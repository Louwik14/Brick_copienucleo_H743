
build/ch.elf:     file format elf32-littlearm


Disassembly of section .vectors:

08000000 <__vectors_base__>:
 8000000:	20000400 	.word	0x20000400
 8000004:	080003b9 	.word	0x080003b9
 8000008:	080003bb 	.word	0x080003bb
 800000c:	080003bb 	.word	0x080003bb
 8000010:	080003bb 	.word	0x080003bb
 8000014:	080003bb 	.word	0x080003bb
 8000018:	080003bb 	.word	0x080003bb
 800001c:	080003bb 	.word	0x080003bb
 8000020:	080003bb 	.word	0x080003bb
 8000024:	080003bb 	.word	0x080003bb
 8000028:	080003bb 	.word	0x080003bb
 800002c:	08004d11 	.word	0x08004d11
 8000030:	080003bb 	.word	0x080003bb
 8000034:	080003bb 	.word	0x080003bb
 8000038:	080003bb 	.word	0x080003bb
 800003c:	080003bb 	.word	0x080003bb
 8000040:	080003bb 	.word	0x080003bb
 8000044:	080003bb 	.word	0x080003bb
 8000048:	080003bb 	.word	0x080003bb
 800004c:	080003bb 	.word	0x080003bb
 8000050:	080003bb 	.word	0x080003bb
 8000054:	080003bb 	.word	0x080003bb
 8000058:	080003bb 	.word	0x080003bb
 800005c:	080003bb 	.word	0x080003bb
 8000060:	080003bb 	.word	0x080003bb
 8000064:	080003bb 	.word	0x080003bb
 8000068:	080003bb 	.word	0x080003bb
 800006c:	08003131 	.word	0x08003131
 8000070:	080031c1 	.word	0x080031c1
 8000074:	08003251 	.word	0x08003251
 8000078:	080032e1 	.word	0x080032e1
 800007c:	08003371 	.word	0x08003371
 8000080:	08003401 	.word	0x08003401
 8000084:	08003491 	.word	0x08003491
 8000088:	08002bb1 	.word	0x08002bb1
 800008c:	080003bb 	.word	0x080003bb
 8000090:	080003bb 	.word	0x080003bb
 8000094:	080003bb 	.word	0x080003bb
 8000098:	080003bb 	.word	0x080003bb
 800009c:	080003bb 	.word	0x080003bb
 80000a0:	080003bb 	.word	0x080003bb
 80000a4:	080003bb 	.word	0x080003bb
 80000a8:	080003bb 	.word	0x080003bb
 80000ac:	080003bb 	.word	0x080003bb
 80000b0:	08002a31 	.word	0x08002a31
 80000b4:	080003bb 	.word	0x080003bb
 80000b8:	080003bb 	.word	0x080003bb
 80000bc:	080003bb 	.word	0x080003bb
 80000c0:	080003bb 	.word	0x080003bb
 80000c4:	080003bb 	.word	0x080003bb
 80000c8:	080003bb 	.word	0x080003bb
 80000cc:	08003f41 	.word	0x08003f41
 80000d0:	08003fc1 	.word	0x08003fc1
 80000d4:	080003bb 	.word	0x080003bb
 80000d8:	080003bb 	.word	0x080003bb
 80000dc:	08002811 	.word	0x08002811
 80000e0:	080003bb 	.word	0x080003bb
 80000e4:	080003bb 	.word	0x080003bb
 80000e8:	080003bb 	.word	0x080003bb
 80000ec:	080003bb 	.word	0x080003bb
 80000f0:	080003bb 	.word	0x080003bb
 80000f4:	080003bb 	.word	0x080003bb
 80000f8:	080003bb 	.word	0x080003bb
 80000fc:	08003521 	.word	0x08003521
 8000100:	080003bb 	.word	0x080003bb
 8000104:	08002781 	.word	0x08002781
 8000108:	080003bb 	.word	0x080003bb
 800010c:	08004041 	.word	0x08004041
 8000110:	080003bb 	.word	0x080003bb
 8000114:	080003bb 	.word	0x080003bb
 8000118:	080003bb 	.word	0x080003bb
 800011c:	080003bb 	.word	0x080003bb
 8000120:	080035b1 	.word	0x080035b1
 8000124:	08003641 	.word	0x08003641
 8000128:	080036d1 	.word	0x080036d1
 800012c:	08003761 	.word	0x08003761
 8000130:	080037f1 	.word	0x080037f1
 8000134:	080003bb 	.word	0x080003bb
 8000138:	080003bb 	.word	0x080003bb
 800013c:	080003bb 	.word	0x080003bb
 8000140:	080003bb 	.word	0x080003bb
 8000144:	080003bb 	.word	0x080003bb
 8000148:	080003bb 	.word	0x080003bb
 800014c:	080003bb 	.word	0x080003bb
 8000150:	08003881 	.word	0x08003881
 8000154:	08003911 	.word	0x08003911
 8000158:	080039a1 	.word	0x080039a1
 800015c:	080003bb 	.word	0x080003bb
 8000160:	080003bb 	.word	0x080003bb
 8000164:	080003bb 	.word	0x080003bb
 8000168:	080003bb 	.word	0x080003bb
 800016c:	080003bb 	.word	0x080003bb
 8000170:	080003bb 	.word	0x080003bb
 8000174:	080003bb 	.word	0x080003bb
 8000178:	080003bb 	.word	0x080003bb
 800017c:	080003bb 	.word	0x080003bb
 8000180:	080003bb 	.word	0x080003bb
 8000184:	080003bb 	.word	0x080003bb
 8000188:	080003bb 	.word	0x080003bb
 800018c:	080003bb 	.word	0x080003bb
 8000190:	080003bb 	.word	0x080003bb
 8000194:	080040c1 	.word	0x080040c1
 8000198:	08004141 	.word	0x08004141
 800019c:	080003bb 	.word	0x080003bb
 80001a0:	080003bb 	.word	0x080003bb
 80001a4:	080003bb 	.word	0x080003bb
 80001a8:	080003bb 	.word	0x080003bb
 80001ac:	080003bb 	.word	0x080003bb
 80001b0:	080003bb 	.word	0x080003bb
 80001b4:	080003bb 	.word	0x080003bb
 80001b8:	080003bb 	.word	0x080003bb
 80001bc:	080003bb 	.word	0x080003bb
 80001c0:	080003bb 	.word	0x080003bb
 80001c4:	080003bb 	.word	0x080003bb
 80001c8:	080003bb 	.word	0x080003bb
 80001cc:	080003bb 	.word	0x080003bb
 80001d0:	080003bb 	.word	0x080003bb
 80001d4:	08003a31 	.word	0x08003a31
 80001d8:	080003bb 	.word	0x080003bb
 80001dc:	080003bb 	.word	0x080003bb
 80001e0:	080003bb 	.word	0x080003bb
 80001e4:	080003bb 	.word	0x080003bb
 80001e8:	080003bb 	.word	0x080003bb
 80001ec:	080003bb 	.word	0x080003bb
 80001f0:	080003bb 	.word	0x080003bb
 80001f4:	080003bb 	.word	0x080003bb
 80001f8:	080003bb 	.word	0x080003bb
 80001fc:	080003bb 	.word	0x080003bb
 8000200:	080003bb 	.word	0x080003bb
 8000204:	080003bb 	.word	0x080003bb
 8000208:	080003bb 	.word	0x080003bb
 800020c:	080003bb 	.word	0x080003bb
 8000210:	080003bb 	.word	0x080003bb
 8000214:	080003bb 	.word	0x080003bb
 8000218:	080003bb 	.word	0x080003bb
 800021c:	080003bb 	.word	0x080003bb
 8000220:	080003bb 	.word	0x080003bb
 8000224:	080003bb 	.word	0x080003bb
 8000228:	080003bb 	.word	0x080003bb
 800022c:	080003bb 	.word	0x080003bb
 8000230:	080003bb 	.word	0x080003bb
 8000234:	080003bb 	.word	0x080003bb
 8000238:	080003bb 	.word	0x080003bb
 800023c:	08002c31 	.word	0x08002c31
 8000240:	080003bb 	.word	0x080003bb
 8000244:	08002cb1 	.word	0x08002cb1
 8000248:	08002d41 	.word	0x08002d41
 800024c:	08002dd1 	.word	0x08002dd1
 8000250:	08002e61 	.word	0x08002e61
 8000254:	08002ef1 	.word	0x08002ef1
 8000258:	08002f81 	.word	0x08002f81
 800025c:	08003011 	.word	0x08003011
 8000260:	080030a1 	.word	0x080030a1
 8000264:	080003bb 	.word	0x080003bb
 8000268:	080003bb 	.word	0x080003bb
 800026c:	080003bb 	.word	0x080003bb
 8000270:	080003bb 	.word	0x080003bb
 8000274:	080003bb 	.word	0x080003bb
 8000278:	080003bb 	.word	0x080003bb
 800027c:	080003bb 	.word	0x080003bb
 8000280:	080003bb 	.word	0x080003bb
 8000284:	080003bb 	.word	0x080003bb
 8000288:	080003bb 	.word	0x080003bb
 800028c:	080003bb 	.word	0x080003bb
 8000290:	080003bb 	.word	0x080003bb
 8000294:	080003bb 	.word	0x080003bb
 8000298:	080003bb 	.word	0x080003bb
 800029c:	080003bb 	.word	0x080003bb
 80002a0:	080003bb 	.word	0x080003bb
 80002a4:	080003bb 	.word	0x080003bb
 80002a8:	080003bb 	.word	0x080003bb
 80002ac:	080003bb 	.word	0x080003bb
 80002b0:	080003bb 	.word	0x080003bb
 80002b4:	080003bb 	.word	0x080003bb
 80002b8:	080003bb 	.word	0x080003bb
 80002bc:	080003bb 	.word	0x080003bb
 80002c0:	080003bb 	.word	0x080003bb
 80002c4:	080003bb 	.word	0x080003bb
 80002c8:	080003bb 	.word	0x080003bb
 80002cc:	080003bb 	.word	0x080003bb
 80002d0:	080003bb 	.word	0x080003bb
 80002d4:	080003bb 	.word	0x080003bb
 80002d8:	080003bb 	.word	0x080003bb
 80002dc:	080003bb 	.word	0x080003bb

Disassembly of section .text:

080002e0 <_crt0_entry>:
                .align  2
                .thumb_func
                .global _crt0_entry
_crt0_entry:
                /* Interrupts are globally masked initially.*/
                cpsid   i
 80002e0:	b672      	cpsid	i

#if CRT0_FORCE_MSP_INIT == TRUE
                /* MSP stack pointers initialization.*/
                ldr     r0, =__main_stack_end__
 80002e2:	4826      	ldr	r0, [pc, #152]	; (800037c <endfiniloop+0x6>)
                msr     MSP, r0
 80002e4:	f380 8808 	msr	MSP, r0
#endif

                /* PSP stack pointers initialization.*/
                ldr     r0, =__process_stack_end__
 80002e8:	4825      	ldr	r0, [pc, #148]	; (8000380 <endfiniloop+0xa>)
                msr     PSP, r0
 80002ea:	f380 8809 	msr	PSP, r0

#if CRT0_VTOR_INIT == TRUE
                /* Initial VTOR position enforced.*/
                ldr     r0, =_vectors
 80002ee:	4825      	ldr	r0, [pc, #148]	; (8000384 <endfiniloop+0xe>)
                ldr     r1, =SCB_VTOR
 80002f0:	4925      	ldr	r1, [pc, #148]	; (8000388 <endfiniloop+0x12>)
                str     r0, [r1]
 80002f2:	6008      	str	r0, [r1, #0]

                /* Enforcing FPCA bit in the CONTROL register.*/
                movs    r0, #CRT0_CONTROL_INIT | CONTROL_FPCA

#else
                movs    r0, #CRT0_CONTROL_INIT
 80002f4:	2002      	movs	r0, #2
#endif

                /* CONTROL register initialization as configured.*/
                msr     CONTROL, r0
 80002f6:	f380 8814 	msr	CONTROL, r0
                isb
 80002fa:	f3bf 8f6f 	isb	sy

#if CRT0_INIT_CORE == TRUE
                /* Core initialization.*/
                bl      __cpu_init
 80002fe:	f002 f9b7 	bl	8002670 <__cpu_init>
#endif

                /* Early initialization.*/
                bl      __early_init
 8000302:	f003 ff5d 	bl	80041c0 <__early_init>

#if CRT0_INIT_STACKS == TRUE
                ldr     r0, =CRT0_STACKS_FILL_PATTERN
 8000306:	f04f 3055 	mov.w	r0, #1431655765	; 0x55555555
                /* Main Stack initialization. Note, it assumes that the
                   stack size is a multiple of 4 so the linker file must
                   ensure this.*/
                ldr     r1, =__main_stack_base__
 800030a:	4920      	ldr	r1, [pc, #128]	; (800038c <endfiniloop+0x16>)
                ldr     r2, =__main_stack_end__
 800030c:	4a1b      	ldr	r2, [pc, #108]	; (800037c <endfiniloop+0x6>)

0800030e <msloop>:
msloop:
                cmp     r1, r2
 800030e:	4291      	cmp	r1, r2
                itt     lo
 8000310:	bf3c      	itt	cc
                strlo   r0, [r1], #4
 8000312:	f841 0b04 	strcc.w	r0, [r1], #4
                blo     msloop
 8000316:	e7fa      	bcc.n	800030e <msloop>

                /* Process Stack initialization. Note, it assumes that the
                   stack size is a multiple of 4 so the linker file must
                   ensure this.*/
                ldr     r1, =__process_stack_base__
 8000318:	491d      	ldr	r1, [pc, #116]	; (8000390 <endfiniloop+0x1a>)
                ldr     r2, =__process_stack_end__
 800031a:	4a19      	ldr	r2, [pc, #100]	; (8000380 <endfiniloop+0xa>)

0800031c <psloop>:
psloop:
                cmp     r1, r2
 800031c:	4291      	cmp	r1, r2
                itt     lo
 800031e:	bf3c      	itt	cc
                strlo   r0, [r1], #4
 8000320:	f841 0b04 	strcc.w	r0, [r1], #4
                blo     psloop
 8000324:	e7fa      	bcc.n	800031c <psloop>

#if CRT0_INIT_DATA == TRUE
                /* Data initialization. Note, it assumes that the DATA
                   size is a multiple of 4 so the linker file must ensure
                   this.*/
                ldr     r1, =__textdata_base__
 8000326:	491b      	ldr	r1, [pc, #108]	; (8000394 <endfiniloop+0x1e>)
                ldr     r2, =__data_base__
 8000328:	4a1b      	ldr	r2, [pc, #108]	; (8000398 <endfiniloop+0x22>)
                ldr     r3, =__data_end__
 800032a:	4b1c      	ldr	r3, [pc, #112]	; (800039c <endfiniloop+0x26>)

0800032c <dloop>:
dloop:
                cmp     r2, r3
 800032c:	429a      	cmp	r2, r3
                ittt    lo
 800032e:	bf3e      	ittt	cc
                ldrlo   r0, [r1], #4
 8000330:	f851 0b04 	ldrcc.w	r0, [r1], #4
                strlo   r0, [r2], #4
 8000334:	f842 0b04 	strcc.w	r0, [r2], #4
                blo     dloop
 8000338:	e7f8      	bcc.n	800032c <dloop>

#if CRT0_INIT_BSS == TRUE
                /* BSS initialization. Note, it assumes that the BSS
                   size is a multiple of 4 so the linker file must ensure
                   this.*/
                movs    r0, #0
 800033a:	2000      	movs	r0, #0
                ldr     r1, =__bss_base__
 800033c:	4918      	ldr	r1, [pc, #96]	; (80003a0 <endfiniloop+0x2a>)
                ldr     r2, =__bss_end__
 800033e:	4a19      	ldr	r2, [pc, #100]	; (80003a4 <endfiniloop+0x2e>)

08000340 <bloop>:
bloop:
                cmp     r1, r2
 8000340:	4291      	cmp	r1, r2
                itt     lo
 8000342:	bf3c      	itt	cc
                strlo   r0, [r1], #4
 8000344:	f841 0b04 	strcc.w	r0, [r1], #4
                blo     bloop
 8000348:	e7fa      	bcc.n	8000340 <bloop>
#endif

#if CRT0_INIT_RAM_AREAS == TRUE
                /* RAM areas initialization.*/
                bl      __init_ram_areas
 800034a:	f002 f9e1 	bl	8002710 <__init_ram_areas>
#endif

                /* Late initialization..*/
                bl      __late_init
 800034e:	f002 f9cf 	bl	80026f0 <__late_init>

#if CRT0_CALL_CONSTRUCTORS == TRUE
                /* Constructors invocation.*/
                ldr     r4, =__init_array_base__
 8000352:	4c15      	ldr	r4, [pc, #84]	; (80003a8 <endfiniloop+0x32>)
                ldr     r5, =__init_array_end__
 8000354:	4d15      	ldr	r5, [pc, #84]	; (80003ac <endfiniloop+0x36>)

08000356 <initloop>:
initloop:
                cmp     r4, r5
 8000356:	42ac      	cmp	r4, r5
                bge     endinitloop
 8000358:	da03      	bge.n	8000362 <endinitloop>
                ldr     r1, [r4], #4
 800035a:	f854 1b04 	ldr.w	r1, [r4], #4
                blx     r1
 800035e:	4788      	blx	r1
                b       initloop
 8000360:	e7f9      	b.n	8000356 <initloop>

08000362 <endinitloop>:
endinitloop:
#endif

                /* Main program invocation, r0 contains the returned value.*/
                bl      main
 8000362:	f004 fce5 	bl	8004d30 <main>

#if CRT0_CALL_DESTRUCTORS == TRUE
                /* Destructors invocation.*/
                ldr     r4, =__fini_array_base__
 8000366:	4c12      	ldr	r4, [pc, #72]	; (80003b0 <endfiniloop+0x3a>)
                ldr     r5, =__fini_array_end__
 8000368:	4d12      	ldr	r5, [pc, #72]	; (80003b4 <endfiniloop+0x3e>)

0800036a <finiloop>:
finiloop:
                cmp     r4, r5
 800036a:	42ac      	cmp	r4, r5
                bge     endfiniloop
 800036c:	da03      	bge.n	8000376 <endfiniloop>
                ldr     r1, [r4], #4
 800036e:	f854 1b04 	ldr.w	r1, [r4], #4
                blx     r1
 8000372:	4788      	blx	r1
                b       finiloop
 8000374:	e7f9      	b.n	800036a <finiloop>

08000376 <endfiniloop>:
endfiniloop:
#endif

                /* Branching to the defined exit handler.*/
                b       __default_exit
 8000376:	f002 b9c3 	b.w	8002700 <__default_exit>
 800037a:	0000      	.short	0x0000
                ldr     r0, =__main_stack_end__
 800037c:	20000400 	.word	0x20000400
                ldr     r0, =__process_stack_end__
 8000380:	20000800 	.word	0x20000800
                ldr     r0, =_vectors
 8000384:	08000000 	.word	0x08000000
                ldr     r1, =SCB_VTOR
 8000388:	e000ed08 	.word	0xe000ed08
                ldr     r1, =__main_stack_base__
 800038c:	20000000 	.word	0x20000000
                ldr     r1, =__process_stack_base__
 8000390:	20000400 	.word	0x20000400
                ldr     r1, =__textdata_base__
 8000394:	08005f64 	.word	0x08005f64
                ldr     r2, =__data_base__
 8000398:	24000000 	.word	0x24000000
                ldr     r3, =__data_end__
 800039c:	24000000 	.word	0x24000000
                ldr     r1, =__bss_base__
 80003a0:	24000000 	.word	0x24000000
                ldr     r2, =__bss_end__
 80003a4:	24001830 	.word	0x24001830
                ldr     r4, =__init_array_base__
 80003a8:	080002e0 	.word	0x080002e0
                ldr     r5, =__init_array_end__
 80003ac:	080002e0 	.word	0x080002e0
                ldr     r4, =__fini_array_base__
 80003b0:	080002e0 	.word	0x080002e0
                ldr     r5, =__fini_array_end__
 80003b4:	080002e0 	.word	0x080002e0

080003b8 <Reset_Handler>:

        .align      2
        .thumb_func
        .weak       Reset_Handler
Reset_Handler:
         b          _crt0_entry
 80003b8:	e792      	b.n	80002e0 <_crt0_entry>

080003ba <BusFault_Handler>:
        .thumb_func
Vector3F8:
        .thumb_func
Vector3FC:
#endif
        bl          _unhandled_exception
 80003ba:	f000 f800 	bl	80003be <_unhandled_exception>

080003be <_unhandled_exception>:

        .thumb_func
        .weak       _unhandled_exception
_unhandled_exception:
.stay:
        b           .stay
 80003be:	e7fe      	b.n	80003be <_unhandled_exception>

080003c0 <__port_switch>:
 * Performs a context switch between two threads.
 *--------------------------------------------------------------------------*/
                .thumb_func
                .globl  __port_switch
__port_switch:
                push    {r4, r5, r6, r7, r8, r9, r10, r11, lr}
 80003c0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
#if PORT_SWITCHED_REGIONS_NUMBER == 4
                push    {r4, r5, r6, r7, r8, r9, r10, r11}
#endif
#endif

                str     sp, [r1, #CONTEXT_OFFSET]
 80003c4:	f8c1 d00c 	str.w	sp, [r1, #12]
                /* Workaround for ARM errata 752419, only applied if
                   condition exists for it to be triggered.*/
                ldr     r3, [r0, #CONTEXT_OFFSET]
                mov     sp, r3
#else
                ldr     sp, [r0, #CONTEXT_OFFSET]
 80003c8:	f8d0 d00c 	ldr.w	sp, [r0, #12]

#if CORTEX_USE_FPU
                /* Restoring FPU context.*/
                vpop    {s16-s31}
#endif
                pop     {r4, r5, r6, r7, r8, r9, r10, r11, pc}
 80003cc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

080003d0 <__port_thread_start>:
                bl      __stats_stop_measure_crit_thd
#endif
#if CORTEX_SIMPLIFIED_PRIORITY
                cpsie   i
#else
                movs    r3, #0              /* CORTEX_BASEPRI_DISABLED */
 80003d0:	2300      	movs	r3, #0
                msr     BASEPRI, r3
 80003d2:	f383 8811 	msr	BASEPRI, r3
#endif
                mov     r0, r5
 80003d6:	4628      	mov	r0, r5
                blx     r4
 80003d8:	47a0      	blx	r4
                movs    r0, #0              /* MSG_OK */
 80003da:	2000      	movs	r0, #0
                bl      chThdExit
 80003dc:	f004 fc68 	bl	8004cb0 <chThdExit>

080003e0 <.zombies>:
.zombies:       b       .zombies
 80003e0:	e7fe      	b.n	80003e0 <.zombies>

080003e2 <__port_switch_from_isr>:
                bl      __stats_start_measure_crit_thd
#endif
#if CH_DBG_SYSTEM_STATE_CHECK
                bl      __dbg_check_lock
#endif
                bl      chSchDoPreemption
 80003e2:	f004 f8dd 	bl	80045a0 <chSchDoPreemption>

080003e6 <__port_exit_from_isr>:
                movt    r3, #:upper16:SCB_ICSR
                mov     r2, ICSR_PENDSVSET
                str     r2, [r3, #0]
                cpsie   i
#else /* !CORTEX_SIMPLIFIED_PRIORITY */
                svc     #0
 80003e6:	df00      	svc	0
#endif /* !CORTEX_SIMPLIFIED_PRIORITY */
.L1:            b       .L1
 80003e8:	e7fe      	b.n	80003e8 <__port_exit_from_isr+0x2>
	...

080003ec <memcpy>:
 80003ec:	4684      	mov	ip, r0
 80003ee:	ea41 0300 	orr.w	r3, r1, r0
 80003f2:	f013 0303 	ands.w	r3, r3, #3
 80003f6:	d16d      	bne.n	80004d4 <memcpy+0xe8>
 80003f8:	3a40      	subs	r2, #64	; 0x40
 80003fa:	d341      	bcc.n	8000480 <memcpy+0x94>
 80003fc:	f851 3b04 	ldr.w	r3, [r1], #4
 8000400:	f840 3b04 	str.w	r3, [r0], #4
 8000404:	f851 3b04 	ldr.w	r3, [r1], #4
 8000408:	f840 3b04 	str.w	r3, [r0], #4
 800040c:	f851 3b04 	ldr.w	r3, [r1], #4
 8000410:	f840 3b04 	str.w	r3, [r0], #4
 8000414:	f851 3b04 	ldr.w	r3, [r1], #4
 8000418:	f840 3b04 	str.w	r3, [r0], #4
 800041c:	f851 3b04 	ldr.w	r3, [r1], #4
 8000420:	f840 3b04 	str.w	r3, [r0], #4
 8000424:	f851 3b04 	ldr.w	r3, [r1], #4
 8000428:	f840 3b04 	str.w	r3, [r0], #4
 800042c:	f851 3b04 	ldr.w	r3, [r1], #4
 8000430:	f840 3b04 	str.w	r3, [r0], #4
 8000434:	f851 3b04 	ldr.w	r3, [r1], #4
 8000438:	f840 3b04 	str.w	r3, [r0], #4
 800043c:	f851 3b04 	ldr.w	r3, [r1], #4
 8000440:	f840 3b04 	str.w	r3, [r0], #4
 8000444:	f851 3b04 	ldr.w	r3, [r1], #4
 8000448:	f840 3b04 	str.w	r3, [r0], #4
 800044c:	f851 3b04 	ldr.w	r3, [r1], #4
 8000450:	f840 3b04 	str.w	r3, [r0], #4
 8000454:	f851 3b04 	ldr.w	r3, [r1], #4
 8000458:	f840 3b04 	str.w	r3, [r0], #4
 800045c:	f851 3b04 	ldr.w	r3, [r1], #4
 8000460:	f840 3b04 	str.w	r3, [r0], #4
 8000464:	f851 3b04 	ldr.w	r3, [r1], #4
 8000468:	f840 3b04 	str.w	r3, [r0], #4
 800046c:	f851 3b04 	ldr.w	r3, [r1], #4
 8000470:	f840 3b04 	str.w	r3, [r0], #4
 8000474:	f851 3b04 	ldr.w	r3, [r1], #4
 8000478:	f840 3b04 	str.w	r3, [r0], #4
 800047c:	3a40      	subs	r2, #64	; 0x40
 800047e:	d2bd      	bcs.n	80003fc <memcpy+0x10>
 8000480:	3230      	adds	r2, #48	; 0x30
 8000482:	d311      	bcc.n	80004a8 <memcpy+0xbc>
 8000484:	f851 3b04 	ldr.w	r3, [r1], #4
 8000488:	f840 3b04 	str.w	r3, [r0], #4
 800048c:	f851 3b04 	ldr.w	r3, [r1], #4
 8000490:	f840 3b04 	str.w	r3, [r0], #4
 8000494:	f851 3b04 	ldr.w	r3, [r1], #4
 8000498:	f840 3b04 	str.w	r3, [r0], #4
 800049c:	f851 3b04 	ldr.w	r3, [r1], #4
 80004a0:	f840 3b04 	str.w	r3, [r0], #4
 80004a4:	3a10      	subs	r2, #16
 80004a6:	d2ed      	bcs.n	8000484 <memcpy+0x98>
 80004a8:	320c      	adds	r2, #12
 80004aa:	d305      	bcc.n	80004b8 <memcpy+0xcc>
 80004ac:	f851 3b04 	ldr.w	r3, [r1], #4
 80004b0:	f840 3b04 	str.w	r3, [r0], #4
 80004b4:	3a04      	subs	r2, #4
 80004b6:	d2f9      	bcs.n	80004ac <memcpy+0xc0>
 80004b8:	3204      	adds	r2, #4
 80004ba:	d008      	beq.n	80004ce <memcpy+0xe2>
 80004bc:	07d2      	lsls	r2, r2, #31
 80004be:	bf1c      	itt	ne
 80004c0:	f811 3b01 	ldrbne.w	r3, [r1], #1
 80004c4:	f800 3b01 	strbne.w	r3, [r0], #1
 80004c8:	d301      	bcc.n	80004ce <memcpy+0xe2>
 80004ca:	880b      	ldrh	r3, [r1, #0]
 80004cc:	8003      	strh	r3, [r0, #0]
 80004ce:	4660      	mov	r0, ip
 80004d0:	4770      	bx	lr
 80004d2:	bf00      	nop
 80004d4:	2a08      	cmp	r2, #8
 80004d6:	d313      	bcc.n	8000500 <memcpy+0x114>
 80004d8:	078b      	lsls	r3, r1, #30
 80004da:	d08d      	beq.n	80003f8 <memcpy+0xc>
 80004dc:	f010 0303 	ands.w	r3, r0, #3
 80004e0:	d08a      	beq.n	80003f8 <memcpy+0xc>
 80004e2:	f1c3 0304 	rsb	r3, r3, #4
 80004e6:	1ad2      	subs	r2, r2, r3
 80004e8:	07db      	lsls	r3, r3, #31
 80004ea:	bf1c      	itt	ne
 80004ec:	f811 3b01 	ldrbne.w	r3, [r1], #1
 80004f0:	f800 3b01 	strbne.w	r3, [r0], #1
 80004f4:	d380      	bcc.n	80003f8 <memcpy+0xc>
 80004f6:	f831 3b02 	ldrh.w	r3, [r1], #2
 80004fa:	f820 3b02 	strh.w	r3, [r0], #2
 80004fe:	e77b      	b.n	80003f8 <memcpy+0xc>
 8000500:	3a04      	subs	r2, #4
 8000502:	d3d9      	bcc.n	80004b8 <memcpy+0xcc>
 8000504:	3a01      	subs	r2, #1
 8000506:	f811 3b01 	ldrb.w	r3, [r1], #1
 800050a:	f800 3b01 	strb.w	r3, [r0], #1
 800050e:	d2f9      	bcs.n	8000504 <memcpy+0x118>
 8000510:	780b      	ldrb	r3, [r1, #0]
 8000512:	7003      	strb	r3, [r0, #0]
 8000514:	784b      	ldrb	r3, [r1, #1]
 8000516:	7043      	strb	r3, [r0, #1]
 8000518:	788b      	ldrb	r3, [r1, #2]
 800051a:	7083      	strb	r3, [r0, #2]
 800051c:	4660      	mov	r0, ip
 800051e:	4770      	bx	lr

08000520 <_mmcsd_get_capacity>:
  /* One or two pieces?*/
  if (startidx < endidx) {
    return (data[startidx] >> startoff) |               /* Two pieces case. */
           ((data[endidx] & endmask) << (32U - startoff));
  }
  return (data[startidx] & endmask) >> startoff;        /* One piece case.  */
 8000520:	68c3      	ldr	r3, [r0, #12]
uint32_t _mmcsd_get_capacity(const uint32_t *csd) {
  uint32_t a, b, c;

  osalDbgCheck(NULL != csd);

  switch (_mmcsd_get_slice(csd, MMCSD_CSD_10_CSD_STRUCTURE_SLICE)) {
 8000522:	0f9b      	lsrs	r3, r3, #30
 8000524:	d00c      	beq.n	8000540 <_mmcsd_get_capacity+0x20>
 8000526:	2b01      	cmp	r3, #1
 8000528:	d108      	bne.n	800053c <_mmcsd_get_capacity+0x1c>
           ((data[endidx] & endmask) << (32U - startoff));
 800052a:	6883      	ldr	r3, [r0, #8]
    return (data[startidx] >> startoff) |               /* Two pieces case. */
 800052c:	88c2      	ldrh	r2, [r0, #6]
           ((data[endidx] & endmask) << (32U - startoff));
 800052e:	0418      	lsls	r0, r3, #16
 8000530:	f400 107c 	and.w	r0, r0, #4128768	; 0x3f0000
    return (data[startidx] >> startoff) |               /* Two pieces case. */
 8000534:	4310      	orrs	r0, r2
    b = _mmcsd_get_slice(csd, MMCSD_CSD_10_C_SIZE_MULT_SLICE);
    c = _mmcsd_get_slice(csd, MMCSD_CSD_10_READ_BL_LEN_SLICE);
    return ((a + 1U) << (b + 2U)) << (c - 9U);  /* 2^9 == MMCSD_BLOCK_SIZE. */
  case 1:
    /* CSD version 2.0.*/
    return 1024U * (_mmcsd_get_slice(csd, MMCSD_CSD_20_C_SIZE_SLICE) + 1U);
 8000536:	3001      	adds	r0, #1
 8000538:	0280      	lsls	r0, r0, #10
  default:
    /* Reserved value detected.*/
    break;
  }
  return 0U;
}
 800053a:	4770      	bx	lr
  switch (_mmcsd_get_slice(csd, MMCSD_CSD_10_CSD_STRUCTURE_SLICE)) {
 800053c:	2000      	movs	r0, #0
 800053e:	4770      	bx	lr
           ((data[endidx] & endmask) << (32U - startoff));
 8000540:	6882      	ldr	r2, [r0, #8]
 8000542:	f640 73fc 	movw	r3, #4092	; 0xffc
    return (data[startidx] >> startoff) |               /* Two pieces case. */
 8000546:	6841      	ldr	r1, [r0, #4]
           ((data[endidx] & endmask) << (32U - startoff));
 8000548:	ea03 0082 	and.w	r0, r3, r2, lsl #2
  return (data[startidx] & endmask) >> startoff;        /* One piece case.  */
 800054c:	f3c2 4203 	ubfx	r2, r2, #16, #4
 8000550:	f3c1 33c2 	ubfx	r3, r1, #15, #3
    return (data[startidx] >> startoff) |               /* Two pieces case. */
 8000554:	ea40 7091 	orr.w	r0, r0, r1, lsr #30
    return ((a + 1U) << (b + 2U)) << (c - 9U);  /* 2^9 == MMCSD_BLOCK_SIZE. */
 8000558:	3a09      	subs	r2, #9
 800055a:	3302      	adds	r3, #2
 800055c:	3001      	adds	r0, #1
 800055e:	4098      	lsls	r0, r3
 8000560:	4090      	lsls	r0, r2
 8000562:	4770      	bx	lr
	...

08000570 <sdc_lld_is_write_protected>:
bool sdc_lld_sync(SDCDriver *sdcp) {

  /* CHTODO: Implement.*/
  (void)sdcp;
  return HAL_SUCCESS;
}
 8000570:	2000      	movs	r0, #0
 8000572:	4770      	bx	lr
	...

08000580 <sdcSync>:
bool sdcSync(SDCDriver *sdcp) {
  bool result;

  osalDbgCheck(sdcp != NULL);

  if (sdcp->state != BLK_READY) {
 8000580:	7900      	ldrb	r0, [r0, #4]
  result = sdc_lld_sync(sdcp);

  /* Synchronization operation finished.*/
  sdcp->state = BLK_READY;
  return result;
}
 8000582:	3805      	subs	r0, #5
 8000584:	bf18      	it	ne
 8000586:	2001      	movne	r0, #1
 8000588:	4770      	bx	lr
 800058a:	bf00      	nop
 800058c:	0000      	movs	r0, r0
	...

08000590 <sdcGetInfo>:
 */
bool sdcGetInfo(SDCDriver *sdcp, BlockDeviceInfo *bdip) {

  osalDbgCheck((sdcp != NULL) && (bdip != NULL));

  if (sdcp->state != BLK_READY) {
 8000590:	7903      	ldrb	r3, [r0, #4]
 8000592:	2b05      	cmp	r3, #5
 8000594:	d106      	bne.n	80005a4 <sdcGetInfo+0x14>
    return HAL_FAILED;
  }

  bdip->blk_num = sdcp->capacity;
 8000596:	6a82      	ldr	r2, [r0, #40]	; 0x28
  bdip->blk_size = MMCSD_BLOCK_SIZE;
 8000598:	f44f 7300 	mov.w	r3, #512	; 0x200

  return HAL_SUCCESS;
 800059c:	2000      	movs	r0, #0
  bdip->blk_size = MMCSD_BLOCK_SIZE;
 800059e:	e9c1 3200 	strd	r3, r2, [r1]
  return HAL_SUCCESS;
 80005a2:	4770      	bx	lr
    return HAL_FAILED;
 80005a4:	2001      	movs	r0, #1
}
 80005a6:	4770      	bx	lr
	...

080005b0 <_ctl>:
    return sd_lld_control(sdp, operation, arg);
#else
    return HAL_RET_UNKNOWN_CTL;
#endif
  }
  return HAL_RET_SUCCESS;
 80005b0:	2901      	cmp	r1, #1
}
 80005b2:	bf14      	ite	ne
 80005b4:	f06f 0013 	mvnne.w	r0, #19
 80005b8:	2000      	moveq	r0, #0
 80005ba:	4770      	bx	lr
 80005bc:	0000      	movs	r0, r0
	...

080005c0 <usb_lld_init_endpoint>:
void usb_lld_init_endpoint(USBDriver *usbp, usbep_t ep) {
  uint32_t ctl, fsize;
  stm32_otg_t *otgp = usbp->otg;

  /* IN and OUT common parameters.*/
  switch (usbp->epc[ep]->ep_mode & USB_EP_MODE_TYPE) {
 80005c0:	eb00 0381 	add.w	r3, r0, r1, lsl #2
  stm32_otg_t *otgp = usbp->otg;
 80005c4:	f8d0 2090 	ldr.w	r2, [r0, #144]	; 0x90
  default:
    return;
  }

  /* OUT endpoint activation or deactivation.*/
  otgp->oe[ep].DOEPTSIZ = 0;
 80005c8:	ea4f 1c41 	mov.w	ip, r1, lsl #5
  switch (usbp->epc[ep]->ep_mode & USB_EP_MODE_TYPE) {
 80005cc:	68db      	ldr	r3, [r3, #12]
void usb_lld_init_endpoint(USBDriver *usbp, usbep_t ep) {
 80005ce:	b5f0      	push	{r4, r5, r6, r7, lr}
  switch (usbp->epc[ep]->ep_mode & USB_EP_MODE_TYPE) {
 80005d0:	681c      	ldr	r4, [r3, #0]
  otgp->oe[ep].DOEPTSIZ = 0;
 80005d2:	2600      	movs	r6, #0
  switch (usbp->epc[ep]->ep_mode & USB_EP_MODE_TYPE) {
 80005d4:	f004 0403 	and.w	r4, r4, #3
 80005d8:	1e65      	subs	r5, r4, #1
 80005da:	2d02      	cmp	r5, #2
 80005dc:	4d45      	ldr	r5, [pc, #276]	; (80006f4 <usb_lld_init_endpoint+0x134>)
 80005de:	bf98      	it	ls
 80005e0:	eb05 4584 	addls.w	r5, r5, r4, lsl #18
  otgp->oe[ep].DOEPTSIZ = 0;
 80005e4:	eb02 1441 	add.w	r4, r2, r1, lsl #5
 80005e8:	f8c4 6b10 	str.w	r6, [r4, #2832]	; 0xb10
  if (usbp->epc[ep]->out_state != NULL) {
 80005ec:	699c      	ldr	r4, [r3, #24]
 80005ee:	2c00      	cmp	r4, #0
 80005f0:	d048      	beq.n	8000684 <usb_lld_init_endpoint+0xc4>
    otgp->oe[ep].DOEPCTL = ctl | DOEPCTL_MPSIZ(usbp->epc[ep]->out_maxsize);
 80005f2:	8a5e      	ldrh	r6, [r3, #18]
 80005f4:	f101 0458 	add.w	r4, r1, #88	; 0x58
 80005f8:	432e      	orrs	r6, r5
 80005fa:	0164      	lsls	r4, r4, #5
 80005fc:	5116      	str	r6, [r2, r4]
    otgp->DAINTMSK |= DAINTMSK_OEPM(ep);
 80005fe:	f101 0610 	add.w	r6, r1, #16
 8000602:	2401      	movs	r4, #1
 8000604:	40b4      	lsls	r4, r6
 8000606:	f8d2 681c 	ldr.w	r6, [r2, #2076]	; 0x81c
 800060a:	4334      	orrs	r4, r6
 800060c:	f8c2 481c 	str.w	r4, [r2, #2076]	; 0x81c
    otgp->oe[ep].DOEPCTL &= ~DOEPCTL_USBAEP;
    otgp->DAINTMSK &= ~DAINTMSK_OEPM(ep);
  }

  /* IN endpoint activation or deactivation.*/
  otgp->ie[ep].DIEPTSIZ = 0;
 8000610:	eb02 040c 	add.w	r4, r2, ip
 8000614:	2600      	movs	r6, #0
 8000616:	f8c4 6910 	str.w	r6, [r4, #2320]	; 0x910
  if (usbp->epc[ep]->in_state != NULL) {
 800061a:	695c      	ldr	r4, [r3, #20]
 800061c:	2c00      	cmp	r4, #0
 800061e:	d044      	beq.n	80006aa <usb_lld_init_endpoint+0xea>
    /* FIFO allocation for the IN endpoint.*/
    fsize = usbp->epc[ep]->in_maxsize / 4;
 8000620:	f8b3 c010 	ldrh.w	ip, [r3, #16]
    if (usbp->epc[ep]->in_multiplier > 1)
      fsize *= usbp->epc[ep]->in_multiplier;
    otgp->DIEPTXF[ep - 1] = DIEPTXF_INEPTXFD(fsize) |
 8000624:	f101 0e3f 	add.w	lr, r1, #63	; 0x3f
    if (usbp->epc[ep]->in_multiplier > 1)
 8000628:	8b9b      	ldrh	r3, [r3, #28]
  otgp->GRSTCTL = GRSTCTL_TXFNUM(fifo) | GRSTCTL_TXFFLSH;
 800062a:	018e      	lsls	r6, r1, #6
    fsize = usbp->epc[ep]->in_maxsize / 4;
 800062c:	ea4f 049c 	mov.w	r4, ip, lsr #2
    if (usbp->epc[ep]->in_multiplier > 1)
 8000630:	2b01      	cmp	r3, #1
    otgp->DIEPTXF[ep - 1] = DIEPTXF_INEPTXFD(fsize) |
 8000632:	eb02 0e8e 	add.w	lr, r2, lr, lsl #2
  otgp->GRSTCTL = GRSTCTL_TXFNUM(fifo) | GRSTCTL_TXFFLSH;
 8000636:	f046 0620 	orr.w	r6, r6, #32
      fsize *= usbp->epc[ep]->in_multiplier;
 800063a:	bf88      	it	hi
 800063c:	435c      	mulhi	r4, r3
  next = usbp->pmnext;
 800063e:	f8d0 3098 	ldr.w	r3, [r0, #152]	; 0x98
  usbp->pmnext += size;
 8000642:	18e7      	adds	r7, r4, r3
    otgp->DIEPTXF[ep - 1] = DIEPTXF_INEPTXFD(fsize) |
 8000644:	ea43 4304 	orr.w	r3, r3, r4, lsl #16
  usbp->pmnext += size;
 8000648:	f8c0 7098 	str.w	r7, [r0, #152]	; 0x98
    otgp->DIEPTXF[ep - 1] = DIEPTXF_INEPTXFD(fsize) |
 800064c:	f8ce 3004 	str.w	r3, [lr, #4]
  otgp->GRSTCTL = GRSTCTL_TXFNUM(fifo) | GRSTCTL_TXFFLSH;
 8000650:	6116      	str	r6, [r2, #16]
  while ((otgp->GRSTCTL & GRSTCTL_TXFFLSH) != 0)
 8000652:	6913      	ldr	r3, [r2, #16]
 8000654:	0698      	lsls	r0, r3, #26
 8000656:	d4fc      	bmi.n	8000652 <usb_lld_init_endpoint+0x92>
 *
 * @return              The realtime counter value.
 */
__STATIC_FORCEINLINE rtcnt_t port_rt_get_counter_value(void) {

  return DWT->CYCCNT;
 8000658:	4827      	ldr	r0, [pc, #156]	; (80006f8 <usb_lld_init_endpoint+0x138>)
 800065a:	6844      	ldr	r4, [r0, #4]
 800065c:	6843      	ldr	r3, [r0, #4]
 *
 * @xclass
 */
bool chSysIsCounterWithinX(rtcnt_t cnt, rtcnt_t start, rtcnt_t end) {

  return (bool)(((rtcnt_t)cnt - (rtcnt_t)start) <
 800065e:	1b1b      	subs	r3, r3, r4
 */
void chSysPolledDelayX(rtcnt_t cycles) {
  rtcnt_t start = chSysGetRealtimeCounterX();
  rtcnt_t end  = start + cycles;

  while (chSysIsCounterWithinX(chSysGetRealtimeCounterX(), start, end)) {
 8000660:	2b11      	cmp	r3, #17
 8000662:	d9fb      	bls.n	800065c <usb_lld_init_endpoint+0x9c>
                            DIEPTXF_INEPTXSA(otg_ram_alloc(usbp, fsize));
    otg_txfifo_flush(usbp, ep);

    otgp->ie[ep].DIEPCTL = ctl |
                           DIEPCTL_TXFNUM(ep) |
 8000664:	ea4c 5c81 	orr.w	ip, ip, r1, lsl #22
    otgp->ie[ep].DIEPCTL = ctl |
 8000668:	f101 0048 	add.w	r0, r1, #72	; 0x48
                           DIEPCTL_MPSIZ(usbp->epc[ep]->in_maxsize);
    otgp->DAINTMSK |= DAINTMSK_IEPM(ep);
 800066c:	2301      	movs	r3, #1
    otgp->ie[ep].DIEPCTL = ctl |
 800066e:	0140      	lsls	r0, r0, #5
                           DIEPCTL_TXFNUM(ep) |
 8000670:	ea4c 0505 	orr.w	r5, ip, r5
    otgp->DAINTMSK |= DAINTMSK_IEPM(ep);
 8000674:	408b      	lsls	r3, r1
    otgp->ie[ep].DIEPCTL = ctl |
 8000676:	5015      	str	r5, [r2, r0]
    otgp->DAINTMSK |= DAINTMSK_IEPM(ep);
 8000678:	f8d2 081c 	ldr.w	r0, [r2, #2076]	; 0x81c
 800067c:	4303      	orrs	r3, r0
 800067e:	f8c2 381c 	str.w	r3, [r2, #2076]	; 0x81c
    otgp->DIEPTXF[ep - 1] = 0x02000400; /* Reset value.*/
    otg_txfifo_flush(usbp, ep);
    otgp->ie[ep].DIEPCTL &= ~DIEPCTL_USBAEP;
    otgp->DAINTMSK &= ~DAINTMSK_IEPM(ep);
  }
}
 8000682:	bdf0      	pop	{r4, r5, r6, r7, pc}
    otgp->oe[ep].DOEPCTL &= ~DOEPCTL_USBAEP;
 8000684:	eb02 1441 	add.w	r4, r2, r1, lsl #5
    otgp->DAINTMSK &= ~DAINTMSK_OEPM(ep);
 8000688:	f101 0710 	add.w	r7, r1, #16
 800068c:	2601      	movs	r6, #1
 800068e:	40be      	lsls	r6, r7
    otgp->oe[ep].DOEPCTL &= ~DOEPCTL_USBAEP;
 8000690:	f8d4 7b00 	ldr.w	r7, [r4, #2816]	; 0xb00
 8000694:	f427 4700 	bic.w	r7, r7, #32768	; 0x8000
 8000698:	f8c4 7b00 	str.w	r7, [r4, #2816]	; 0xb00
    otgp->DAINTMSK &= ~DAINTMSK_OEPM(ep);
 800069c:	f8d2 481c 	ldr.w	r4, [r2, #2076]	; 0x81c
 80006a0:	ea24 0406 	bic.w	r4, r4, r6
 80006a4:	f8c2 481c 	str.w	r4, [r2, #2076]	; 0x81c
 80006a8:	e7b2      	b.n	8000610 <usb_lld_init_endpoint+0x50>
    otgp->DIEPTXF[ep - 1] = 0x02000400; /* Reset value.*/
 80006aa:	f101 003f 	add.w	r0, r1, #63	; 0x3f
  otgp->GRSTCTL = GRSTCTL_TXFNUM(fifo) | GRSTCTL_TXFFLSH;
 80006ae:	018b      	lsls	r3, r1, #6
    otgp->DIEPTXF[ep - 1] = 0x02000400; /* Reset value.*/
 80006b0:	4c12      	ldr	r4, [pc, #72]	; (80006fc <usb_lld_init_endpoint+0x13c>)
 80006b2:	eb02 0080 	add.w	r0, r2, r0, lsl #2
  otgp->GRSTCTL = GRSTCTL_TXFNUM(fifo) | GRSTCTL_TXFFLSH;
 80006b6:	f043 0320 	orr.w	r3, r3, #32
    otgp->DIEPTXF[ep - 1] = 0x02000400; /* Reset value.*/
 80006ba:	6044      	str	r4, [r0, #4]
  otgp->GRSTCTL = GRSTCTL_TXFNUM(fifo) | GRSTCTL_TXFFLSH;
 80006bc:	6113      	str	r3, [r2, #16]
  while ((otgp->GRSTCTL & GRSTCTL_TXFFLSH) != 0)
 80006be:	6913      	ldr	r3, [r2, #16]
 80006c0:	069b      	lsls	r3, r3, #26
 80006c2:	d4fc      	bmi.n	80006be <usb_lld_init_endpoint+0xfe>
 80006c4:	480c      	ldr	r0, [pc, #48]	; (80006f8 <usb_lld_init_endpoint+0x138>)
 80006c6:	6844      	ldr	r4, [r0, #4]
 80006c8:	6843      	ldr	r3, [r0, #4]
  return (bool)(((rtcnt_t)cnt - (rtcnt_t)start) <
 80006ca:	1b1b      	subs	r3, r3, r4
  while (chSysIsCounterWithinX(chSysGetRealtimeCounterX(), start, end)) {
 80006cc:	2b11      	cmp	r3, #17
 80006ce:	d9fb      	bls.n	80006c8 <usb_lld_init_endpoint+0x108>
    otgp->ie[ep].DIEPCTL &= ~DIEPCTL_USBAEP;
 80006d0:	eb02 1441 	add.w	r4, r2, r1, lsl #5
    otgp->DAINTMSK &= ~DAINTMSK_IEPM(ep);
 80006d4:	2301      	movs	r3, #1
    otgp->ie[ep].DIEPCTL &= ~DIEPCTL_USBAEP;
 80006d6:	f8d4 0900 	ldr.w	r0, [r4, #2304]	; 0x900
    otgp->DAINTMSK &= ~DAINTMSK_IEPM(ep);
 80006da:	fa03 f101 	lsl.w	r1, r3, r1
    otgp->ie[ep].DIEPCTL &= ~DIEPCTL_USBAEP;
 80006de:	f420 4000 	bic.w	r0, r0, #32768	; 0x8000
 80006e2:	f8c4 0900 	str.w	r0, [r4, #2304]	; 0x900
    otgp->DAINTMSK &= ~DAINTMSK_IEPM(ep);
 80006e6:	f8d2 381c 	ldr.w	r3, [r2, #2076]	; 0x81c
 80006ea:	ea23 0301 	bic.w	r3, r3, r1
 80006ee:	f8c2 381c 	str.w	r3, [r2, #2076]	; 0x81c
}
 80006f2:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80006f4:	10008000 	.word	0x10008000
 80006f8:	e0001000 	.word	0xe0001000
 80006fc:	02000400 	.word	0x02000400

08000700 <usb_lld_start_out>:
 *
 * @notapi
 */
void usb_lld_start_out(USBDriver *usbp, usbep_t ep) {
  uint32_t pcnt, rxsize;
  USBOutEndpointState *osp = usbp->epc[ep]->out_state;
 8000700:	eb00 0381 	add.w	r3, r0, r1, lsl #2

  /* Transfer initialization.*/
  osp->totsize = osp->rxsize;
  if ((ep == 0) && (osp->rxsize > EP0_MAX_OUTSIZE))
 8000704:	f011 0f01 	tst.w	r1, #1
  USBOutEndpointState *osp = usbp->epc[ep]->out_state;
 8000708:	68da      	ldr	r2, [r3, #12]
 800070a:	6993      	ldr	r3, [r2, #24]
void usb_lld_start_out(USBDriver *usbp, usbep_t ep) {
 800070c:	b410      	push	{r4}
  osp->totsize = osp->rxsize;
 800070e:	681c      	ldr	r4, [r3, #0]
 8000710:	60dc      	str	r4, [r3, #12]
  if ((ep == 0) && (osp->rxsize > EP0_MAX_OUTSIZE))
 8000712:	d101      	bne.n	8000718 <usb_lld_start_out+0x18>
 8000714:	2c40      	cmp	r4, #64	; 0x40
 8000716:	d825      	bhi.n	8000764 <usb_lld_start_out+0x64>
  /* Transaction size is rounded to a multiple of packet size because the
     following requirement in the RM:
     "For OUT transfers, the transfer size field in the endpoint's transfer
     size register must be a multiple of the maximum packet size of the
     endpoint, adjusted to the Word boundary".*/
  pcnt   = (osp->rxsize + usbp->epc[ep]->out_maxsize - 1U) /
 8000718:	8a53      	ldrh	r3, [r2, #18]
  /* Setting up transaction parameters in DOEPTSIZ.*/
  usbp->otg->oe[ep].DOEPTSIZ = DOEPTSIZ_STUPCNT(3) | DOEPTSIZ_PKTCNT(pcnt) |
                               DOEPTSIZ_XFRSIZ(rxsize);

  /* Special case of isochronous endpoint.*/
  if ((usbp->epc[ep]->ep_mode & USB_EP_MODE_TYPE) == USB_EP_MODE_TYPE_ISOC) {
 800071a:	6812      	ldr	r2, [r2, #0]
  usbp->otg->oe[ep].DOEPTSIZ = DOEPTSIZ_STUPCNT(3) | DOEPTSIZ_PKTCNT(pcnt) |
 800071c:	f8d0 0090 	ldr.w	r0, [r0, #144]	; 0x90
  if ((usbp->epc[ep]->ep_mode & USB_EP_MODE_TYPE) == USB_EP_MODE_TYPE_ISOC) {
 8000720:	f002 0c03 	and.w	ip, r2, #3
  pcnt   = (osp->rxsize + usbp->epc[ep]->out_maxsize - 1U) /
 8000724:	1e5a      	subs	r2, r3, #1
 8000726:	4422      	add	r2, r4
  if ((usbp->epc[ep]->ep_mode & USB_EP_MODE_TYPE) == USB_EP_MODE_TYPE_ISOC) {
 8000728:	f1bc 0f01 	cmp.w	ip, #1
  pcnt   = (osp->rxsize + usbp->epc[ep]->out_maxsize - 1U) /
 800072c:	fbb2 f2f3 	udiv	r2, r2, r3
  rxsize = (pcnt * usbp->epc[ep]->out_maxsize + 3U) & 0xFFFFFFFCU;
 8000730:	fb02 f303 	mul.w	r3, r2, r3
 8000734:	f103 0303 	add.w	r3, r3, #3
 8000738:	f023 0303 	bic.w	r3, r3, #3
  usbp->otg->oe[ep].DOEPTSIZ = DOEPTSIZ_STUPCNT(3) | DOEPTSIZ_PKTCNT(pcnt) |
 800073c:	ea43 43c2 	orr.w	r3, r3, r2, lsl #19
 8000740:	eb00 1241 	add.w	r2, r0, r1, lsl #5
 8000744:	f043 43c0 	orr.w	r3, r3, #1610612736	; 0x60000000
 8000748:	f8c2 3b10 	str.w	r3, [r2, #2832]	; 0xb10
  if ((usbp->epc[ep]->ep_mode & USB_EP_MODE_TYPE) == USB_EP_MODE_TYPE_ISOC) {
 800074c:	d00d      	beq.n	800076a <usb_lld_start_out+0x6a>
 800074e:	b209      	sxth	r1, r1
    else
      usbp->otg->oe[ep].DOEPCTL |= DOEPCTL_SODDFRM;
  }

  /* Starting operation.*/
  usbp->otg->oe[ep].DOEPCTL |= DOEPCTL_EPENA | DOEPCTL_CNAK;
 8000750:	eb00 1041 	add.w	r0, r0, r1, lsl #5
}
 8000754:	bc10      	pop	{r4}
  usbp->otg->oe[ep].DOEPCTL |= DOEPCTL_EPENA | DOEPCTL_CNAK;
 8000756:	f8d0 3b00 	ldr.w	r3, [r0, #2816]	; 0xb00
 800075a:	f043 4304 	orr.w	r3, r3, #2214592512	; 0x84000000
 800075e:	f8c0 3b00 	str.w	r3, [r0, #2816]	; 0xb00
}
 8000762:	4770      	bx	lr
      osp->rxsize = EP0_MAX_OUTSIZE;
 8000764:	2440      	movs	r4, #64	; 0x40
 8000766:	601c      	str	r4, [r3, #0]
 8000768:	e7d6      	b.n	8000718 <usb_lld_start_out+0x18>
    if (usbp->otg->DSTS & DSTS_FNSOF_ODD)
 800076a:	f8d0 3808 	ldr.w	r3, [r0, #2056]	; 0x808
 800076e:	eb00 1241 	add.w	r2, r0, r1, lsl #5
 8000772:	b209      	sxth	r1, r1
 8000774:	f413 7f80 	tst.w	r3, #256	; 0x100
      usbp->otg->oe[ep].DOEPCTL |= DOEPCTL_SEVNFRM;
 8000778:	f8d2 3b00 	ldr.w	r3, [r2, #2816]	; 0xb00
 800077c:	bf14      	ite	ne
 800077e:	f043 5380 	orrne.w	r3, r3, #268435456	; 0x10000000
      usbp->otg->oe[ep].DOEPCTL |= DOEPCTL_SODDFRM;
 8000782:	f043 5300 	orreq.w	r3, r3, #536870912	; 0x20000000
 8000786:	f8c2 3b00 	str.w	r3, [r2, #2816]	; 0xb00
 800078a:	e7e1      	b.n	8000750 <usb_lld_start_out+0x50>
 800078c:	0000      	movs	r0, r0
	...

08000790 <usb_lld_start_in>:
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
void usb_lld_start_in(USBDriver *usbp, usbep_t ep) {
  USBInEndpointState *isp = usbp->epc[ep]->in_state;
 8000790:	eb00 0381 	add.w	r3, r0, r1, lsl #2
void usb_lld_start_in(USBDriver *usbp, usbep_t ep) {
 8000794:	b410      	push	{r4}
  USBInEndpointState *isp = usbp->epc[ep]->in_state;
 8000796:	68dc      	ldr	r4, [r3, #12]
 8000798:	6962      	ldr	r2, [r4, #20]

  /* Transfer initialization.*/
  isp->totsize = isp->txsize;
 800079a:	6813      	ldr	r3, [r2, #0]
 800079c:	60d3      	str	r3, [r2, #12]
  if (isp->txsize == 0) {
 800079e:	b9f3      	cbnz	r3, 80007de <usb_lld_start_in+0x4e>
    /* Special case, sending zero size packet.*/
    usbp->otg->ie[ep].DIEPTSIZ = DIEPTSIZ_PKTCNT(1) | DIEPTSIZ_XFRSIZ(0);
 80007a0:	f8d0 2090 	ldr.w	r2, [r0, #144]	; 0x90
 80007a4:	f44f 2000 	mov.w	r0, #524288	; 0x80000
 80007a8:	eb02 1341 	add.w	r3, r2, r1, lsl #5
 80007ac:	f8c3 0910 	str.w	r0, [r3, #2320]	; 0x910
    usbp->otg->ie[ep].DIEPTSIZ = DIEPTSIZ_MCNT(1) | DIEPTSIZ_PKTCNT(pcnt) |
                                 DIEPTSIZ_XFRSIZ(isp->txsize);
  }

  /* Special case of isochronous endpoint.*/
  if ((usbp->epc[ep]->ep_mode & USB_EP_MODE_TYPE) == USB_EP_MODE_TYPE_ISOC) {
 80007b0:	6823      	ldr	r3, [r4, #0]
 80007b2:	f003 0303 	and.w	r3, r3, #3
 80007b6:	2b01      	cmp	r3, #1
 80007b8:	d02a      	beq.n	8000810 <usb_lld_start_in+0x80>
 80007ba:	b208      	sxth	r0, r1
    else
      usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_SODDFRM;
  }

  /* Starting operation.*/
  usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_EPENA | DIEPCTL_CNAK;
 80007bc:	eb02 1040 	add.w	r0, r2, r0, lsl #5
  usbp->otg->DIEPEMPMSK |= DIEPEMPMSK_INEPTXFEM(ep);
 80007c0:	2301      	movs	r3, #1
  usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_EPENA | DIEPCTL_CNAK;
 80007c2:	f8d0 4900 	ldr.w	r4, [r0, #2304]	; 0x900
  usbp->otg->DIEPEMPMSK |= DIEPEMPMSK_INEPTXFEM(ep);
 80007c6:	408b      	lsls	r3, r1
  usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_EPENA | DIEPCTL_CNAK;
 80007c8:	f044 4404 	orr.w	r4, r4, #2214592512	; 0x84000000
 80007cc:	f8c0 4900 	str.w	r4, [r0, #2304]	; 0x900
  usbp->otg->DIEPEMPMSK |= DIEPEMPMSK_INEPTXFEM(ep);
 80007d0:	f8d2 1834 	ldr.w	r1, [r2, #2100]	; 0x834
}
 80007d4:	bc10      	pop	{r4}
  usbp->otg->DIEPEMPMSK |= DIEPEMPMSK_INEPTXFEM(ep);
 80007d6:	430b      	orrs	r3, r1
 80007d8:	f8c2 3834 	str.w	r3, [r2, #2100]	; 0x834
}
 80007dc:	4770      	bx	lr
    if ((ep == 0) && (isp->txsize > EP0_MAX_INSIZE))
 80007de:	b909      	cbnz	r1, 80007e4 <usb_lld_start_in+0x54>
 80007e0:	2b40      	cmp	r3, #64	; 0x40
 80007e2:	d826      	bhi.n	8000832 <usb_lld_start_in+0xa2>
    uint32_t pcnt = (isp->txsize + usbp->epc[ep]->in_maxsize - 1) /
 80007e4:	f8b4 c010 	ldrh.w	ip, [r4, #16]
    usbp->otg->ie[ep].DIEPTSIZ = DIEPTSIZ_MCNT(1) | DIEPTSIZ_PKTCNT(pcnt) |
 80007e8:	f8d0 2090 	ldr.w	r2, [r0, #144]	; 0x90
    uint32_t pcnt = (isp->txsize + usbp->epc[ep]->in_maxsize - 1) /
 80007ec:	f10c 30ff 	add.w	r0, ip, #4294967295
 80007f0:	4418      	add	r0, r3
 80007f2:	fbb0 f0fc 	udiv	r0, r0, ip
    usbp->otg->ie[ep].DIEPTSIZ = DIEPTSIZ_MCNT(1) | DIEPTSIZ_PKTCNT(pcnt) |
 80007f6:	ea43 43c0 	orr.w	r3, r3, r0, lsl #19
 80007fa:	eb02 1041 	add.w	r0, r2, r1, lsl #5
 80007fe:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
 8000802:	f8c0 3910 	str.w	r3, [r0, #2320]	; 0x910
  if ((usbp->epc[ep]->ep_mode & USB_EP_MODE_TYPE) == USB_EP_MODE_TYPE_ISOC) {
 8000806:	6823      	ldr	r3, [r4, #0]
 8000808:	f003 0303 	and.w	r3, r3, #3
 800080c:	2b01      	cmp	r3, #1
 800080e:	d1d4      	bne.n	80007ba <usb_lld_start_in+0x2a>
    if (usbp->otg->DSTS & DSTS_FNSOF_ODD)
 8000810:	f8d2 3808 	ldr.w	r3, [r2, #2056]	; 0x808
 8000814:	b208      	sxth	r0, r1
 8000816:	f413 7f80 	tst.w	r3, #256	; 0x100
 800081a:	eb02 1341 	add.w	r3, r2, r1, lsl #5
      usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_SEVNFRM;
 800081e:	f8d3 4900 	ldr.w	r4, [r3, #2304]	; 0x900
 8000822:	bf14      	ite	ne
 8000824:	f044 5480 	orrne.w	r4, r4, #268435456	; 0x10000000
      usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_SODDFRM;
 8000828:	f044 5400 	orreq.w	r4, r4, #536870912	; 0x20000000
 800082c:	f8c3 4900 	str.w	r4, [r3, #2304]	; 0x900
 8000830:	e7c4      	b.n	80007bc <usb_lld_start_in+0x2c>
      isp->txsize = EP0_MAX_INSIZE;
 8000832:	2340      	movs	r3, #64	; 0x40
 8000834:	6013      	str	r3, [r2, #0]
 8000836:	e7d5      	b.n	80007e4 <usb_lld_start_in+0x54>
	...

08000840 <_usb_ep0in>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number, always zero
 *
 * @notapi
 */
void _usb_ep0in(USBDriver *usbp, usbep_t ep) {
 8000840:	b538      	push	{r3, r4, r5, lr}
  size_t max;

  (void)ep;
  switch (usbp->ep0state) {
 8000842:	f890 3070 	ldrb.w	r3, [r0, #112]	; 0x70
void _usb_ep0in(USBDriver *usbp, usbep_t ep) {
 8000846:	4604      	mov	r4, r0
  switch (usbp->ep0state) {
 8000848:	2b15      	cmp	r3, #21
 800084a:	d827      	bhi.n	800089c <_usb_ep0in+0x5c>
 800084c:	e8df f003 	tbb	[pc, r3]
 8000850:	26262627 	.word	0x26262627
 8000854:	26272626 	.word	0x26272626
 8000858:	3e100b26 	.word	0x3e100b26
 800085c:	26262626 	.word	0x26262626
 8000860:	26262626 	.word	0x26262626
 8000864:	2727      	.short	0x2727
  case USB_EP0_IN_TX:
    max = (size_t)get_hword(&usbp->setup[6]);
    /* If the transmitted size is less than the requested size and it is a
       multiple of the maximum packet size then a zero size packet must be
       transmitted.*/
    if ((usbp->ep0n < max) &&
 8000866:	6f85      	ldr	r5, [r0, #120]	; 0x78
    max = (size_t)get_hword(&usbp->setup[6]);
 8000868:	f8b0 3086 	ldrh.w	r3, [r0, #134]	; 0x86
    if ((usbp->ep0n < max) &&
 800086c:	429d      	cmp	r5, r3
 800086e:	d334      	bcc.n	80008da <_usb_ep0in+0x9a>
      return;
    }
    /* Falls through.*/
  case USB_EP0_IN_WAITING_TX0:
    /* Transmit phase over, receiving the zero sized status packet.*/
    usbp->ep0state = USB_EP0_OUT_WAITING_STS;
 8000870:	2214      	movs	r2, #20
  \details Assigns the given value to the Base Priority register.
  \param [in]    basePri  Base Priority value to set
 */
__STATIC_FORCEINLINE void __set_BASEPRI(uint32_t basePri)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8000872:	2330      	movs	r3, #48	; 0x30
 8000874:	f884 2070 	strb.w	r2, [r4, #112]	; 0x70
 8000878:	f383 8811 	msr	BASEPRI, r3
  usbp->receiving |= (uint16_t)((unsigned)1U << (unsigned)ep);
 800087c:	8962      	ldrh	r2, [r4, #10]
  osp->rxbuf  = buf;
 800087e:	2500      	movs	r5, #0
  osp = usbp->epc[ep]->out_state;
 8000880:	68e3      	ldr	r3, [r4, #12]
  usb_lld_start_out(usbp, ep);
 8000882:	4620      	mov	r0, r4
  usbp->receiving |= (uint16_t)((unsigned)1U << (unsigned)ep);
 8000884:	f042 0201 	orr.w	r2, r2, #1
  usb_lld_start_out(usbp, ep);
 8000888:	4629      	mov	r1, r5
  osp = usbp->epc[ep]->out_state;
 800088a:	699b      	ldr	r3, [r3, #24]
  usbp->receiving |= (uint16_t)((unsigned)1U << (unsigned)ep);
 800088c:	8162      	strh	r2, [r4, #10]
  osp->rxbuf  = buf;
 800088e:	609d      	str	r5, [r3, #8]
  osp->rxcnt  = 0;
 8000890:	e9c3 5500 	strd	r5, r5, [r3]
  usb_lld_start_out(usbp, ep);
 8000894:	f7ff ff34 	bl	8000700 <usb_lld_start_out>
 8000898:	f385 8811 	msr	BASEPRI, r5
    usbp->ep0state = USB_EP0_ERROR;
    return;
  default:
    osalDbgAssert(false, "EP0 state machine invalid state");
  }
}
 800089c:	bd38      	pop	{r3, r4, r5, pc}
    usb_lld_stall_in(usbp, 0);
 800089e:	f8d0 3090 	ldr.w	r3, [r0, #144]	; 0x90
    _usb_isr_invoke_event_cb(usbp, USB_EVENT_STALLED);
 80008a2:	6841      	ldr	r1, [r0, #4]
 *
 * @notapi
 */
void usb_lld_stall_in(USBDriver *usbp, usbep_t ep) {

  usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_STALL;
 80008a4:	f8d3 2900 	ldr.w	r2, [r3, #2304]	; 0x900
 80008a8:	680d      	ldr	r5, [r1, #0]
 80008aa:	f442 1200 	orr.w	r2, r2, #2097152	; 0x200000
 80008ae:	f8c3 2900 	str.w	r2, [r3, #2304]	; 0x900
  usbp->otg->oe[ep].DOEPCTL |= DOEPCTL_STALL;
 80008b2:	f8d3 2b00 	ldr.w	r2, [r3, #2816]	; 0xb00
 80008b6:	f442 1200 	orr.w	r2, r2, #2097152	; 0x200000
 80008ba:	f8c3 2b00 	str.w	r2, [r3, #2816]	; 0xb00
 80008be:	b10d      	cbz	r5, 80008c4 <_usb_ep0in+0x84>
 80008c0:	2106      	movs	r1, #6
 80008c2:	47a8      	blx	r5
    usbp->ep0state = USB_EP0_ERROR;
 80008c4:	2306      	movs	r3, #6
 80008c6:	f884 3070 	strb.w	r3, [r4, #112]	; 0x70
}
 80008ca:	bd38      	pop	{r3, r4, r5, pc}
    if (usbp->ep0endcb != NULL) {
 80008cc:	6fc3      	ldr	r3, [r0, #124]	; 0x7c
 80008ce:	b103      	cbz	r3, 80008d2 <_usb_ep0in+0x92>
      usbp->ep0endcb(usbp);
 80008d0:	4798      	blx	r3
    usbp->ep0state = USB_EP0_STP_WAITING;
 80008d2:	2300      	movs	r3, #0
 80008d4:	f884 3070 	strb.w	r3, [r4, #112]	; 0x70
}
 80008d8:	bd38      	pop	{r3, r4, r5, pc}
        ((usbp->ep0n % usbp->epc[0]->in_maxsize) == 0U)) {
 80008da:	68c3      	ldr	r3, [r0, #12]
 80008dc:	8a1b      	ldrh	r3, [r3, #16]
 80008de:	fbb5 f2f3 	udiv	r2, r5, r3
 80008e2:	fb03 5512 	mls	r5, r3, r2, r5
    if ((usbp->ep0n < max) &&
 80008e6:	2d00      	cmp	r5, #0
 80008e8:	d1c2      	bne.n	8000870 <_usb_ep0in+0x30>
 80008ea:	2330      	movs	r3, #48	; 0x30
 80008ec:	f383 8811 	msr	BASEPRI, r3
  usbp->transmitting |= (uint16_t)((unsigned)1U << (unsigned)ep);
 80008f0:	8902      	ldrh	r2, [r0, #8]
  usb_lld_start_in(usbp, ep);
 80008f2:	4629      	mov	r1, r5
  isp = usbp->epc[ep]->in_state;
 80008f4:	68c3      	ldr	r3, [r0, #12]
  usbp->transmitting |= (uint16_t)((unsigned)1U << (unsigned)ep);
 80008f6:	f042 0201 	orr.w	r2, r2, #1
  isp = usbp->epc[ep]->in_state;
 80008fa:	695b      	ldr	r3, [r3, #20]
  usbp->transmitting |= (uint16_t)((unsigned)1U << (unsigned)ep);
 80008fc:	8102      	strh	r2, [r0, #8]
  isp->txbuf  = buf;
 80008fe:	609d      	str	r5, [r3, #8]
  isp->txcnt  = 0;
 8000900:	e9c3 5500 	strd	r5, r5, [r3]
  usb_lld_start_in(usbp, ep);
 8000904:	f7ff ff44 	bl	8000790 <usb_lld_start_in>
 8000908:	f385 8811 	msr	BASEPRI, r5
      usbp->ep0state = USB_EP0_IN_WAITING_TX0;
 800090c:	230a      	movs	r3, #10
 800090e:	f884 3070 	strb.w	r3, [r4, #112]	; 0x70
}
 8000912:	bd38      	pop	{r3, r4, r5, pc}
	...

08000920 <_usb_ep0out>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number, always zero
 *
 * @notapi
 */
void _usb_ep0out(USBDriver *usbp, usbep_t ep) {
 8000920:	b538      	push	{r3, r4, r5, lr}

  (void)ep;
  switch (usbp->ep0state) {
 8000922:	f890 3070 	ldrb.w	r3, [r0, #112]	; 0x70
void _usb_ep0out(USBDriver *usbp, usbep_t ep) {
 8000926:	4604      	mov	r4, r0
  switch (usbp->ep0state) {
 8000928:	2b15      	cmp	r3, #21
 800092a:	d821      	bhi.n	8000970 <_usb_ep0out+0x50>
 800092c:	e8df f003 	tbb	[pc, r3]
 8000930:	20202021 	.word	0x20202021
 8000934:	20212020 	.word	0x20212020
 8000938:	21212120 	.word	0x21212120
 800093c:	20202020 	.word	0x20202020
 8000940:	20202020 	.word	0x20202020
 8000944:	0b38      	.short	0x0b38
  case USB_EP0_OUT_RX:
    /* Receive phase over, sending the zero sized status packet.*/
    usbp->ep0state = USB_EP0_IN_SENDING_STS;
 8000946:	220b      	movs	r2, #11
 8000948:	2330      	movs	r3, #48	; 0x30
 800094a:	f880 2070 	strb.w	r2, [r0, #112]	; 0x70
 800094e:	f383 8811 	msr	BASEPRI, r3
  usbp->transmitting |= (uint16_t)((unsigned)1U << (unsigned)ep);
 8000952:	8902      	ldrh	r2, [r0, #8]
  isp->txbuf  = buf;
 8000954:	2500      	movs	r5, #0
  isp = usbp->epc[ep]->in_state;
 8000956:	68c3      	ldr	r3, [r0, #12]
  usbp->transmitting |= (uint16_t)((unsigned)1U << (unsigned)ep);
 8000958:	f042 0201 	orr.w	r2, r2, #1
  usb_lld_start_in(usbp, ep);
 800095c:	4629      	mov	r1, r5
  isp = usbp->epc[ep]->in_state;
 800095e:	695b      	ldr	r3, [r3, #20]
  usbp->transmitting |= (uint16_t)((unsigned)1U << (unsigned)ep);
 8000960:	8102      	strh	r2, [r0, #8]
  isp->txbuf  = buf;
 8000962:	609d      	str	r5, [r3, #8]
  isp->txcnt  = 0;
 8000964:	e9c3 5500 	strd	r5, r5, [r3]
  usb_lld_start_in(usbp, ep);
 8000968:	f7ff ff12 	bl	8000790 <usb_lld_start_in>
 800096c:	f385 8811 	msr	BASEPRI, r5
    usbp->ep0state = USB_EP0_ERROR;
    return;
  default:
    osalDbgAssert(false, "EP0 state machine invalid state");
  }
}
 8000970:	bd38      	pop	{r3, r4, r5, pc}
    usb_lld_stall_in(usbp, 0);
 8000972:	f8d0 3090 	ldr.w	r3, [r0, #144]	; 0x90
    _usb_isr_invoke_event_cb(usbp, USB_EVENT_STALLED);
 8000976:	6841      	ldr	r1, [r0, #4]
  usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_STALL;
 8000978:	f8d3 2900 	ldr.w	r2, [r3, #2304]	; 0x900
 800097c:	680d      	ldr	r5, [r1, #0]
 800097e:	f442 1200 	orr.w	r2, r2, #2097152	; 0x200000
 8000982:	f8c3 2900 	str.w	r2, [r3, #2304]	; 0x900
  usbp->otg->oe[ep].DOEPCTL |= DOEPCTL_STALL;
 8000986:	f8d3 2b00 	ldr.w	r2, [r3, #2816]	; 0xb00
 800098a:	f442 1200 	orr.w	r2, r2, #2097152	; 0x200000
 800098e:	f8c3 2b00 	str.w	r2, [r3, #2816]	; 0xb00
 8000992:	b10d      	cbz	r5, 8000998 <_usb_ep0out+0x78>
 8000994:	2106      	movs	r1, #6
 8000996:	47a8      	blx	r5
    usbp->ep0state = USB_EP0_ERROR;
 8000998:	2306      	movs	r3, #6
 800099a:	f884 3070 	strb.w	r3, [r4, #112]	; 0x70
}
 800099e:	bd38      	pop	{r3, r4, r5, pc}
    if (usbGetReceiveTransactionSizeX(usbp, 0) != 0U) {
 80009a0:	68c3      	ldr	r3, [r0, #12]
 80009a2:	699b      	ldr	r3, [r3, #24]
 80009a4:	685b      	ldr	r3, [r3, #4]
 80009a6:	2b00      	cmp	r3, #0
 80009a8:	d1e2      	bne.n	8000970 <_usb_ep0out+0x50>
    if (usbp->ep0endcb != NULL) {
 80009aa:	6fc3      	ldr	r3, [r0, #124]	; 0x7c
 80009ac:	b103      	cbz	r3, 80009b0 <_usb_ep0out+0x90>
      usbp->ep0endcb(usbp);
 80009ae:	4798      	blx	r3
    usbp->ep0state = USB_EP0_STP_WAITING;
 80009b0:	2300      	movs	r3, #0
 80009b2:	f884 3070 	strb.w	r3, [r4, #112]	; 0x70
}
 80009b6:	bd38      	pop	{r3, r4, r5, pc}
	...

080009c0 <sdc_lld_collect_errors>:
  if (sta & SDMMC_STA_CCRCFAIL)
 80009c0:	f001 0301 	and.w	r3, r1, #1
  if (sta & SDMMC_STA_DCRCFAIL)
 80009c4:	078a      	lsls	r2, r1, #30
    errors |= SDC_DATA_CRC_ERROR;
 80009c6:	bf48      	it	mi
 80009c8:	f043 0302 	orrmi.w	r3, r3, #2
  if (sta & SDMMC_STA_CTIMEOUT)
 80009cc:	074a      	lsls	r2, r1, #29
    errors |= SDC_COMMAND_TIMEOUT;
 80009ce:	bf48      	it	mi
 80009d0:	f043 0308 	orrmi.w	r3, r3, #8
  if (sta & SDMMC_STA_DTIMEOUT)
 80009d4:	070a      	lsls	r2, r1, #28
    errors |= SDC_DATA_TIMEOUT;
 80009d6:	bf48      	it	mi
 80009d8:	f043 0304 	orrmi.w	r3, r3, #4
  if (sta & SDMMC_STA_TXUNDERR)
 80009dc:	06ca      	lsls	r2, r1, #27
    errors |= SDC_TX_UNDERRUN;
 80009de:	bf48      	it	mi
 80009e0:	f043 0310 	orrmi.w	r3, r3, #16
  if (sta & SDMMC_STA_RXOVERR)
 80009e4:	068a      	lsls	r2, r1, #26
  sdcp->errors |= errors;
 80009e6:	6b42      	ldr	r2, [r0, #52]	; 0x34
    errors |= SDC_RX_OVERRUN;
 80009e8:	bf48      	it	mi
 80009ea:	f043 0320 	orrmi.w	r3, r3, #32
  sdcp->errors |= errors;
 80009ee:	431a      	orrs	r2, r3
 80009f0:	6342      	str	r2, [r0, #52]	; 0x34
}
 80009f2:	4770      	bx	lr
	...

08000a00 <notify3>:

#if STM32_SERIAL_USE_USART3 || defined(__DOXYGEN__)
static void notify3(io_queue_t *qp) {

  (void)qp;
  USART3->CR1 |= USART_CR1_TXEIE | USART_CR1_TCIE;
 8000a00:	4a02      	ldr	r2, [pc, #8]	; (8000a0c <notify3+0xc>)
 8000a02:	6813      	ldr	r3, [r2, #0]
 8000a04:	f043 03c0 	orr.w	r3, r3, #192	; 0xc0
 8000a08:	6013      	str	r3, [r2, #0]
}
 8000a0a:	4770      	bx	lr
 8000a0c:	40004800 	.word	0x40004800

08000a10 <sdc_lld_is_card_inserted>:
bool sdc_lld_is_card_inserted(SDCDriver *sdcp) {

  (void)sdcp;
  /* CHTODO: Fill the implementation.*/
  return true;
}
 8000a10:	2001      	movs	r0, #1
 8000a12:	4770      	bx	lr
	...

08000a20 <__idle_thread>:
  (void)p;

  while (true) {
    /*lint -save -e522 [2.2] Apparently no side effects because it contains
      an asm instruction.*/
    port_wait_for_interrupt();
 8000a20:	e7fe      	b.n	8000a20 <__idle_thread>
 8000a22:	bf00      	nop
	...

08000a30 <chTMStartMeasurementX>:
 8000a30:	4b01      	ldr	r3, [pc, #4]	; (8000a38 <chTMStartMeasurementX+0x8>)
 8000a32:	685b      	ldr	r3, [r3, #4]
 *
 * @xclass
 */
NOINLINE void chTMStartMeasurementX(time_measurement_t *tmp) {

  tmp->last = chSysGetRealtimeCounterX();
 8000a34:	6083      	str	r3, [r0, #8]
}
 8000a36:	4770      	bx	lr
 8000a38:	e0001000 	.word	0xe0001000
 8000a3c:	00000000 	.word	0x00000000

08000a40 <chTMStopMeasurementX>:
 *
 * @xclass
 */
NOINLINE void chTMStopMeasurementX(time_measurement_t *tmp) {

  tm_stop(tmp, chSysGetRealtimeCounterX(), ch_system.tmc.offset);
 8000a40:	4a0e      	ldr	r2, [pc, #56]	; (8000a7c <chTMStopMeasurementX+0x3c>)
 8000a42:	4b0f      	ldr	r3, [pc, #60]	; (8000a80 <chTMStopMeasurementX+0x40>)
  tmp->last = (now - tmp->last) - offset;
 8000a44:	6881      	ldr	r1, [r0, #8]
 8000a46:	685b      	ldr	r3, [r3, #4]
NOINLINE void chTMStopMeasurementX(time_measurement_t *tmp) {
 8000a48:	b410      	push	{r4}
  tm_stop(tmp, chSysGetRealtimeCounterX(), ch_system.tmc.offset);
 8000a4a:	6894      	ldr	r4, [r2, #8]
  tmp->cumulative += (rttime_t)tmp->last;
 8000a4c:	6902      	ldr	r2, [r0, #16]
  tmp->last = (now - tmp->last) - offset;
 8000a4e:	1b1b      	subs	r3, r3, r4
  tmp->n++;
 8000a50:	68c4      	ldr	r4, [r0, #12]
  tmp->last = (now - tmp->last) - offset;
 8000a52:	1a5b      	subs	r3, r3, r1
  tmp->cumulative += (rttime_t)tmp->last;
 8000a54:	6941      	ldr	r1, [r0, #20]
  tmp->n++;
 8000a56:	3401      	adds	r4, #1
  tmp->cumulative += (rttime_t)tmp->last;
 8000a58:	18d2      	adds	r2, r2, r3
 8000a5a:	6102      	str	r2, [r0, #16]
 8000a5c:	f141 0100 	adc.w	r1, r1, #0
  if (tmp->last > tmp->worst) {
 8000a60:	6842      	ldr	r2, [r0, #4]
  tmp->cumulative += (rttime_t)tmp->last;
 8000a62:	6141      	str	r1, [r0, #20]
  if (tmp->last > tmp->worst) {
 8000a64:	4293      	cmp	r3, r2
  if (tmp->last < tmp->best) {
 8000a66:	6802      	ldr	r2, [r0, #0]
    tmp->worst = tmp->last;
 8000a68:	bf88      	it	hi
 8000a6a:	6043      	strhi	r3, [r0, #4]
  if (tmp->last < tmp->best) {
 8000a6c:	4293      	cmp	r3, r2
  tmp->n++;
 8000a6e:	e9c0 3402 	strd	r3, r4, [r0, #8]
    tmp->best = tmp->last;
 8000a72:	bf38      	it	cc
 8000a74:	6003      	strcc	r3, [r0, #0]
}
 8000a76:	bc10      	pop	{r4}
 8000a78:	4770      	bx	lr
 8000a7a:	bf00      	nop
 8000a7c:	24000d40 	.word	0x24000d40
 8000a80:	e0001000 	.word	0xe0001000
	...

08000a90 <chCoreAllocFromTop>:
 8000a90:	2330      	movs	r3, #48	; 0x30
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @api
 */
void *chCoreAllocFromTop(size_t size, unsigned align, size_t offset) {
 8000a92:	b410      	push	{r4}
 8000a94:	f383 8811 	msr	BASEPRI, r3
  p = (uint8_t *)MEM_ALIGN_PREV(ch_memcore.topmem - size, align);
 8000a98:	4b0b      	ldr	r3, [pc, #44]	; (8000ac8 <chCoreAllocFromTop+0x38>)
 8000a9a:	4249      	negs	r1, r1
 8000a9c:	685c      	ldr	r4, [r3, #4]
 8000a9e:	1a20      	subs	r0, r4, r0
 8000aa0:	4008      	ands	r0, r1
  if ((prev < ch_memcore.basemem) || (prev > ch_memcore.topmem)) {
 8000aa2:	6819      	ldr	r1, [r3, #0]
  prev = p - offset;
 8000aa4:	1a82      	subs	r2, r0, r2
  if ((prev < ch_memcore.basemem) || (prev > ch_memcore.topmem)) {
 8000aa6:	428a      	cmp	r2, r1
 8000aa8:	d307      	bcc.n	8000aba <chCoreAllocFromTop+0x2a>
 8000aaa:	4294      	cmp	r4, r2
 8000aac:	d305      	bcc.n	8000aba <chCoreAllocFromTop+0x2a>
  ch_memcore.topmem = prev;
 8000aae:	605a      	str	r2, [r3, #4]
 8000ab0:	2300      	movs	r3, #0
 8000ab2:	f383 8811 	msr	BASEPRI, r3
  chSysLock();
  p = chCoreAllocFromTopI(size, align, offset);
  chSysUnlock();

  return p;
}
 8000ab6:	bc10      	pop	{r4}
 8000ab8:	4770      	bx	lr
    return NULL;
 8000aba:	2000      	movs	r0, #0
 8000abc:	2300      	movs	r3, #0
 8000abe:	f383 8811 	msr	BASEPRI, r3
}
 8000ac2:	bc10      	pop	{r4}
 8000ac4:	4770      	bx	lr
 8000ac6:	bf00      	nop
 8000ac8:	24000d38 	.word	0x24000d38
 8000acc:	00000000 	.word	0x00000000

08000ad0 <chCoreAllocAlignedI>:
  p = (uint8_t *)MEM_ALIGN_PREV(ch_memcore.topmem - size, align);
 8000ad0:	4b06      	ldr	r3, [pc, #24]	; (8000aec <chCoreAllocAlignedI+0x1c>)
 8000ad2:	4249      	negs	r1, r1
 8000ad4:	685a      	ldr	r2, [r3, #4]
 8000ad6:	1a10      	subs	r0, r2, r0
 8000ad8:	4008      	ands	r0, r1
  if ((prev < ch_memcore.basemem) || (prev > ch_memcore.topmem)) {
 8000ada:	6819      	ldr	r1, [r3, #0]
 8000adc:	4288      	cmp	r0, r1
 8000ade:	d303      	bcc.n	8000ae8 <chCoreAllocAlignedI+0x18>
 8000ae0:	4282      	cmp	r2, r0
 8000ae2:	d301      	bcc.n	8000ae8 <chCoreAllocAlignedI+0x18>
  ch_memcore.topmem = prev;
 8000ae4:	6058      	str	r0, [r3, #4]
  return p;
 8000ae6:	4770      	bx	lr
    return NULL;
 8000ae8:	2000      	movs	r0, #0
 * @iclass
 */
static inline void *chCoreAllocAlignedI(size_t size, unsigned align) {

  return chCoreAllocAlignedWithOffsetI(size, align, 0U);
}
 8000aea:	4770      	bx	lr
 8000aec:	24000d38 	.word	0x24000d38

08000af0 <__port_irq_epilogue>:
 8000af0:	2330      	movs	r3, #48	; 0x30
 8000af2:	f383 8811 	msr	BASEPRI, r3
 * @brief   Exception exit redirection to @p __port_switch_from_isr().
 */
void __port_irq_epilogue(void) {

  port_lock_from_isr();
  if ((SCB->ICSR & SCB_ICSR_RETTOBASE_Msk) != 0U) {
 8000af6:	4b0d      	ldr	r3, [pc, #52]	; (8000b2c <__port_irq_epilogue+0x3c>)
 8000af8:	685b      	ldr	r3, [r3, #4]
 8000afa:	f413 6300 	ands.w	r3, r3, #2048	; 0x800
 8000afe:	d102      	bne.n	8000b06 <__port_irq_epilogue+0x16>
 8000b00:	f383 8811 	msr	BASEPRI, r3
    /* Note, returning without unlocking is intentional, this is done in
       order to keep the rest of the context switch atomic.*/
    return;
  }
  port_unlock_from_isr();
}
 8000b04:	4770      	bx	lr
  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 8000b06:	f3ef 8309 	mrs	r3, PSP
    ectxp->xpsr = 0x01000000U;
 8000b0a:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
    s_psp -= sizeof (struct port_extctx);
 8000b0e:	3b20      	subs	r3, #32
    ectxp->xpsr = 0x01000000U;
 8000b10:	61da      	str	r2, [r3, #28]
  __ASM volatile ("MSR psp, %0" : : "r" (topOfProcStack) : );
 8000b12:	f383 8809 	msr	PSP, r3
 */
bool chSchIsPreemptionRequired(void) {
  os_instance_t *oip = currcore;
  thread_t *tp = __instance_get_currthread(oip);

  tprio_t p1 = firstprio(&oip->rlist.pqueue);
 8000b16:	4a06      	ldr	r2, [pc, #24]	; (8000b30 <__port_irq_epilogue+0x40>)
 8000b18:	6811      	ldr	r1, [r2, #0]
  tprio_t p2 = tp->hdr.pqueue.prio;
 8000b1a:	68d2      	ldr	r2, [r2, #12]
    if (chSchIsPreemptionRequired()) {
 8000b1c:	6889      	ldr	r1, [r1, #8]
 8000b1e:	6892      	ldr	r2, [r2, #8]
 8000b20:	4291      	cmp	r1, r2
      ectxp->pc = (uint32_t)__port_switch_from_isr;
 8000b22:	bf8c      	ite	hi
 8000b24:	4a03      	ldrhi	r2, [pc, #12]	; (8000b34 <__port_irq_epilogue+0x44>)
      ectxp->pc = (uint32_t)__port_exit_from_isr;
 8000b26:	4a04      	ldrls	r2, [pc, #16]	; (8000b38 <__port_irq_epilogue+0x48>)
 8000b28:	619a      	str	r2, [r3, #24]
 8000b2a:	4770      	bx	lr
 8000b2c:	e000ed00 	.word	0xe000ed00
 8000b30:	24000330 	.word	0x24000330
 8000b34:	080003e3 	.word	0x080003e3
 8000b38:	080003e6 	.word	0x080003e6
 8000b3c:	00000000 	.word	0x00000000

08000b40 <midi_usb_start_tx>:
  if (midi_usb_rx_queue_fill > 0U) {
    midi_usb_rx_queue_fill--;
  }
}

static inline void midi_usb_start_tx(const uint8_t *buffer, size_t len) {
 8000b40:	b538      	push	{r3, r4, r5, lr}
 8000b42:	460a      	mov	r2, r1
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8000b44:	2330      	movs	r3, #48	; 0x30
 8000b46:	4604      	mov	r4, r0
 8000b48:	f383 8811 	msr	BASEPRI, r3
  usbp->transmitting |= (uint16_t)((unsigned)1U << (unsigned)ep);
 8000b4c:	4808      	ldr	r0, [pc, #32]	; (8000b70 <midi_usb_start_tx+0x30>)
  isp->txcnt  = 0;
 8000b4e:	2500      	movs	r5, #0
  usb_lld_start_in(usbp, ep);
 8000b50:	2102      	movs	r1, #2
  usbp->transmitting |= (uint16_t)((unsigned)1U << (unsigned)ep);
 8000b52:	8903      	ldrh	r3, [r0, #8]
 8000b54:	f043 0304 	orr.w	r3, r3, #4
 8000b58:	8103      	strh	r3, [r0, #8]
  isp = usbp->epc[ep]->in_state;
 8000b5a:	6943      	ldr	r3, [r0, #20]
 8000b5c:	695b      	ldr	r3, [r3, #20]
  isp->txbuf  = buf;
 8000b5e:	609c      	str	r4, [r3, #8]
  isp->txcnt  = 0;
 8000b60:	e9c3 2500 	strd	r2, r5, [r3]
  usb_lld_start_in(usbp, ep);
 8000b64:	f7ff fe14 	bl	8000790 <usb_lld_start_in>
 8000b68:	f385 8811 	msr	BASEPRI, r5
  midi_usb_flush_tx_cache(buffer, len);
  osalSysLock();
  usbStartTransmitI(&USBD1, MIDI_EP_IN, buffer, len);
  osalSysUnlock();
}
 8000b6c:	bd38      	pop	{r3, r4, r5, pc}
 8000b6e:	bf00      	nop
 8000b70:	2400024c 	.word	0x2400024c
	...

08000b80 <get_descriptor>:
static const USBDescriptor *get_descriptor(USBDriver *usbp,
                                           uint8_t dtype,
                                           uint8_t dindex,
                                           uint16_t lang) {
  (void)usbp; (void)lang;
  switch (dtype) {
 8000b80:	2902      	cmp	r1, #2
 8000b82:	d006      	beq.n	8000b92 <get_descriptor+0x12>
 8000b84:	2903      	cmp	r1, #3
 8000b86:	d006      	beq.n	8000b96 <get_descriptor+0x16>
    case USB_DESCRIPTOR_DEVICE:        return &device_descriptor;
 8000b88:	2901      	cmp	r1, #1
 8000b8a:	4807      	ldr	r0, [pc, #28]	; (8000ba8 <get_descriptor+0x28>)
 8000b8c:	bf18      	it	ne
 8000b8e:	2000      	movne	r0, #0
 8000b90:	4770      	bx	lr
  switch (dtype) {
 8000b92:	4806      	ldr	r0, [pc, #24]	; (8000bac <get_descriptor+0x2c>)
 8000b94:	4770      	bx	lr
    case USB_DESCRIPTOR_CONFIGURATION: return &config_descriptor;
    case USB_DESCRIPTOR_STRING:
      if (dindex < 4) return &strings[dindex];
 8000b96:	2a03      	cmp	r2, #3
 8000b98:	d803      	bhi.n	8000ba2 <get_descriptor+0x22>
 8000b9a:	4805      	ldr	r0, [pc, #20]	; (8000bb0 <get_descriptor+0x30>)
 8000b9c:	eb00 00c2 	add.w	r0, r0, r2, lsl #3
 8000ba0:	4770      	bx	lr
      break;
    default:
      break;
  }
  return NULL;
 8000ba2:	2000      	movs	r0, #0
}
 8000ba4:	4770      	bx	lr
 8000ba6:	bf00      	nop
 8000ba8:	08005d8c 	.word	0x08005d8c
 8000bac:	08005d30 	.word	0x08005d30
 8000bb0:	08005f08 	.word	0x08005f08
	...

08000bc0 <otg_epin_handler.constprop.0>:
static void otg_epin_handler(USBDriver *usbp, usbep_t ep) {
 8000bc0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  stm32_otg_t *otgp = usbp->otg;
 8000bc4:	f8df 8100 	ldr.w	r8, [pc, #256]	; 8000cc8 <otg_epin_handler.constprop.0+0x108>
static void otg_epin_handler(USBDriver *usbp, usbep_t ep) {
 8000bc8:	4604      	mov	r4, r0
  uint32_t epint = otgp->ie[ep].DIEPINT;
 8000bca:	ea4f 1a40 	mov.w	sl, r0, lsl #5
  stm32_otg_t *otgp = usbp->otg;
 8000bce:	f8d8 6090 	ldr.w	r6, [r8, #144]	; 0x90
  uint32_t epint = otgp->ie[ep].DIEPINT;
 8000bd2:	eb06 1340 	add.w	r3, r6, r0, lsl #5
 8000bd6:	f8d3 5908 	ldr.w	r5, [r3, #2312]	; 0x908
  if ((epint & DIEPINT_XFRC) && (otgp->DIEPMSK & DIEPMSK_XFRCM)) {
 8000bda:	07e9      	lsls	r1, r5, #31
  otgp->ie[ep].DIEPINT = epint;
 8000bdc:	f8c3 5908 	str.w	r5, [r3, #2312]	; 0x908
  if ((epint & DIEPINT_XFRC) && (otgp->DIEPMSK & DIEPMSK_XFRCM)) {
 8000be0:	d503      	bpl.n	8000bea <otg_epin_handler.constprop.0+0x2a>
 8000be2:	f8d6 3810 	ldr.w	r3, [r6, #2064]	; 0x810
 8000be6:	07da      	lsls	r2, r3, #31
 8000be8:	d409      	bmi.n	8000bfe <otg_epin_handler.constprop.0+0x3e>
  if ((epint & DIEPINT_TXFE) &&
 8000bea:	062b      	lsls	r3, r5, #24
 8000bec:	d505      	bpl.n	8000bfa <otg_epin_handler.constprop.0+0x3a>
      (otgp->DIEPEMPMSK & DIEPEMPMSK_INEPTXFEM(ep))) {
 8000bee:	2701      	movs	r7, #1
 8000bf0:	f8d6 3834 	ldr.w	r3, [r6, #2100]	; 0x834
 8000bf4:	40a7      	lsls	r7, r4
  if ((epint & DIEPINT_TXFE) &&
 8000bf6:	423b      	tst	r3, r7
 8000bf8:	d118      	bne.n	8000c2c <otg_epin_handler.constprop.0+0x6c>
}
 8000bfa:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    USBInEndpointState *isp = usbp->epc[ep]->in_state;
 8000bfe:	eb08 0380 	add.w	r3, r8, r0, lsl #2
 8000c02:	68d9      	ldr	r1, [r3, #12]
 8000c04:	694b      	ldr	r3, [r1, #20]
    if (isp->txsize < isp->totsize) {
 8000c06:	6818      	ldr	r0, [r3, #0]
 8000c08:	68da      	ldr	r2, [r3, #12]
 8000c0a:	4290      	cmp	r0, r2
 8000c0c:	d34b      	bcc.n	8000ca6 <otg_epin_handler.constprop.0+0xe6>
      _usb_isr_invoke_in_cb(usbp, ep);
 8000c0e:	2201      	movs	r2, #1
 8000c10:	f8b8 3008 	ldrh.w	r3, [r8, #8]
 8000c14:	688f      	ldr	r7, [r1, #8]
 8000c16:	40a2      	lsls	r2, r4
 8000c18:	ea23 0302 	bic.w	r3, r3, r2
 8000c1c:	f8a8 3008 	strh.w	r3, [r8, #8]
 8000c20:	2f00      	cmp	r7, #0
 8000c22:	d0e2      	beq.n	8000bea <otg_epin_handler.constprop.0+0x2a>
 8000c24:	4621      	mov	r1, r4
 8000c26:	4640      	mov	r0, r8
 8000c28:	47b8      	blx	r7
 8000c2a:	e7de      	b.n	8000bea <otg_epin_handler.constprop.0+0x2a>
    if (usbp->epc[ep]->in_state->txcnt >= usbp->epc[ep]->in_state->txsize) {
 8000c2c:	eb08 0384 	add.w	r3, r8, r4, lsl #2
 8000c30:	68da      	ldr	r2, [r3, #12]
 8000c32:	6956      	ldr	r6, [r2, #20]
 8000c34:	e9d6 3500 	ldrd	r3, r5, [r6]
 8000c38:	42ab      	cmp	r3, r5
 8000c3a:	d942      	bls.n	8000cc2 <otg_epin_handler.constprop.0+0x102>
    otg_fifo_write_from_buffer(usbp->otg->FIFO[ep],
 8000c3c:	3401      	adds	r4, #1
    if (((usbp->otg->ie[ep].DTXFSTS & DTXFSTS_INEPTFSAV_MASK) * 4) < n)
 8000c3e:	f8d8 9090 	ldr.w	r9, [r8, #144]	; 0x90
    if (n > usbp->epc[ep]->in_maxsize)
 8000c42:	f8b2 8010 	ldrh.w	r8, [r2, #16]
    otg_fifo_write_from_buffer(usbp->otg->FIFO[ep],
 8000c46:	b2e4      	uxtb	r4, r4
    if (((usbp->otg->ie[ep].DTXFSTS & DTXFSTS_INEPTFSAV_MASK) * 4) < n)
 8000c48:	eb09 0e0a 	add.w	lr, r9, sl
    otg_fifo_write_from_buffer(usbp->otg->FIFO[ep],
 8000c4c:	eb09 3004 	add.w	r0, r9, r4, lsl #12
    n = usbp->epc[ep]->in_state->txsize - usbp->epc[ep]->in_state->txcnt;
 8000c50:	eba3 0c05 	sub.w	ip, r3, r5
    if (((usbp->otg->ie[ep].DTXFSTS & DTXFSTS_INEPTFSAV_MASK) * 4) < n)
 8000c54:	f8de 3918 	ldr.w	r3, [lr, #2328]	; 0x918
 8000c58:	45c4      	cmp	ip, r8
 8000c5a:	b29b      	uxth	r3, r3
 8000c5c:	bf28      	it	cs
 8000c5e:	46c4      	movcs	ip, r8
 8000c60:	ebbc 0f83 	cmp.w	ip, r3, lsl #2
 8000c64:	d8c9      	bhi.n	8000bfa <otg_epin_handler.constprop.0+0x3a>
    otg_fifo_write_from_buffer(usbp->otg->FIFO[ep],
 8000c66:	68b4      	ldr	r4, [r6, #8]
    if (n <= 4) {
 8000c68:	f1bc 0f04 	cmp.w	ip, #4
    *fifop = *((uint32_t *)buf);
 8000c6c:	6823      	ldr	r3, [r4, #0]
 8000c6e:	6003      	str	r3, [r0, #0]
    if (n <= 4) {
 8000c70:	d90b      	bls.n	8000c8a <otg_epin_handler.constprop.0+0xca>
 8000c72:	f1ac 0105 	sub.w	r1, ip, #5
 8000c76:	4623      	mov	r3, r4
 8000c78:	f021 0103 	bic.w	r1, r1, #3
 8000c7c:	3104      	adds	r1, #4
 8000c7e:	4421      	add	r1, r4
    *fifop = *((uint32_t *)buf);
 8000c80:	f853 2f04 	ldr.w	r2, [r3, #4]!
    if (n <= 4) {
 8000c84:	4299      	cmp	r1, r3
    *fifop = *((uint32_t *)buf);
 8000c86:	6002      	str	r2, [r0, #0]
    if (n <= 4) {
 8000c88:	d1fa      	bne.n	8000c80 <otg_epin_handler.constprop.0+0xc0>
    usbp->epc[ep]->in_state->txcnt += n;
 8000c8a:	4465      	add	r5, ip
    if (usbp->epc[ep]->in_state->txcnt >= usbp->epc[ep]->in_state->txsize) {
 8000c8c:	6833      	ldr	r3, [r6, #0]
    usbp->epc[ep]->in_state->txbuf += n;
 8000c8e:	4464      	add	r4, ip
    if (usbp->epc[ep]->in_state->txcnt >= usbp->epc[ep]->in_state->txsize) {
 8000c90:	42ab      	cmp	r3, r5
    usbp->epc[ep]->in_state->txcnt += n;
 8000c92:	6075      	str	r5, [r6, #4]
    usbp->epc[ep]->in_state->txbuf += n;
 8000c94:	60b4      	str	r4, [r6, #8]
    if (usbp->epc[ep]->in_state->txcnt >= usbp->epc[ep]->in_state->txsize) {
 8000c96:	d8db      	bhi.n	8000c50 <otg_epin_handler.constprop.0+0x90>
      usbp->otg->DIEPEMPMSK &= ~DIEPEMPMSK_INEPTXFEM(ep);
 8000c98:	f8d9 3834 	ldr.w	r3, [r9, #2100]	; 0x834
 8000c9c:	ea23 0307 	bic.w	r3, r3, r7
 8000ca0:	f8c9 3834 	str.w	r3, [r9, #2100]	; 0x834
      return true;
 8000ca4:	e7a9      	b.n	8000bfa <otg_epin_handler.constprop.0+0x3a>
      isp->txsize = isp->totsize - isp->txsize;
 8000ca6:	1a12      	subs	r2, r2, r0
      isp->txcnt  = 0;
 8000ca8:	2700      	movs	r7, #0
      isp->txsize = isp->totsize - isp->txsize;
 8000caa:	601a      	str	r2, [r3, #0]
      isp->txcnt  = 0;
 8000cac:	605f      	str	r7, [r3, #4]
 8000cae:	2330      	movs	r3, #48	; 0x30
 8000cb0:	f383 8811 	msr	BASEPRI, r3
      usb_lld_start_in(usbp, ep);
 8000cb4:	4621      	mov	r1, r4
 8000cb6:	4640      	mov	r0, r8
 8000cb8:	f7ff fd6a 	bl	8000790 <usb_lld_start_in>
 8000cbc:	f387 8811 	msr	BASEPRI, r7
 * @special
 */
static inline void osalSysUnlockFromISR(void) {

  chSysUnlockFromISR();
}
 8000cc0:	e793      	b.n	8000bea <otg_epin_handler.constprop.0+0x2a>
      usbp->otg->DIEPEMPMSK &= ~DIEPEMPMSK_INEPTXFEM(ep);
 8000cc2:	f8d8 9090 	ldr.w	r9, [r8, #144]	; 0x90
 8000cc6:	e7e7      	b.n	8000c98 <otg_epin_handler.constprop.0+0xd8>
 8000cc8:	2400024c 	.word	0x2400024c
 8000ccc:	00000000 	.word	0x00000000

08000cd0 <otg_epout_handler.constprop.0>:
static void otg_epout_handler(USBDriver *usbp, usbep_t ep) {
 8000cd0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  stm32_otg_t *otgp = usbp->otg;
 8000cd4:	4f24      	ldr	r7, [pc, #144]	; (8000d68 <otg_epout_handler.constprop.0+0x98>)
static void otg_epout_handler(USBDriver *usbp, usbep_t ep) {
 8000cd6:	4604      	mov	r4, r0
  stm32_otg_t *otgp = usbp->otg;
 8000cd8:	f8d7 6090 	ldr.w	r6, [r7, #144]	; 0x90
  uint32_t epint = otgp->oe[ep].DOEPINT;
 8000cdc:	eb06 1340 	add.w	r3, r6, r0, lsl #5
 8000ce0:	f8d3 5b08 	ldr.w	r5, [r3, #2824]	; 0xb08
  if ((epint & DOEPINT_STUP) && (otgp->DOEPMSK & DOEPMSK_STUPM)) {
 8000ce4:	0728      	lsls	r0, r5, #28
  otgp->oe[ep].DOEPINT = epint;
 8000ce6:	f8c3 5b08 	str.w	r5, [r3, #2824]	; 0xb08
  if ((epint & DOEPINT_STUP) && (otgp->DOEPMSK & DOEPMSK_STUPM)) {
 8000cea:	d503      	bpl.n	8000cf4 <otg_epout_handler.constprop.0+0x24>
 8000cec:	f8d6 3814 	ldr.w	r3, [r6, #2068]	; 0x814
 8000cf0:	0719      	lsls	r1, r3, #28
 8000cf2:	d431      	bmi.n	8000d58 <otg_epout_handler.constprop.0+0x88>
  if ((epint & DOEPINT_XFRC) && (otgp->DOEPMSK & DOEPMSK_XFRCM)) {
 8000cf4:	07ea      	lsls	r2, r5, #31
 8000cf6:	d52d      	bpl.n	8000d54 <otg_epout_handler.constprop.0+0x84>
 8000cf8:	f8d6 3814 	ldr.w	r3, [r6, #2068]	; 0x814
 8000cfc:	07db      	lsls	r3, r3, #31
 8000cfe:	d529      	bpl.n	8000d54 <otg_epout_handler.constprop.0+0x84>
    osp = usbp->epc[ep]->out_state;
 8000d00:	eb07 0384 	add.w	r3, r7, r4, lsl #2
 8000d04:	68d9      	ldr	r1, [r3, #12]
 8000d06:	698a      	ldr	r2, [r1, #24]
    if (ep == 0) {
 8000d08:	b954      	cbnz	r4, 8000d20 <otg_epout_handler.constprop.0+0x50>
      if (((osp->rxcnt % usbp->epc[ep]->out_maxsize) == 0) &&
 8000d0a:	8a48      	ldrh	r0, [r1, #18]
 8000d0c:	6853      	ldr	r3, [r2, #4]
 8000d0e:	fbb3 f5f0 	udiv	r5, r3, r0
 8000d12:	fb00 3315 	mls	r3, r0, r5, r3
 8000d16:	b91b      	cbnz	r3, 8000d20 <otg_epout_handler.constprop.0+0x50>
          (osp->rxsize < osp->totsize)) {
 8000d18:	6810      	ldr	r0, [r2, #0]
 8000d1a:	68d3      	ldr	r3, [r2, #12]
      if (((osp->rxcnt % usbp->epc[ep]->out_maxsize) == 0) &&
 8000d1c:	4298      	cmp	r0, r3
 8000d1e:	d30d      	bcc.n	8000d3c <otg_epout_handler.constprop.0+0x6c>
    _usb_isr_invoke_out_cb(usbp, ep);
 8000d20:	2201      	movs	r2, #1
 8000d22:	897b      	ldrh	r3, [r7, #10]
 8000d24:	68cd      	ldr	r5, [r1, #12]
 8000d26:	40a2      	lsls	r2, r4
 8000d28:	ea23 0302 	bic.w	r3, r3, r2
 8000d2c:	817b      	strh	r3, [r7, #10]
 8000d2e:	b18d      	cbz	r5, 8000d54 <otg_epout_handler.constprop.0+0x84>
 8000d30:	4621      	mov	r1, r4
 8000d32:	462b      	mov	r3, r5
 8000d34:	480c      	ldr	r0, [pc, #48]	; (8000d68 <otg_epout_handler.constprop.0+0x98>)
}
 8000d36:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    _usb_isr_invoke_out_cb(usbp, ep);
 8000d3a:	4718      	bx	r3
        osp->rxsize = osp->totsize - osp->rxsize;
 8000d3c:	1a1b      	subs	r3, r3, r0
        osp->rxcnt  = 0;
 8000d3e:	6054      	str	r4, [r2, #4]
 8000d40:	2130      	movs	r1, #48	; 0x30
        osp->rxsize = osp->totsize - osp->rxsize;
 8000d42:	6013      	str	r3, [r2, #0]
 8000d44:	f381 8811 	msr	BASEPRI, r1
        usb_lld_start_out(usbp, ep);
 8000d48:	4807      	ldr	r0, [pc, #28]	; (8000d68 <otg_epout_handler.constprop.0+0x98>)
 8000d4a:	4621      	mov	r1, r4
 8000d4c:	f7ff fcd8 	bl	8000700 <usb_lld_start_out>
 8000d50:	f384 8811 	msr	BASEPRI, r4
}
 8000d54:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    _usb_isr_invoke_setup_cb(usbp, ep);
 8000d58:	eb07 0384 	add.w	r3, r7, r4, lsl #2
 8000d5c:	4621      	mov	r1, r4
 8000d5e:	4638      	mov	r0, r7
 8000d60:	68db      	ldr	r3, [r3, #12]
 8000d62:	685b      	ldr	r3, [r3, #4]
 8000d64:	4798      	blx	r3
 8000d66:	e7c5      	b.n	8000cf4 <otg_epout_handler.constprop.0+0x24>
 8000d68:	2400024c 	.word	0x2400024c
 8000d6c:	00000000 	.word	0x00000000

08000d70 <trace_next.constprop.0>:
 *
 * @notapi
 */
NOINLINE static void trace_next(os_instance_t *oip) {

  oip->trace_buffer.ptr->time    = chVTGetSystemTimeX();
 8000d70:	4a0c      	ldr	r2, [pc, #48]	; (8000da4 <trace_next.constprop.0+0x34>)
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 8000d72:	f04f 4180 	mov.w	r1, #1073741824	; 0x40000000
 8000d76:	480c      	ldr	r0, [pc, #48]	; (8000da8 <trace_next.constprop.0+0x38>)
 8000d78:	f8d2 308c 	ldr.w	r3, [r2, #140]	; 0x8c
#endif

  /* Trace hook, useful in order to interface debug tools.*/
  CH_CFG_TRACE_HOOK(oip->trace_buffer.ptr);

  if (++oip->trace_buffer.ptr >= &oip->trace_buffer.buffer[CH_DBG_TRACE_BUFFER_SIZE]) {
 8000d7c:	f502 6c09 	add.w	ip, r2, #2192	; 0x890
NOINLINE static void trace_next(os_instance_t *oip) {
 8000d80:	b410      	push	{r4}
 8000d82:	6a4c      	ldr	r4, [r1, #36]	; 0x24
  oip->trace_buffer.ptr->rtstamp = chSysGetRealtimeCounterX();
 8000d84:	6819      	ldr	r1, [r3, #0]
  oip->trace_buffer.ptr->time    = chVTGetSystemTimeX();
 8000d86:	605c      	str	r4, [r3, #4]
 8000d88:	6840      	ldr	r0, [r0, #4]
  oip->trace_buffer.ptr->rtstamp = chSysGetRealtimeCounterX();
 8000d8a:	f360 211f 	bfi	r1, r0, #8, #24
    oip->trace_buffer.ptr = &oip->trace_buffer.buffer[0];
 8000d8e:	f102 0090 	add.w	r0, r2, #144	; 0x90
  oip->trace_buffer.ptr->rtstamp = chSysGetRealtimeCounterX();
 8000d92:	f843 1b10 	str.w	r1, [r3], #16
    oip->trace_buffer.ptr = &oip->trace_buffer.buffer[0];
 8000d96:	4563      	cmp	r3, ip
 8000d98:	bf28      	it	cs
 8000d9a:	4603      	movcs	r3, r0
 8000d9c:	f8c2 308c 	str.w	r3, [r2, #140]	; 0x8c
  }
}
 8000da0:	bc10      	pop	{r4}
 8000da2:	4770      	bx	lr
 8000da4:	24000330 	.word	0x24000330
 8000da8:	e0001000 	.word	0xe0001000
 8000dac:	00000000 	.word	0x00000000

08000db0 <otg_disable_ep.isra.0>:
static void otg_disable_ep(USBDriver *usbp) {
 8000db0:	b470      	push	{r4, r5, r6}
  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
 8000db2:	2200      	movs	r2, #0
    otgp->ie[i].DIEPINT = 0xFFFFFFFF;
 8000db4:	f04f 34ff 	mov.w	r4, #4294967295
  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
 8000db8:	688e      	ldr	r6, [r1, #8]
 8000dba:	eb00 1142 	add.w	r1, r0, r2, lsl #5
 8000dbe:	f102 0c01 	add.w	ip, r2, #1
    if ((otgp->ie[i].DIEPCTL & DIEPCTL_EPENA) != 0U) {
 8000dc2:	f8d1 5900 	ldr.w	r5, [r1, #2304]	; 0x900
    otgp->ie[i].DIEPINT = 0xFFFFFFFF;
 8000dc6:	460b      	mov	r3, r1
    if ((otgp->ie[i].DIEPCTL & DIEPCTL_EPENA) != 0U) {
 8000dc8:	2d00      	cmp	r5, #0
 8000dca:	da05      	bge.n	8000dd8 <otg_disable_ep.isra.0+0x28>
      otgp->ie[i].DIEPCTL |= DIEPCTL_EPDIS;
 8000dcc:	f8d1 5900 	ldr.w	r5, [r1, #2304]	; 0x900
 8000dd0:	f045 4580 	orr.w	r5, r5, #1073741824	; 0x40000000
 8000dd4:	f8c1 5900 	str.w	r5, [r1, #2304]	; 0x900
    if ((otgp->oe[i].DOEPCTL & DIEPCTL_EPENA) != 0U) {
 8000dd8:	f8d1 5b00 	ldr.w	r5, [r1, #2816]	; 0xb00
 8000ddc:	2d00      	cmp	r5, #0
 8000dde:	da05      	bge.n	8000dec <otg_disable_ep.isra.0+0x3c>
      otgp->oe[i].DOEPCTL |= DIEPCTL_EPDIS;
 8000de0:	f8d1 5b00 	ldr.w	r5, [r1, #2816]	; 0xb00
 8000de4:	f045 4580 	orr.w	r5, r5, #1073741824	; 0x40000000
 8000de8:	f8c1 5b00 	str.w	r5, [r1, #2816]	; 0xb00
  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
 8000dec:	42b2      	cmp	r2, r6
    otgp->ie[i].DIEPINT = 0xFFFFFFFF;
 8000dee:	f8c3 4908 	str.w	r4, [r3, #2312]	; 0x908
 8000df2:	4662      	mov	r2, ip
    otgp->oe[i].DOEPINT = 0xFFFFFFFF;
 8000df4:	f8c3 4b08 	str.w	r4, [r3, #2824]	; 0xb08
  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
 8000df8:	d1df      	bne.n	8000dba <otg_disable_ep.isra.0+0xa>
  otgp->DAINTMSK = DAINTMSK_OEPM(0) | DAINTMSK_IEPM(0);
 8000dfa:	f04f 1301 	mov.w	r3, #65537	; 0x10001
}
 8000dfe:	bc70      	pop	{r4, r5, r6}
  otgp->DAINTMSK = DAINTMSK_OEPM(0) | DAINTMSK_IEPM(0);
 8000e00:	f8c0 381c 	str.w	r3, [r0, #2076]	; 0x81c
}
 8000e04:	4770      	bx	lr
 8000e06:	bf00      	nop
	...

08000e10 <__sch_ready_ahead>:
 * @notapi
 */
void __trace_ready(thread_t *tp, msg_t msg) {
  os_instance_t *oip = currcore;

  if ((oip->trace_buffer.suspended & CH_DBG_TRACE_MASK_READY) == 0U) {
 8000e10:	4b12      	ldr	r3, [pc, #72]	; (8000e5c <__sch_ready_ahead+0x4c>)
 8000e12:	f8b3 2088 	ldrh.w	r2, [r3, #136]	; 0x88
 8000e16:	07d2      	lsls	r2, r2, #31
static thread_t *__sch_ready_ahead(thread_t *tp) {
 8000e18:	b510      	push	{r4, lr}
 8000e1a:	4604      	mov	r4, r0
 8000e1c:	d50f      	bpl.n	8000e3e <__sch_ready_ahead+0x2e>
  tp->state = CH_STATE_READY;
 8000e1e:	2200      	movs	r2, #0
  return threadref(ch_pqueue_insert_ahead(&tp->owner->rlist.pqueue,
 8000e20:	69a3      	ldr	r3, [r4, #24]
                                                          ch_priority_queue_t *p) {

  /* Scanning priority queue, the list is assumed to be mostly empty.*/
  do {
    pqp = pqp->next;
  } while (unlikely(pqp->prio > p->prio));
 8000e22:	68a1      	ldr	r1, [r4, #8]
  tp->state = CH_STATE_READY;
 8000e24:	f884 2024 	strb.w	r2, [r4, #36]	; 0x24
    pqp = pqp->next;
 8000e28:	681b      	ldr	r3, [r3, #0]
  } while (unlikely(pqp->prio > p->prio));
 8000e2a:	689a      	ldr	r2, [r3, #8]
 8000e2c:	428a      	cmp	r2, r1
 8000e2e:	d8fb      	bhi.n	8000e28 <__sch_ready_ahead+0x18>

  /* Insertion on prev.*/
  p->next       = pqp;
  p->prev       = pqp->prev;
 8000e30:	685a      	ldr	r2, [r3, #4]
}
 8000e32:	4620      	mov	r0, r4
  p->next       = pqp;
 8000e34:	6023      	str	r3, [r4, #0]
  p->prev       = pqp->prev;
 8000e36:	6062      	str	r2, [r4, #4]
  p->prev->next = p;
 8000e38:	6014      	str	r4, [r2, #0]
  pqp->prev     = p;
 8000e3a:	605c      	str	r4, [r3, #4]
 8000e3c:	bd10      	pop	{r4, pc}
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_READY;
 8000e3e:	f890 2024 	ldrb.w	r2, [r0, #36]	; 0x24
 8000e42:	f8d3 108c 	ldr.w	r1, [r3, #140]	; 0x8c
 8000e46:	00d3      	lsls	r3, r2, #3
  __trace_ready(tp, tp->u.rdymsg);
 8000e48:	6a80      	ldr	r0, [r0, #40]	; 0x28
 8000e4a:	f043 0301 	orr.w	r3, r3, #1
    oip->trace_buffer.ptr->state       = (uint8_t)tp->state;
    oip->trace_buffer.ptr->u.rdy.tp    = tp;
    oip->trace_buffer.ptr->u.rdy.msg   = msg;
 8000e4e:	e9c1 4002 	strd	r4, r0, [r1, #8]
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_READY;
 8000e52:	700b      	strb	r3, [r1, #0]
    trace_next(oip);
 8000e54:	f7ff ff8c 	bl	8000d70 <trace_next.constprop.0>
  }
}
 8000e58:	e7e1      	b.n	8000e1e <__sch_ready_ahead+0xe>
 8000e5a:	bf00      	nop
 8000e5c:	24000330 	.word	0x24000330

08000e60 <__sch_ready_behind.isra.0>:
  if ((oip->trace_buffer.suspended & CH_DBG_TRACE_MASK_READY) == 0U) {
 8000e60:	4b11      	ldr	r3, [pc, #68]	; (8000ea8 <__sch_ready_behind.isra.0+0x48>)
 8000e62:	f8b3 2088 	ldrh.w	r2, [r3, #136]	; 0x88
 8000e66:	07d2      	lsls	r2, r2, #31
static thread_t *__sch_ready_behind(thread_t *tp) {
 8000e68:	b510      	push	{r4, lr}
 8000e6a:	4604      	mov	r4, r0
 8000e6c:	d50e      	bpl.n	8000e8c <__sch_ready_behind.isra.0+0x2c>
  tp->state = CH_STATE_READY;
 8000e6e:	2200      	movs	r2, #0
  return threadref(ch_pqueue_insert_behind(&tp->owner->rlist.pqueue,
 8000e70:	69a3      	ldr	r3, [r4, #24]
  } while (unlikely(pqp->prio >= p->prio));
 8000e72:	68a1      	ldr	r1, [r4, #8]
  tp->state = CH_STATE_READY;
 8000e74:	f884 2024 	strb.w	r2, [r4, #36]	; 0x24
    pqp = pqp->next;
 8000e78:	681b      	ldr	r3, [r3, #0]
  } while (unlikely(pqp->prio >= p->prio));
 8000e7a:	689a      	ldr	r2, [r3, #8]
 8000e7c:	428a      	cmp	r2, r1
 8000e7e:	d2fb      	bcs.n	8000e78 <__sch_ready_behind.isra.0+0x18>
  p->prev       = pqp->prev;
 8000e80:	685a      	ldr	r2, [r3, #4]
 8000e82:	e9c4 3200 	strd	r3, r2, [r4]
  p->prev->next = p;
 8000e86:	6014      	str	r4, [r2, #0]
  pqp->prev     = p;
 8000e88:	605c      	str	r4, [r3, #4]
}
 8000e8a:	bd10      	pop	{r4, pc}
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_READY;
 8000e8c:	f890 2024 	ldrb.w	r2, [r0, #36]	; 0x24
 8000e90:	f8d3 108c 	ldr.w	r1, [r3, #140]	; 0x8c
 8000e94:	00d3      	lsls	r3, r2, #3
  __trace_ready(tp, tp->u.rdymsg);
 8000e96:	6a80      	ldr	r0, [r0, #40]	; 0x28
 8000e98:	f043 0301 	orr.w	r3, r3, #1
    oip->trace_buffer.ptr->u.rdy.msg   = msg;
 8000e9c:	e9c1 4002 	strd	r4, r0, [r1, #8]
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_READY;
 8000ea0:	700b      	strb	r3, [r1, #0]
    trace_next(oip);
 8000ea2:	f7ff ff65 	bl	8000d70 <trace_next.constprop.0>
}
 8000ea6:	e7e2      	b.n	8000e6e <__sch_ready_behind.isra.0+0xe>
 8000ea8:	24000330 	.word	0x24000330
 8000eac:	00000000 	.word	0x00000000

08000eb0 <adc_lld_serve_interrupt>:
 * @brief   ADC IRQ service routine.
 *
 * @param[in] adcp      pointer to the @p ADCDriver object
 * @param[in] isr       content of the ISR register
 */
static void adc_lld_serve_interrupt(ADCDriver *adcp, uint32_t isr) {
 8000eb0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8000eb2:	4604      	mov	r4, r0

  /* It could be a spurious interrupt caused by overflows after DMA disabling,
     just ignore it in this case.*/
  if (adcp->grpp != NULL) {
 8000eb4:	6900      	ldr	r0, [r0, #16]
 8000eb6:	2800      	cmp	r0, #0
 8000eb8:	d04c      	beq.n	8000f54 <adc_lld_serve_interrupt+0xa4>
    adcerror_t emask = 0U;

    /* Note, an overflow may occur after the conversion ended before the driver
       is able to stop the ADC, this is why the state is checked too.*/
    if ((isr & ADC_ISR_OVR) && (adcp->state == ADC_ACTIVE)) {
 8000eba:	f011 0310 	ands.w	r3, r1, #16
 8000ebe:	d006      	beq.n	8000ece <adc_lld_serve_interrupt+0x1e>
 8000ec0:	7823      	ldrb	r3, [r4, #0]
 8000ec2:	f1a3 0303 	sub.w	r3, r3, #3
 8000ec6:	fab3 f383 	clz	r3, r3
 8000eca:	095b      	lsrs	r3, r3, #5
 8000ecc:	005b      	lsls	r3, r3, #1
      /* ADC overflow condition, this could happen only if the DMA is unable
         to read data fast enough.*/
      emask |= ADC_ERR_OVERFLOW;
    }
    if (isr & ADC_ISR_AWD1) {
 8000ece:	060e      	lsls	r6, r1, #24
      /* Analog watchdog 1 error.*/
      emask |= ADC_ERR_AWD1;
 8000ed0:	bf48      	it	mi
 8000ed2:	f043 0304 	orrmi.w	r3, r3, #4
    }
    if (isr & ADC_ISR_AWD2) {
 8000ed6:	05cd      	lsls	r5, r1, #23
 8000ed8:	d53d      	bpl.n	8000f56 <adc_lld_serve_interrupt+0xa6>
      /* Analog watchdog 2 error.*/
      emask |= ADC_ERR_AWD2;
    }
    if (isr & ADC_ISR_AWD3) {
 8000eda:	058a      	lsls	r2, r1, #22
      emask |= ADC_ERR_AWD2;
 8000edc:	f043 0308 	orr.w	r3, r3, #8
    if (isr & ADC_ISR_AWD3) {
 8000ee0:	d501      	bpl.n	8000ee6 <adc_lld_serve_interrupt+0x36>
      /* Analog watchdog 3 error.*/
      emask |= ADC_ERR_AWD3;
 8000ee2:	f043 0310 	orr.w	r3, r3, #16
 * @notapi
 */
void adc_lld_stop_conversion(ADCDriver *adcp) {

#if STM32_ADC_USE_ADC12 == TRUE
  if (&ADCD1 == adcp) {
 8000ee6:	4a28      	ldr	r2, [pc, #160]	; (8000f88 <adc_lld_serve_interrupt+0xd8>)
 8000ee8:	4294      	cmp	r4, r2
 8000eea:	d039      	beq.n	8000f60 <adc_lld_serve_interrupt+0xb0>
    dmaStreamDisable(adcp->data.dma);
  }
#endif /* STM32_ADC_USE_ADC12 == TRUE */

#if STM32_ADC_USE_ADC3 == TRUE
  if (&ADCD3 == adcp) {
 8000eec:	4a27      	ldr	r2, [pc, #156]	; (8000f8c <adc_lld_serve_interrupt+0xdc>)
 8000eee:	4294      	cmp	r4, r2
 8000ef0:	d10a      	bne.n	8000f08 <adc_lld_serve_interrupt+0x58>
    bdmaStreamDisable(adcp->data.bdma);
 8000ef2:	6b21      	ldr	r1, [r4, #48]	; 0x30
 8000ef4:	220e      	movs	r2, #14
 8000ef6:	684e      	ldr	r6, [r1, #4]
 8000ef8:	680f      	ldr	r7, [r1, #0]
 8000efa:	6835      	ldr	r5, [r6, #0]
 8000efc:	f025 050f 	bic.w	r5, r5, #15
 8000f00:	6035      	str	r5, [r6, #0]
 8000f02:	7a09      	ldrb	r1, [r1, #8]
 8000f04:	408a      	lsls	r2, r1
 8000f06:	607a      	str	r2, [r7, #4]
  }
#endif /* STM32_ADC_USE_ADC12 == TRUE */

  adc_lld_stop_adc(adcp);
 8000f08:	6aa1      	ldr	r1, [r4, #40]	; 0x28
  if (adcp->adcm->CR & ADC_CR_ADSTART) {
 8000f0a:	688a      	ldr	r2, [r1, #8]
 8000f0c:	0755      	lsls	r5, r2, #29
 8000f0e:	d506      	bpl.n	8000f1e <adc_lld_serve_interrupt+0x6e>
    adcp->adcm->CR |= ADC_CR_ADSTP;
 8000f10:	688a      	ldr	r2, [r1, #8]
 8000f12:	f042 0210 	orr.w	r2, r2, #16
 8000f16:	608a      	str	r2, [r1, #8]
    while (adcp->adcm->CR & ADC_CR_ADSTP)
 8000f18:	688a      	ldr	r2, [r1, #8]
 8000f1a:	06d2      	lsls	r2, r2, #27
 8000f1c:	d4fc      	bmi.n	8000f18 <adc_lld_serve_interrupt+0x68>
  adcp->adcm->PCSEL = 0U;
 8000f1e:	2500      	movs	r5, #0
      _adc_isr_error_code(adcp, emask);
 8000f20:	68c2      	ldr	r2, [r0, #12]
  adcp->adcm->PCSEL = 0U;
 8000f22:	61cd      	str	r5, [r1, #28]
      _adc_isr_error_code(adcp, emask);
 8000f24:	b35a      	cbz	r2, 8000f7e <adc_lld_serve_interrupt+0xce>
 8000f26:	2505      	movs	r5, #5
 8000f28:	4619      	mov	r1, r3
 8000f2a:	4620      	mov	r0, r4
 8000f2c:	7025      	strb	r5, [r4, #0]
 8000f2e:	4790      	blx	r2
 8000f30:	7823      	ldrb	r3, [r4, #0]
 8000f32:	42ab      	cmp	r3, r5
 8000f34:	d023      	beq.n	8000f7e <adc_lld_serve_interrupt+0xce>
 8000f36:	2330      	movs	r3, #48	; 0x30
 8000f38:	f383 8811 	msr	BASEPRI, r3
 *
 * @iclass
 */
void chThdResumeI(thread_reference_t *trp, msg_t msg) {

  if (*trp != NULL) {
 8000f3c:	6960      	ldr	r0, [r4, #20]
 8000f3e:	b130      	cbz	r0, 8000f4e <adc_lld_serve_interrupt+0x9e>
    thread_t *tp = *trp;

    chDbgAssert(tp->state == CH_STATE_SUSPENDED, "not CH_STATE_SUSPENDED");

    *trp = NULL;
 8000f40:	2200      	movs	r2, #0
    tp->u.rdymsg = msg;
 8000f42:	f04f 33ff 	mov.w	r3, #4294967295
    *trp = NULL;
 8000f46:	6162      	str	r2, [r4, #20]
    tp->u.rdymsg = msg;
 8000f48:	6283      	str	r3, [r0, #40]	; 0x28
  return __sch_ready_behind(tp);
 8000f4a:	f7ff ff89 	bl	8000e60 <__sch_ready_behind.isra.0>
 8000f4e:	2300      	movs	r3, #0
 8000f50:	f383 8811 	msr	BASEPRI, r3
}
 8000f54:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    if (isr & ADC_ISR_AWD3) {
 8000f56:	058f      	lsls	r7, r1, #22
 8000f58:	d4c3      	bmi.n	8000ee2 <adc_lld_serve_interrupt+0x32>
    if (emask != 0U) {
 8000f5a:	2b00      	cmp	r3, #0
 8000f5c:	d1c3      	bne.n	8000ee6 <adc_lld_serve_interrupt+0x36>
}
 8000f5e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    dmaStreamDisable(adcp->data.dma);
 8000f60:	6b25      	ldr	r5, [r4, #48]	; 0x30
 8000f62:	6829      	ldr	r1, [r5, #0]
 8000f64:	680a      	ldr	r2, [r1, #0]
 8000f66:	f022 021f 	bic.w	r2, r2, #31
 8000f6a:	600a      	str	r2, [r1, #0]
 8000f6c:	680a      	ldr	r2, [r1, #0]
 8000f6e:	07d6      	lsls	r6, r2, #31
 8000f70:	d4fc      	bmi.n	8000f6c <adc_lld_serve_interrupt+0xbc>
 8000f72:	6869      	ldr	r1, [r5, #4]
 8000f74:	223d      	movs	r2, #61	; 0x3d
 8000f76:	7b2d      	ldrb	r5, [r5, #12]
 8000f78:	40aa      	lsls	r2, r5
 8000f7a:	600a      	str	r2, [r1, #0]
  if (&ADCD3 == adcp) {
 8000f7c:	e7c4      	b.n	8000f08 <adc_lld_serve_interrupt+0x58>
      _adc_isr_error_code(adcp, emask);
 8000f7e:	2202      	movs	r2, #2
 8000f80:	2300      	movs	r3, #0
 8000f82:	7022      	strb	r2, [r4, #0]
 8000f84:	6123      	str	r3, [r4, #16]
 8000f86:	e7d6      	b.n	8000f36 <adc_lld_serve_interrupt+0x86>
 8000f88:	24000000 	.word	0x24000000
 8000f8c:	24000038 	.word	0x24000038

08000f90 <spi_lld_serve_interrupt.part.0>:
/**
 * @brief   Shared SPI service routine.
 *
 * @param[in] spip      pointer to the @p SPIDriver object
 */
static void spi_lld_serve_interrupt(SPIDriver *spip) {
 8000f90:	b538      	push	{r3, r4, r5, lr}
  if (spip->is_bdma)
 8000f92:	f890 3020 	ldrb.w	r3, [r0, #32]
static void spi_lld_serve_interrupt(SPIDriver *spip) {
 8000f96:	4604      	mov	r4, r0
  if (spip->is_bdma)
 8000f98:	2b00      	cmp	r3, #0
 8000f9a:	d036      	beq.n	800100a <spi_lld_serve_interrupt.part.0+0x7a>
    bdmaStreamDisable(spip->tx.bdma);
 8000f9c:	6a83      	ldr	r3, [r0, #40]	; 0x28
 8000f9e:	e9d3 0100 	ldrd	r0, r1, [r3]
 8000fa2:	680a      	ldr	r2, [r1, #0]
 8000fa4:	f022 020f 	bic.w	r2, r2, #15
 8000fa8:	600a      	str	r2, [r1, #0]
 8000faa:	7a19      	ldrb	r1, [r3, #8]
 8000fac:	230e      	movs	r3, #14
    bdmaStreamDisable(spip->rx.bdma);
 8000fae:	6a62      	ldr	r2, [r4, #36]	; 0x24
    bdmaStreamDisable(spip->tx.bdma);
 8000fb0:	fa03 f101 	lsl.w	r1, r3, r1
 8000fb4:	6041      	str	r1, [r0, #4]
    bdmaStreamDisable(spip->rx.bdma);
 8000fb6:	6850      	ldr	r0, [r2, #4]
 8000fb8:	6801      	ldr	r1, [r0, #0]
 8000fba:	f021 010f 	bic.w	r1, r1, #15
 8000fbe:	6001      	str	r1, [r0, #0]
 8000fc0:	7a11      	ldrb	r1, [r2, #8]
 8000fc2:	6812      	ldr	r2, [r2, #0]
 8000fc4:	408b      	lsls	r3, r1
 8000fc6:	6053      	str	r3, [r2, #4]
  else if (&SPID1 == spip) {
 8000fc8:	4b58      	ldr	r3, [pc, #352]	; (800112c <spi_lld_serve_interrupt.part.0+0x19c>)
 8000fca:	429c      	cmp	r4, r3
 8000fcc:	d03c      	beq.n	8001048 <spi_lld_serve_interrupt.part.0+0xb8>
  else if (&SPID2 == spip) {
 8000fce:	4b58      	ldr	r3, [pc, #352]	; (8001130 <spi_lld_serve_interrupt.part.0+0x1a0>)
 8000fd0:	429c      	cmp	r4, r3
 8000fd2:	d049      	beq.n	8001068 <spi_lld_serve_interrupt.part.0+0xd8>
  else if (&SPID3 == spip) {
 8000fd4:	4b57      	ldr	r3, [pc, #348]	; (8001134 <spi_lld_serve_interrupt.part.0+0x1a4>)
 8000fd6:	429c      	cmp	r4, r3
 8000fd8:	f000 8087 	beq.w	80010ea <spi_lld_serve_interrupt.part.0+0x15a>
  else if (&SPID5 == spip) {
 8000fdc:	4b56      	ldr	r3, [pc, #344]	; (8001138 <spi_lld_serve_interrupt.part.0+0x1a8>)
 8000fde:	429c      	cmp	r4, r3
 8000fe0:	f000 8093 	beq.w	800110a <spi_lld_serve_interrupt.part.0+0x17a>
  else if (&SPID6 == spip) {
 8000fe4:	4b55      	ldr	r3, [pc, #340]	; (800113c <spi_lld_serve_interrupt.part.0+0x1ac>)
 8000fe6:	429c      	cmp	r4, r3
 8000fe8:	d14d      	bne.n	8001086 <spi_lld_serve_interrupt.part.0+0xf6>
}

__STATIC_INLINE void __rccResetAPB4(uint32_t mask) {

  /* Resetting the peripherals.*/
  RCC->APB4RSTR |= mask;
 8000fea:	4b55      	ldr	r3, [pc, #340]	; (8001140 <spi_lld_serve_interrupt.part.0+0x1b0>)
 8000fec:	f8d3 209c 	ldr.w	r2, [r3, #156]	; 0x9c
 8000ff0:	f042 0220 	orr.w	r2, r2, #32
 8000ff4:	f8c3 209c 	str.w	r2, [r3, #156]	; 0x9c
  RCC->APB4RSTR &= ~mask;
 8000ff8:	f8d3 209c 	ldr.w	r2, [r3, #156]	; 0x9c
 8000ffc:	f022 0220 	bic.w	r2, r2, #32
 8001000:	f8c3 209c 	str.w	r2, [r3, #156]	; 0x9c
  (void)RCC->APB4RSTR;
 8001004:	f8d3 309c 	ldr.w	r3, [r3, #156]	; 0x9c
  osalDbgAssert((RCC_C2->APB4ENR & mask) == mask, "peripherals not allocated");
#endif
#endif

  __rccResetAPB4(mask);
}
 8001008:	e03d      	b.n	8001086 <spi_lld_serve_interrupt.part.0+0xf6>
    dmaStreamDisable(spip->tx.dma);
 800100a:	6a80      	ldr	r0, [r0, #40]	; 0x28
 800100c:	6802      	ldr	r2, [r0, #0]
 800100e:	6813      	ldr	r3, [r2, #0]
 8001010:	f023 031f 	bic.w	r3, r3, #31
 8001014:	6013      	str	r3, [r2, #0]
 8001016:	6813      	ldr	r3, [r2, #0]
 8001018:	07d9      	lsls	r1, r3, #31
 800101a:	d4fc      	bmi.n	8001016 <spi_lld_serve_interrupt.part.0+0x86>
 800101c:	7b02      	ldrb	r2, [r0, #12]
 800101e:	233d      	movs	r3, #61	; 0x3d
    dmaStreamDisable(spip->rx.dma);
 8001020:	6a61      	ldr	r1, [r4, #36]	; 0x24
    dmaStreamDisable(spip->tx.dma);
 8001022:	4093      	lsls	r3, r2
 8001024:	6840      	ldr	r0, [r0, #4]
    dmaStreamDisable(spip->rx.dma);
 8001026:	680a      	ldr	r2, [r1, #0]
    dmaStreamDisable(spip->tx.dma);
 8001028:	6003      	str	r3, [r0, #0]
    dmaStreamDisable(spip->rx.dma);
 800102a:	6813      	ldr	r3, [r2, #0]
 800102c:	f023 031f 	bic.w	r3, r3, #31
 8001030:	6013      	str	r3, [r2, #0]
 8001032:	6813      	ldr	r3, [r2, #0]
 8001034:	07db      	lsls	r3, r3, #31
 8001036:	d4fc      	bmi.n	8001032 <spi_lld_serve_interrupt.part.0+0xa2>
 8001038:	7b08      	ldrb	r0, [r1, #12]
 800103a:	233d      	movs	r3, #61	; 0x3d
 800103c:	684a      	ldr	r2, [r1, #4]
 800103e:	4083      	lsls	r3, r0
 8001040:	6013      	str	r3, [r2, #0]
  else if (&SPID1 == spip) {
 8001042:	4b3a      	ldr	r3, [pc, #232]	; (800112c <spi_lld_serve_interrupt.part.0+0x19c>)
 8001044:	429c      	cmp	r4, r3
 8001046:	d1c2      	bne.n	8000fce <spi_lld_serve_interrupt.part.0+0x3e>
  RCC->APB2RSTR |= mask;
 8001048:	4b3d      	ldr	r3, [pc, #244]	; (8001140 <spi_lld_serve_interrupt.part.0+0x1b0>)
 800104a:	f8d3 2098 	ldr.w	r2, [r3, #152]	; 0x98
 800104e:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
 8001052:	f8c3 2098 	str.w	r2, [r3, #152]	; 0x98
  RCC->APB2RSTR &= ~mask;
 8001056:	f8d3 2098 	ldr.w	r2, [r3, #152]	; 0x98
 800105a:	f422 5280 	bic.w	r2, r2, #4096	; 0x1000
 800105e:	f8c3 2098 	str.w	r2, [r3, #152]	; 0x98
  (void)RCC->APB2RSTR;
 8001062:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
}
 8001066:	e00e      	b.n	8001086 <spi_lld_serve_interrupt.part.0+0xf6>
  RCC->APB1LRSTR |= mask;
 8001068:	4b35      	ldr	r3, [pc, #212]	; (8001140 <spi_lld_serve_interrupt.part.0+0x1b0>)
 800106a:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
 800106e:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
 8001072:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
  RCC->APB1LRSTR &= ~mask;
 8001076:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
 800107a:	f422 4280 	bic.w	r2, r2, #16384	; 0x4000
 800107e:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
  (void)RCC->APB1LRSTR;
 8001082:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
  spi_lld_configure(spip);
 8001086:	6861      	ldr	r1, [r4, #4]
  spip->spi->CR1  = 0U;
 8001088:	2200      	movs	r2, #0
 800108a:	69e3      	ldr	r3, [r4, #28]
  spip->spi->IER  = SPI_IER_OVRIE;
 800108c:	2040      	movs	r0, #64	; 0x40
                    SPI_CFG1_RXDMAEN | SPI_CFG1_TXDMAEN;
 800108e:	694d      	ldr	r5, [r1, #20]
  spip->spi->CR1  = 0U;
 8001090:	601a      	str	r2, [r3, #0]
  spip->spi->CR2  = 0U;
 8001092:	605a      	str	r2, [r3, #4]
                    SPI_CFG1_RXDMAEN | SPI_CFG1_TXDMAEN;
 8001094:	4a2b      	ldr	r2, [pc, #172]	; (8001144 <spi_lld_serve_interrupt.part.0+0x1b4>)
  spip->spi->IER  = SPI_IER_OVRIE;
 8001096:	6118      	str	r0, [r3, #16]
  spip->spi->IFCR = 0xFFFFFFFFU;
 8001098:	f04f 30ff 	mov.w	r0, #4294967295
                    SPI_CFG1_RXDMAEN | SPI_CFG1_TXDMAEN;
 800109c:	402a      	ands	r2, r5
  spip->spi->IFCR = 0xFFFFFFFFU;
 800109e:	6198      	str	r0, [r3, #24]
                    SPI_CFG1_RXDMAEN | SPI_CFG1_TXDMAEN;
 80010a0:	f442 4240 	orr.w	r2, r2, #49152	; 0xc000
  spip->spi->CFG1 = (spip->config->cfg1 & ~SPI_CFG1_FTHLV_Msk) |
 80010a4:	609a      	str	r2, [r3, #8]
  if (spip->config->slave) {
 80010a6:	784a      	ldrb	r2, [r1, #1]
 80010a8:	b1c2      	cbz	r2, 80010dc <spi_lld_serve_interrupt.part.0+0x14c>
    spip->spi->CFG2 = spip->config->cfg2 & ~SPI_CFG2_COMM_Msk;
 80010aa:	698a      	ldr	r2, [r1, #24]
 80010ac:	f422 22c0 	bic.w	r2, r2, #393216	; 0x60000
 80010b0:	60da      	str	r2, [r3, #12]
  spip->spi->CR1  = SPI_CR1_MASRX | SPI_CR1_SPE;
 80010b2:	f240 1001 	movw	r0, #257	; 0x101

    /* Aborting the transfer.*/
    spi_lld_stop_abort(spip);

    /* Reporting the failure.*/
    __spi_isr_error_code(spip, HAL_RET_HW_FAILURE);
 80010b6:	688a      	ldr	r2, [r1, #8]
  spip->spi->CR1  = SPI_CR1_MASRX | SPI_CR1_SPE;
 80010b8:	6018      	str	r0, [r3, #0]
    __spi_isr_error_code(spip, HAL_RET_HW_FAILURE);
 80010ba:	b10a      	cbz	r2, 80010c0 <spi_lld_serve_interrupt.part.0+0x130>
 80010bc:	4620      	mov	r0, r4
 80010be:	4790      	blx	r2
 80010c0:	2330      	movs	r3, #48	; 0x30
 80010c2:	f383 8811 	msr	BASEPRI, r3
  if (*trp != NULL) {
 80010c6:	68a0      	ldr	r0, [r4, #8]
 80010c8:	b120      	cbz	r0, 80010d4 <spi_lld_serve_interrupt.part.0+0x144>
    *trp = NULL;
 80010ca:	2300      	movs	r3, #0
 80010cc:	60a3      	str	r3, [r4, #8]
    tp->u.rdymsg = msg;
 80010ce:	6283      	str	r3, [r0, #40]	; 0x28
 80010d0:	f7ff fec6 	bl	8000e60 <__sch_ready_behind.isra.0>
 80010d4:	2300      	movs	r3, #0
 80010d6:	f383 8811 	msr	BASEPRI, r3
  }
}
 80010da:	bd38      	pop	{r3, r4, r5, pc}
    spip->spi->CFG2 = (spip->config->cfg2 | SPI_CFG2_MASTER | SPI_CFG2_SSOE) &
 80010dc:	6988      	ldr	r0, [r1, #24]
 80010de:	4a1a      	ldr	r2, [pc, #104]	; (8001148 <spi_lld_serve_interrupt.part.0+0x1b8>)
 80010e0:	4002      	ands	r2, r0
 80010e2:	f042 5201 	orr.w	r2, r2, #541065216	; 0x20400000
 80010e6:	60da      	str	r2, [r3, #12]
 80010e8:	e7e3      	b.n	80010b2 <spi_lld_serve_interrupt.part.0+0x122>
  RCC->APB1LRSTR |= mask;
 80010ea:	4b15      	ldr	r3, [pc, #84]	; (8001140 <spi_lld_serve_interrupt.part.0+0x1b0>)
 80010ec:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
 80010f0:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 80010f4:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
  RCC->APB1LRSTR &= ~mask;
 80010f8:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
 80010fc:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
 8001100:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
  (void)RCC->APB1LRSTR;
 8001104:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
}
 8001108:	e7bd      	b.n	8001086 <spi_lld_serve_interrupt.part.0+0xf6>
  RCC->APB2RSTR |= mask;
 800110a:	4b0d      	ldr	r3, [pc, #52]	; (8001140 <spi_lld_serve_interrupt.part.0+0x1b0>)
 800110c:	f8d3 2098 	ldr.w	r2, [r3, #152]	; 0x98
 8001110:	f442 1280 	orr.w	r2, r2, #1048576	; 0x100000
 8001114:	f8c3 2098 	str.w	r2, [r3, #152]	; 0x98
  RCC->APB2RSTR &= ~mask;
 8001118:	f8d3 2098 	ldr.w	r2, [r3, #152]	; 0x98
 800111c:	f422 1280 	bic.w	r2, r2, #1048576	; 0x100000
 8001120:	f8c3 2098 	str.w	r2, [r3, #152]	; 0x98
  (void)RCC->APB2RSTR;
 8001124:	f8d3 3098 	ldr.w	r3, [r3, #152]	; 0x98
}
 8001128:	e7ad      	b.n	8001086 <spi_lld_serve_interrupt.part.0+0xf6>
 800112a:	bf00      	nop
 800112c:	24000120 	.word	0x24000120
 8001130:	2400015c 	.word	0x2400015c
 8001134:	24000198 	.word	0x24000198
 8001138:	240001d4 	.word	0x240001d4
 800113c:	24000210 	.word	0x24000210
 8001140:	58024400 	.word	0x58024400
 8001144:	ffff3e1f 	.word	0xffff3e1f
 8001148:	dfb9ffff 	.word	0xdfb9ffff
 800114c:	00000000 	.word	0x00000000

08001150 <ep2_in_cb>:
 */
static inline void chBSemSignalI(binary_semaphore_t *bsp) {

  chDbgCheckClassI();

  if (bsp->sem.cnt < (cnt_t)1) {
 8001150:	4a08      	ldr	r2, [pc, #32]	; (8001174 <ep2_in_cb+0x24>)
 8001152:	6893      	ldr	r3, [r2, #8]
 8001154:	2b00      	cmp	r3, #0
 8001156:	dd00      	ble.n	800115a <ep2_in_cb+0xa>
}
 8001158:	4770      	bx	lr
  chDbgCheck(sp != NULL);
  chDbgAssert(((sp->cnt >= (cnt_t)0) && ch_queue_isempty(&sp->queue)) ||
              ((sp->cnt < (cnt_t)0) && ch_queue_notempty(&sp->queue)),
              "inconsistent semaphore");

  if (++sp->cnt <= (cnt_t)0) {
 800115a:	3301      	adds	r3, #1
 800115c:	2b01      	cmp	r3, #1
 800115e:	6093      	str	r3, [r2, #8]
 8001160:	d0fa      	beq.n	8001158 <ep2_in_cb+0x8>
  ch_queue_t *p = qp->next;
 8001162:	6810      	ldr	r0, [r2, #0]
    /* Note, it is done this way in order to allow a tail call on
             chSchReadyI().*/
    thread_t *tp = threadref(ch_queue_fifo_remove(&sp->queue));
    tp->u.rdymsg = MSG_OK;
 8001164:	2100      	movs	r1, #0
  qp->next       = p->next;
 8001166:	6803      	ldr	r3, [r0, #0]
  qp->next->prev = qp;
 8001168:	605a      	str	r2, [r3, #4]
  qp->next       = p->next;
 800116a:	6013      	str	r3, [r2, #0]
 800116c:	6281      	str	r1, [r0, #40]	; 0x28
 800116e:	f7ff be77 	b.w	8000e60 <__sch_ready_behind.isra.0>
 8001172:	bf00      	nop
 8001174:	2400152c 	.word	0x2400152c
	...

08001180 <sof_handler>:
 8001180:	4a08      	ldr	r2, [pc, #32]	; (80011a4 <sof_handler+0x24>)
 8001182:	6893      	ldr	r3, [r2, #8]
 8001184:	2b00      	cmp	r3, #0
 8001186:	dd00      	ble.n	800118a <sof_handler+0xa>
 * @brief Callback "Start Of Frame" (SOF). Inutilis ici.
 */
static void sof_handler(USBDriver *usbp) {
  (void)usbp;
  chBSemSignalI(&sof_sem);
}
 8001188:	4770      	bx	lr
  if (++sp->cnt <= (cnt_t)0) {
 800118a:	3301      	adds	r3, #1
 800118c:	2b01      	cmp	r3, #1
 800118e:	6093      	str	r3, [r2, #8]
 8001190:	d0fa      	beq.n	8001188 <sof_handler+0x8>
  ch_queue_t *p = qp->next;
 8001192:	6810      	ldr	r0, [r2, #0]
    tp->u.rdymsg = MSG_OK;
 8001194:	2100      	movs	r1, #0
  qp->next       = p->next;
 8001196:	6803      	ldr	r3, [r0, #0]
  qp->next->prev = qp;
 8001198:	605a      	str	r2, [r3, #4]
  qp->next       = p->next;
 800119a:	6013      	str	r3, [r2, #0]
 800119c:	6281      	str	r1, [r0, #40]	; 0x28
 800119e:	f7ff be5f 	b.w	8000e60 <__sch_ready_behind.isra.0>
 80011a2:	bf00      	nop
 80011a4:	24001520 	.word	0x24001520
	...

080011b0 <chEvtBroadcastFlagsI.constprop.0>:
 * @param[in] esp       pointer to the @p event_source_t structure
 * @param[in] flags     the flags set to be added to the listener flags mask
 *
 * @iclass
 */
void chEvtBroadcastFlagsI(event_source_t *esp, eventflags_t flags) {
 80011b0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  event_listener_t *elp;

  chDbgCheckClassI();
  chDbgCheck(esp != NULL);

  elp = esp->next;
 80011b2:	4f15      	ldr	r7, [pc, #84]	; (8001208 <chEvtBroadcastFlagsI.constprop.0+0x58>)
 80011b4:	f857 4f04 	ldr.w	r4, [r7, #4]!
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (elp != (event_listener_t *)esp) {
 80011b8:	42bc      	cmp	r4, r7
 80011ba:	d020      	beq.n	80011fe <chEvtBroadcastFlagsI.constprop.0+0x4e>
 80011bc:	4605      	mov	r5, r0
    tp->u.rdymsg = MSG_OK;
 80011be:	2600      	movs	r6, #0
 80011c0:	e004      	b.n	80011cc <chEvtBroadcastFlagsI.constprop.0+0x1c>
       ((tp->epending & tp->u.ewmask) != (eventmask_t)0)) ||
 80011c2:	2a0b      	cmp	r2, #11
 80011c4:	d01c      	beq.n	8001200 <chEvtBroadcastFlagsI.constprop.0+0x50>
       source does not emit any flag.*/
    if ((flags == (eventflags_t)0) ||
        ((flags & elp->wflags) != (eventflags_t)0)) {
      chEvtSignalI(elp->listener, elp->events);
    }
    elp = elp->next;
 80011c6:	6824      	ldr	r4, [r4, #0]
  while (elp != (event_listener_t *)esp) {
 80011c8:	42bc      	cmp	r4, r7
 80011ca:	d018      	beq.n	80011fe <chEvtBroadcastFlagsI.constprop.0+0x4e>
    elp->flags |= flags;
 80011cc:	68e3      	ldr	r3, [r4, #12]
 80011ce:	432b      	orrs	r3, r5
 80011d0:	60e3      	str	r3, [r4, #12]
    if ((flags == (eventflags_t)0) ||
 80011d2:	b115      	cbz	r5, 80011da <chEvtBroadcastFlagsI.constprop.0+0x2a>
        ((flags & elp->wflags) != (eventflags_t)0)) {
 80011d4:	6923      	ldr	r3, [r4, #16]
    if ((flags == (eventflags_t)0) ||
 80011d6:	421d      	tst	r5, r3
 80011d8:	d0f5      	beq.n	80011c6 <chEvtBroadcastFlagsI.constprop.0+0x16>
  tp->epending |= events;
 80011da:	e9d4 0301 	ldrd	r0, r3, [r4, #4]
 80011de:	6b81      	ldr	r1, [r0, #56]	; 0x38
  if (((tp->state == CH_STATE_WTOREVT) &&
 80011e0:	f890 2024 	ldrb.w	r2, [r0, #36]	; 0x24
  tp->epending |= events;
 80011e4:	430b      	orrs	r3, r1
  if (((tp->state == CH_STATE_WTOREVT) &&
 80011e6:	2a0a      	cmp	r2, #10
  tp->epending |= events;
 80011e8:	6383      	str	r3, [r0, #56]	; 0x38
  if (((tp->state == CH_STATE_WTOREVT) &&
 80011ea:	d1ea      	bne.n	80011c2 <chEvtBroadcastFlagsI.constprop.0+0x12>
       ((tp->epending & tp->u.ewmask) != (eventmask_t)0)) ||
 80011ec:	6a82      	ldr	r2, [r0, #40]	; 0x28
  if (((tp->state == CH_STATE_WTOREVT) &&
 80011ee:	4213      	tst	r3, r2
 80011f0:	d0e9      	beq.n	80011c6 <chEvtBroadcastFlagsI.constprop.0+0x16>
    tp->u.rdymsg = MSG_OK;
 80011f2:	6286      	str	r6, [r0, #40]	; 0x28
 80011f4:	f7ff fe34 	bl	8000e60 <__sch_ready_behind.isra.0>
    elp = elp->next;
 80011f8:	6824      	ldr	r4, [r4, #0]
  while (elp != (event_listener_t *)esp) {
 80011fa:	42bc      	cmp	r4, r7
 80011fc:	d1e6      	bne.n	80011cc <chEvtBroadcastFlagsI.constprop.0+0x1c>
  }
}
 80011fe:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
       ((tp->epending & tp->u.ewmask) == tp->u.ewmask))) {
 8001200:	6a82      	ldr	r2, [r0, #40]	; 0x28
      ((tp->state == CH_STATE_WTANDEVT) &&
 8001202:	439a      	bics	r2, r3
 8001204:	d1df      	bne.n	80011c6 <chEvtBroadcastFlagsI.constprop.0+0x16>
 8001206:	e7f4      	b.n	80011f2 <chEvtBroadcastFlagsI.constprop.0+0x42>
 8001208:	24000070 	.word	0x24000070
 800120c:	00000000 	.word	0x00000000

08001210 <__sch_wakeup>:
static void __sch_wakeup(virtual_timer_t *vtp, void *p) {
 8001210:	b510      	push	{r4, lr}
 8001212:	2330      	movs	r3, #48	; 0x30
 8001214:	460c      	mov	r4, r1
 8001216:	f383 8811 	msr	BASEPRI, r3
  switch (tp->state) {
 800121a:	f891 3024 	ldrb.w	r3, [r1, #36]	; 0x24
 800121e:	2b0c      	cmp	r3, #12
 8001220:	d810      	bhi.n	8001244 <__sch_wakeup+0x34>
 8001222:	e8df f003 	tbb	[pc, r3]
 8001226:	0f2d      	.short	0x0f2d
 8001228:	070b290f 	.word	0x070b290f
 800122c:	0f0f0b0f 	.word	0x0f0f0b0f
 8001230:	0f0f      	.short	0x0f0f
 8001232:	0b          	.byte	0x0b
 8001233:	00          	.byte	0x00
    chSemFastSignalI(tp->u.wtsemp);
 8001234:	6a89      	ldr	r1, [r1, #40]	; 0x28
 */
static inline void chSemFastSignalI(semaphore_t *sp) {

  chDbgCheckClassI();

  sp->cnt++;
 8001236:	688a      	ldr	r2, [r1, #8]
 8001238:	3201      	adds	r2, #1
 800123a:	608a      	str	r2, [r1, #8]
  p->prev->next = p->next;
 800123c:	e9d4 2100 	ldrd	r2, r1, [r4]
 8001240:	600a      	str	r2, [r1, #0]
  p->next->prev = p->prev;
 8001242:	6051      	str	r1, [r2, #4]
  if ((oip->trace_buffer.suspended & CH_DBG_TRACE_MASK_READY) == 0U) {
 8001244:	4916      	ldr	r1, [pc, #88]	; (80012a0 <__sch_wakeup+0x90>)
  tp->u.rdymsg = MSG_TIMEOUT;
 8001246:	f04f 32ff 	mov.w	r2, #4294967295
 800124a:	f8b1 0088 	ldrh.w	r0, [r1, #136]	; 0x88
 800124e:	62a2      	str	r2, [r4, #40]	; 0x28
 8001250:	07c0      	lsls	r0, r0, #31
 8001252:	d519      	bpl.n	8001288 <__sch_wakeup+0x78>
  tp->state = CH_STATE_READY;
 8001254:	2200      	movs	r2, #0
  return threadref(ch_pqueue_insert_behind(&tp->owner->rlist.pqueue,
 8001256:	69a3      	ldr	r3, [r4, #24]
  } while (unlikely(pqp->prio >= p->prio));
 8001258:	68a1      	ldr	r1, [r4, #8]
  tp->state = CH_STATE_READY;
 800125a:	f884 2024 	strb.w	r2, [r4, #36]	; 0x24
    pqp = pqp->next;
 800125e:	681b      	ldr	r3, [r3, #0]
  } while (unlikely(pqp->prio >= p->prio));
 8001260:	689a      	ldr	r2, [r3, #8]
 8001262:	428a      	cmp	r2, r1
 8001264:	d2fb      	bcs.n	800125e <__sch_wakeup+0x4e>
  p->prev       = pqp->prev;
 8001266:	685a      	ldr	r2, [r3, #4]
 8001268:	2100      	movs	r1, #0
  p->next       = pqp;
 800126a:	6023      	str	r3, [r4, #0]
  p->prev       = pqp->prev;
 800126c:	6062      	str	r2, [r4, #4]
  p->prev->next = p;
 800126e:	6014      	str	r4, [r2, #0]
  pqp->prev     = p;
 8001270:	605c      	str	r4, [r3, #4]
 8001272:	f381 8811 	msr	BASEPRI, r1
}
 8001276:	bd10      	pop	{r4, pc}
    *tp->u.wttrp = NULL;
 8001278:	6a8a      	ldr	r2, [r1, #40]	; 0x28
 800127a:	2100      	movs	r1, #0
 800127c:	6011      	str	r1, [r2, #0]
    break;
 800127e:	e7e1      	b.n	8001244 <__sch_wakeup+0x34>
 8001280:	2300      	movs	r3, #0
 8001282:	f383 8811 	msr	BASEPRI, r3
}
 8001286:	bd10      	pop	{r4, pc}
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_READY;
 8001288:	00db      	lsls	r3, r3, #3
 800128a:	f8d1 108c 	ldr.w	r1, [r1, #140]	; 0x8c
 800128e:	f043 0301 	orr.w	r3, r3, #1
    oip->trace_buffer.ptr->u.rdy.msg   = msg;
 8001292:	e9c1 4202 	strd	r4, r2, [r1, #8]
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_READY;
 8001296:	700b      	strb	r3, [r1, #0]
    trace_next(oip);
 8001298:	f7ff fd6a 	bl	8000d70 <trace_next.constprop.0>
}
 800129c:	e7da      	b.n	8001254 <__sch_wakeup+0x44>
 800129e:	bf00      	nop
 80012a0:	24000330 	.word	0x24000330
	...

080012b0 <vt_insert_first.constprop.0>:
                            sysinterval_t delay) {
  sysinterval_t currdelta;

  /* The delta list is empty, the current time becomes the new
     delta list base time, the timer is inserted.*/
  vtlp->lasttime = now;
 80012b0:	4b16      	ldr	r3, [pc, #88]	; (800130c <vt_insert_first.constprop.0+0x5c>)
 80012b2:	2a02      	cmp	r2, #2
static void vt_insert_first(virtual_timers_list_t *vtlp,
 80012b4:	b430      	push	{r4, r5}
static inline void ch_dlist_insert_after(ch_delta_list_t *dlhp,
                                         ch_delta_list_t *dlp,
                                         sysinterval_t delta) {

  dlp->delta      = delta;
  dlp->prev       = dlhp;
 80012b6:	f103 0410 	add.w	r4, r3, #16
  vtlp->lasttime = now;
 80012ba:	61d9      	str	r1, [r3, #28]
  dlp->delta      = delta;
 80012bc:	6082      	str	r2, [r0, #8]
 80012be:	bf38      	it	cc
 80012c0:	2202      	movcc	r2, #2
  dlp->prev       = dlhp;
 80012c2:	6044      	str	r4, [r0, #4]
  dlp->next       = dlp->prev->next;
 80012c4:	691c      	ldr	r4, [r3, #16]
 80012c6:	6004      	str	r4, [r0, #0]
  dlp->next->prev = dlp;
 80012c8:	6060      	str	r0, [r4, #4]

#if CH_CFG_ST_RESOLUTION != CH_CFG_INTERVALS_SIZE
  chDbgCheck(interval <= (sysinterval_t)TIME_MAX_SYSTIME);
#endif

  return systime + (systime_t)interval;
 80012ca:	188c      	adds	r4, r1, r2
  dlhp->next      = dlp;
 80012cc:	6118      	str	r0, [r3, #16]
 *
 * @notapi
 */
static inline void st_lld_start_alarm(systime_t abstime) {

  STM32_ST_TIM->CCR[0] = (uint32_t)abstime;
 80012ce:	f04f 4080 	mov.w	r0, #1073741824	; 0x40000000
 80012d2:	6344      	str	r4, [r0, #52]	; 0x34
  STM32_ST_TIM->SR     = 0;
 80012d4:	2400      	movs	r4, #0
 80012d6:	6104      	str	r4, [r0, #16]
#if ST_LLD_NUM_ALARMS == 1
  STM32_ST_TIM->DIER   = STM32_TIM_DIER_CC1IE;
 80012d8:	2402      	movs	r4, #2
 80012da:	60c4      	str	r4, [r0, #12]
  return (systime_t)STM32_ST_TIM->CNT;
 80012dc:	6a45      	ldr	r5, [r0, #36]	; 0x24
 */
static inline sysinterval_t chTimeDiffX(systime_t start, systime_t end) {

  /*lint -save -e9033 [10.8] This cast is required by the operation, it is
    known that the destination type can be wider.*/
  return (sysinterval_t)((systime_t)(end - start));
 80012de:	eba5 0c01 	sub.w	ip, r5, r1
       Note that the "<" condition is intentional, we want to make sure
       that the alarm is set before the deadline is reached because the
       comparison could happen on the transition depending on the timer
       architecture.*/
    newnow = chVTGetSystemTimeX();
    if (likely(chTimeDiffX(now, newnow) < delay)) {
 80012e2:	4562      	cmp	r2, ip
 80012e4:	d903      	bls.n	80012ee <vt_insert_first.constprop.0+0x3e>
  }
#else
  /* Assertions as fallback.*/
  chDbgAssert(currdelta <= CH_CFG_ST_TIMEDELTA, "insufficient delta");
#endif
}
 80012e6:	bc30      	pop	{r4, r5}
 80012e8:	4770      	bx	lr
 80012ea:	4629      	mov	r1, r5
 80012ec:	4615      	mov	r5, r2
    currdelta += (sysinterval_t)1;
 80012ee:	3401      	adds	r4, #1
  return systime + (systime_t)interval;
 80012f0:	4421      	add	r1, r4
 *
 * @notapi
 */
static inline void st_lld_set_alarm(systime_t abstime) {

  STM32_ST_TIM->CCR[0] = (uint32_t)abstime;
 80012f2:	6341      	str	r1, [r0, #52]	; 0x34
  return (systime_t)STM32_ST_TIM->CNT;
 80012f4:	6a42      	ldr	r2, [r0, #36]	; 0x24
  return (sysinterval_t)((systime_t)(end - start));
 80012f6:	1b51      	subs	r1, r2, r5
    if (likely(chTimeDiffX(now, newnow) < delay)) {
 80012f8:	42a1      	cmp	r1, r4
 80012fa:	d2f6      	bcs.n	80012ea <vt_insert_first.constprop.0+0x3a>
  if (currdelta > CH_CFG_ST_TIMEDELTA) {
 80012fc:	2c02      	cmp	r4, #2
 80012fe:	d9f2      	bls.n	80012e6 <vt_insert_first.constprop.0+0x36>
 * @param[in] mask      fault flags to be added
 */
void chRFCUCollectFaultsI(rfcu_mask_t mask) {

#if CH_CFG_SMP_MODE == FALSE
  currcore->rfcu.mask |= mask;
 8001300:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8001302:	f042 0201 	orr.w	r2, r2, #1
}
 8001306:	bc30      	pop	{r4, r5}
 8001308:	635a      	str	r2, [r3, #52]	; 0x34
 800130a:	4770      	bx	lr
 800130c:	24000330 	.word	0x24000330

08001310 <chThdDequeueNextI.constprop.0>:
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void chThdDequeueNextI(threads_queue_t *tqp, msg_t msg) {
 8001310:	b510      	push	{r4, lr}
  return (bool)(qp->next != qp);
 8001312:	6804      	ldr	r4, [r0, #0]

  if (ch_queue_notempty(&tqp->queue)) {
 8001314:	42a0      	cmp	r0, r4
 8001316:	d018      	beq.n	800134a <chThdDequeueNextI.constprop.0+0x3a>
  qp->next       = p->next;
 8001318:	6823      	ldr	r3, [r4, #0]

  tp = threadref(ch_queue_fifo_remove(&tqp->queue));

  chDbgAssert(tp->state == CH_STATE_QUEUED, "invalid state");

  tp->u.rdymsg = msg;
 800131a:	2100      	movs	r1, #0
  if ((oip->trace_buffer.suspended & CH_DBG_TRACE_MASK_READY) == 0U) {
 800131c:	4a12      	ldr	r2, [pc, #72]	; (8001368 <chThdDequeueNextI.constprop.0+0x58>)
 800131e:	6003      	str	r3, [r0, #0]
  qp->next->prev = qp;
 8001320:	6058      	str	r0, [r3, #4]
 8001322:	f8b2 3088 	ldrh.w	r3, [r2, #136]	; 0x88
 8001326:	62a1      	str	r1, [r4, #40]	; 0x28
 8001328:	f013 0301 	ands.w	r3, r3, #1
 800132c:	d00e      	beq.n	800134c <chThdDequeueNextI.constprop.0+0x3c>
  tp->state = CH_STATE_READY;
 800132e:	2200      	movs	r2, #0
  return threadref(ch_pqueue_insert_behind(&tp->owner->rlist.pqueue,
 8001330:	69a3      	ldr	r3, [r4, #24]
  } while (unlikely(pqp->prio >= p->prio));
 8001332:	68a1      	ldr	r1, [r4, #8]
  tp->state = CH_STATE_READY;
 8001334:	f884 2024 	strb.w	r2, [r4, #36]	; 0x24
    pqp = pqp->next;
 8001338:	681b      	ldr	r3, [r3, #0]
  } while (unlikely(pqp->prio >= p->prio));
 800133a:	689a      	ldr	r2, [r3, #8]
 800133c:	428a      	cmp	r2, r1
 800133e:	d2fb      	bcs.n	8001338 <chThdDequeueNextI.constprop.0+0x28>
  p->prev       = pqp->prev;
 8001340:	685a      	ldr	r2, [r3, #4]
 8001342:	e9c4 3200 	strd	r3, r2, [r4]
  p->prev->next = p;
 8001346:	6014      	str	r4, [r2, #0]
  pqp->prev     = p;
 8001348:	605c      	str	r4, [r3, #4]
    chThdDoDequeueNextI(tqp, msg);
  }
}
 800134a:	bd10      	pop	{r4, pc}
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_READY;
 800134c:	f894 1024 	ldrb.w	r1, [r4, #36]	; 0x24
 8001350:	f8d2 008c 	ldr.w	r0, [r2, #140]	; 0x8c
 8001354:	00ca      	lsls	r2, r1, #3
    oip->trace_buffer.ptr->u.rdy.msg   = msg;
 8001356:	e9c0 4302 	strd	r4, r3, [r0, #8]
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_READY;
 800135a:	f042 0301 	orr.w	r3, r2, #1
 800135e:	7003      	strb	r3, [r0, #0]
    trace_next(oip);
 8001360:	f7ff fd06 	bl	8000d70 <trace_next.constprop.0>
}
 8001364:	e7e3      	b.n	800132e <chThdDequeueNextI.constprop.0+0x1e>
 8001366:	bf00      	nop
 8001368:	24000330 	.word	0x24000330
 800136c:	00000000 	.word	0x00000000

08001370 <ep1_out_cb>:
  const size_t rx_size = ep1_out_state.rxsize;
 8001370:	4b46      	ldr	r3, [pc, #280]	; (800148c <ep1_out_cb+0x11c>)
 8001372:	681b      	ldr	r3, [r3, #0]
  if ((rx_size == 0U) || (rx_size > sizeof rx_pkt)) {
 8001374:	1e5a      	subs	r2, r3, #1
 8001376:	2a3f      	cmp	r2, #63	; 0x3f
static void ep1_out_cb(USBDriver *usbp, usbep_t ep) {
 8001378:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800137c:	4607      	mov	r7, r0
 800137e:	b083      	sub	sp, #12
  if ((rx_size == 0U) || (rx_size > sizeof rx_pkt)) {
 8001380:	d871      	bhi.n	8001466 <ep1_out_cb+0xf6>

void midi_usb_rx_submit_from_isr(const uint8_t *packet, size_t len) {
  if ((packet == NULL) || (len < 4U)) {
 8001382:	2b03      	cmp	r3, #3
 8001384:	d95a      	bls.n	800143c <ep1_out_cb+0xcc>
    return;
  }

  const size_t packets = len / 4U;
 8001386:	089b      	lsrs	r3, r3, #2
 8001388:	2230      	movs	r2, #48	; 0x30
 800138a:	f382 8811 	msr	BASEPRI, r2

  osalSysLockFromISR();
  if (midi_usb_rx_mb.buffer == NULL) {
 800138e:	4e40      	ldr	r6, [pc, #256]	; (8001490 <ep1_out_cb+0x120>)
 8001390:	6832      	ldr	r2, [r6, #0]
 8001392:	2a00      	cmp	r2, #0
 8001394:	d050      	beq.n	8001438 <ep1_out_cb+0xc8>
 8001396:	4a3f      	ldr	r2, [pc, #252]	; (8001494 <ep1_out_cb+0x124>)
 8001398:	f8df 80fc 	ldr.w	r8, [pc, #252]	; 8001498 <ep1_out_cb+0x128>
 800139c:	4615      	mov	r5, r2
 800139e:	eb02 0a83 	add.w	sl, r2, r3, lsl #2
 80013a2:	f8df b0f8 	ldr.w	fp, [pc, #248]	; 800149c <ep1_out_cb+0x12c>

      if (chMBPostI(&midi_usb_rx_mb, m) == MSG_OK) {
        midi_usb_rx_queue_increment_i();
        midi_rx_stats.usb_rx_enqueued++;
      } else {
        midi_usb_rx_drops++;
 80013a6:	f8df 90f8 	ldr.w	r9, [pc, #248]	; 80014a0 <ep1_out_cb+0x130>
  if (midi_usb_rx_mb.buffer == NULL) {
 80013aa:	9201      	str	r2, [sp, #4]
 80013ac:	e00d      	b.n	80013ca <ep1_out_cb+0x5a>
        midi_usb_rx_drops++;
 80013ae:	f8d9 3000 	ldr.w	r3, [r9]
        midi_rx_stats.usb_rx_drops++;
      }
    }
    packet += 4U;
 80013b2:	3504      	adds	r5, #4
        midi_usb_rx_drops++;
 80013b4:	3301      	adds	r3, #1
  for (size_t i = 0; i < packets; i++) {
 80013b6:	45aa      	cmp	sl, r5
        midi_usb_rx_drops++;
 80013b8:	f8c9 3000 	str.w	r3, [r9]
        midi_rx_stats.usb_rx_drops++;
 80013bc:	f8d8 3004 	ldr.w	r3, [r8, #4]
 80013c0:	f103 0301 	add.w	r3, r3, #1
 80013c4:	f8c8 3004 	str.w	r3, [r8, #4]
  for (size_t i = 0; i < packets; i++) {
 80013c8:	d032      	beq.n	8001430 <ep1_out_cb+0xc0>
    if (midi_usb_rx_queue_fill >= MIDI_USB_RX_QUEUE_LEN) {
 80013ca:	f8bb 4000 	ldrh.w	r4, [fp]
 80013ce:	2c7f      	cmp	r4, #127	; 0x7f
 80013d0:	d8ed      	bhi.n	80013ae <ep1_out_cb+0x3e>
 80013d2:	682a      	ldr	r2, [r5, #0]

  chDbgCheckClassI();
  chDbgCheck(mbp != NULL);

  /* If the mailbox is in reset state then returns immediately.*/
  if (mbp->reset) {
 80013d4:	7d33      	ldrb	r3, [r6, #20]
 80013d6:	ba12      	rev	r2, r2
 80013d8:	2b00      	cmp	r3, #0
 80013da:	d1e8      	bne.n	80013ae <ep1_out_cb+0x3e>
 */
static inline size_t chMBGetUsedCountI(const mailbox_t *mbp) {

  chDbgCheckClassI();

  return mbp->cnt;
 80013dc:	6933      	ldr	r3, [r6, #16]
  return (size_t)(mbp->top - mbp->buffer);
 80013de:	e9d6 1000 	ldrd	r1, r0, [r6]
 80013e2:	eba0 0c01 	sub.w	ip, r0, r1
    return MSG_RESET;
  }

  /* Is there a free message slot in queue? if so then post.*/
  if (chMBGetFreeCountI(mbp) > (size_t)0) {
 80013e6:	ebb3 0fac 	cmp.w	r3, ip, asr #2
 80013ea:	d0e0      	beq.n	80013ae <ep1_out_cb+0x3e>
    *mbp->wrptr++ = msg;
 80013ec:	f8d6 e008 	ldr.w	lr, [r6, #8]
    if (mbp->wrptr >= mbp->top) {
      mbp->wrptr = mbp->buffer;
    }
    mbp->cnt++;
 80013f0:	3301      	adds	r3, #1
    midi_usb_rx_queue_fill++;
 80013f2:	3401      	adds	r4, #1
    packet += 4U;
 80013f4:	3504      	adds	r5, #4
    *mbp->wrptr++ = msg;
 80013f6:	f10e 0c04 	add.w	ip, lr, #4
    midi_usb_rx_queue_fill++;
 80013fa:	b2a4      	uxth	r4, r4
    if (mbp->wrptr >= mbp->top) {
 80013fc:	4560      	cmp	r0, ip
    *mbp->wrptr++ = msg;
 80013fe:	f8c6 c008 	str.w	ip, [r6, #8]
 8001402:	f8ce 2000 	str.w	r2, [lr]
      mbp->wrptr = mbp->buffer;
 8001406:	bf88      	it	hi
 8001408:	68b1      	ldrhi	r1, [r6, #8]

    /* If there is a reader waiting then makes it ready.*/
    chThdDequeueNextI(&mbp->qr, MSG_OK);
 800140a:	4826      	ldr	r0, [pc, #152]	; (80014a4 <ep1_out_cb+0x134>)
    mbp->cnt++;
 800140c:	6133      	str	r3, [r6, #16]
 800140e:	60b1      	str	r1, [r6, #8]
    chThdDequeueNextI(&mbp->qr, MSG_OK);
 8001410:	f7ff ff7e 	bl	8001310 <chThdDequeueNextI.constprop.0>
    if (midi_usb_rx_queue_fill > midi_usb_rx_queue_high_water) {
 8001414:	4a24      	ldr	r2, [pc, #144]	; (80014a8 <ep1_out_cb+0x138>)
    midi_usb_rx_queue_fill++;
 8001416:	f8ab 4000 	strh.w	r4, [fp]
    if (midi_usb_rx_queue_fill > midi_usb_rx_queue_high_water) {
 800141a:	8813      	ldrh	r3, [r2, #0]
 800141c:	42a3      	cmp	r3, r4
        midi_rx_stats.usb_rx_enqueued++;
 800141e:	f8d8 3000 	ldr.w	r3, [r8]
      midi_usb_rx_queue_high_water = midi_usb_rx_queue_fill;
 8001422:	bf38      	it	cc
 8001424:	8014      	strhcc	r4, [r2, #0]
        midi_rx_stats.usb_rx_enqueued++;
 8001426:	3301      	adds	r3, #1
  for (size_t i = 0; i < packets; i++) {
 8001428:	45aa      	cmp	sl, r5
        midi_rx_stats.usb_rx_enqueued++;
 800142a:	f8c8 3000 	str.w	r3, [r8]
  for (size_t i = 0; i < packets; i++) {
 800142e:	d1cc      	bne.n	80013ca <ep1_out_cb+0x5a>
 8001430:	2300      	movs	r3, #0
 8001432:	f383 8811 	msr	BASEPRI, r3
 8001436:	e003      	b.n	8001440 <ep1_out_cb+0xd0>
 8001438:	f382 8811 	msr	BASEPRI, r2
 800143c:	4b15      	ldr	r3, [pc, #84]	; (8001494 <ep1_out_cb+0x124>)
 800143e:	9301      	str	r3, [sp, #4]
  usbp->receiving |= (uint16_t)((unsigned)1U << (unsigned)ep);
 8001440:	897a      	ldrh	r2, [r7, #10]
  osp->rxsize = n;
 8001442:	2440      	movs	r4, #64	; 0x40
  osp = usbp->epc[ep]->out_state;
 8001444:	693b      	ldr	r3, [r7, #16]
  usb_lld_start_out(usbp, ep);
 8001446:	4638      	mov	r0, r7
  usbp->receiving |= (uint16_t)((unsigned)1U << (unsigned)ep);
 8001448:	f042 0202 	orr.w	r2, r2, #2
  osp = usbp->epc[ep]->out_state;
 800144c:	699b      	ldr	r3, [r3, #24]
  usbp->receiving |= (uint16_t)((unsigned)1U << (unsigned)ep);
 800144e:	817a      	strh	r2, [r7, #10]
  osp->rxbuf  = buf;
 8001450:	9a01      	ldr	r2, [sp, #4]
 8001452:	609a      	str	r2, [r3, #8]
  osp->rxcnt  = 0;
 8001454:	2200      	movs	r2, #0
  usb_lld_start_out(usbp, ep);
 8001456:	2101      	movs	r1, #1
  osp->rxcnt  = 0;
 8001458:	e9c3 4200 	strd	r4, r2, [r3]
}
 800145c:	b003      	add	sp, #12
 800145e:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  usb_lld_start_out(usbp, ep);
 8001462:	f7ff b94d 	b.w	8000700 <usb_lld_start_out>
    usb_midi_rx_invalid_size++;
 8001466:	4a11      	ldr	r2, [pc, #68]	; (80014ac <ep1_out_cb+0x13c>)
    midi_rx_stats.usb_rx_drops++;
 8001468:	490b      	ldr	r1, [pc, #44]	; (8001498 <ep1_out_cb+0x128>)
    usb_midi_rx_invalid_size++;
 800146a:	6813      	ldr	r3, [r2, #0]
  osp = usbp->epc[ep]->out_state;
 800146c:	6904      	ldr	r4, [r0, #16]
 800146e:	3301      	adds	r3, #1
 8001470:	6013      	str	r3, [r2, #0]
  usbp->receiving |= (uint16_t)((unsigned)1U << (unsigned)ep);
 8001472:	8943      	ldrh	r3, [r0, #10]
    midi_rx_stats.usb_rx_drops++;
 8001474:	684a      	ldr	r2, [r1, #4]
 8001476:	f043 0302 	orr.w	r3, r3, #2
 800147a:	3201      	adds	r2, #1
 800147c:	8143      	strh	r3, [r0, #10]
  osp = usbp->epc[ep]->out_state;
 800147e:	69a3      	ldr	r3, [r4, #24]
  osp->rxbuf  = buf;
 8001480:	4c04      	ldr	r4, [pc, #16]	; (8001494 <ep1_out_cb+0x124>)
 8001482:	604a      	str	r2, [r1, #4]
 8001484:	609c      	str	r4, [r3, #8]
  osp->rxsize = n;
 8001486:	2440      	movs	r4, #64	; 0x40
 8001488:	e7e4      	b.n	8001454 <ep1_out_cb+0xe4>
 800148a:	bf00      	nop
 800148c:	24000e04 	.word	0x24000e04
 8001490:	24001284 	.word	0x24001284
 8001494:	240014c0 	.word	0x240014c0
 8001498:	24000e28 	.word	0x24000e28
 800149c:	240014ac 	.word	0x240014ac
 80014a0:	24001280 	.word	0x24001280
 80014a4:	240012a4 	.word	0x240012a4
 80014a8:	240014ae 	.word	0x240014ae
 80014ac:	24001538 	.word	0x24001538

080014b0 <_usb_ep0setup>:
void _usb_ep0setup(USBDriver *usbp, usbep_t ep) {
 80014b0:	b570      	push	{r4, r5, r6, lr}
  if (usbp->ep0state != USB_EP0_STP_WAITING) {
 80014b2:	f890 3070 	ldrb.w	r3, [r0, #112]	; 0x70
void _usb_ep0setup(USBDriver *usbp, usbep_t ep) {
 80014b6:	4604      	mov	r4, r0
  if (usbp->ep0state != USB_EP0_STP_WAITING) {
 80014b8:	b113      	cbz	r3, 80014c0 <_usb_ep0setup+0x10>
    usbp->ep0state = USB_EP0_STP_WAITING;
 80014ba:	2300      	movs	r3, #0
 80014bc:	f880 3070 	strb.w	r3, [r0, #112]	; 0x70
  memcpy(buf, usbp->epc[ep]->setup_buf, 8);
 80014c0:	eb04 0181 	add.w	r1, r4, r1, lsl #2
  if ((usbp->config->requests_hook_cb == NULL) ||
 80014c4:	6862      	ldr	r2, [r4, #4]
 80014c6:	68cb      	ldr	r3, [r1, #12]
 80014c8:	6a1b      	ldr	r3, [r3, #32]
 80014ca:	6819      	ldr	r1, [r3, #0]
 80014cc:	685b      	ldr	r3, [r3, #4]
 80014ce:	f8c4 1080 	str.w	r1, [r4, #128]	; 0x80
 80014d2:	f8c4 3084 	str.w	r3, [r4, #132]	; 0x84
 80014d6:	6893      	ldr	r3, [r2, #8]
 80014d8:	b353      	cbz	r3, 8001530 <_usb_ep0setup+0x80>
      !(usbp->config->requests_hook_cb(usbp))) {
 80014da:	4620      	mov	r0, r4
 80014dc:	4798      	blx	r3
  if ((usbp->config->requests_hook_cb == NULL) ||
 80014de:	b338      	cbz	r0, 8001530 <_usb_ep0setup+0x80>
  if (usbp->ep0n > max) {
 80014e0:	6fa3      	ldr	r3, [r4, #120]	; 0x78
 80014e2:	f894 1080 	ldrb.w	r1, [r4, #128]	; 0x80
  max = (size_t)get_hword(&usbp->setup[6]);
 80014e6:	f8b4 2086 	ldrh.w	r2, [r4, #134]	; 0x86
  if (usbp->ep0n > max) {
 80014ea:	429a      	cmp	r2, r3
  if ((usbp->setup[0] & USB_RTYPE_DIR_MASK) == USB_RTYPE_DIR_DEV2HOST) {
 80014ec:	bf2c      	ite	cs
 80014ee:	461a      	movcs	r2, r3
    usbp->ep0n = max;
 80014f0:	67a2      	strcc	r2, [r4, #120]	; 0x78
  if ((usbp->setup[0] & USB_RTYPE_DIR_MASK) == USB_RTYPE_DIR_DEV2HOST) {
 80014f2:	0609      	lsls	r1, r1, #24
 80014f4:	f100 80e1 	bmi.w	80016ba <_usb_ep0setup+0x20a>
    if (usbp->ep0n != 0U) {
 80014f8:	2a00      	cmp	r2, #0
 80014fa:	f000 8094 	beq.w	8001626 <_usb_ep0setup+0x176>
      usbp->ep0state = USB_EP0_OUT_RX;
 80014fe:	2215      	movs	r2, #21
 8001500:	2330      	movs	r3, #48	; 0x30
 8001502:	f884 2070 	strb.w	r2, [r4, #112]	; 0x70
 8001506:	f383 8811 	msr	BASEPRI, r3
  usbp->receiving |= (uint16_t)((unsigned)1U << (unsigned)ep);
 800150a:	8962      	ldrh	r2, [r4, #10]
  usb_lld_start_out(usbp, ep);
 800150c:	4620      	mov	r0, r4
  osp = usbp->epc[ep]->out_state;
 800150e:	68e3      	ldr	r3, [r4, #12]
  usbp->receiving |= (uint16_t)((unsigned)1U << (unsigned)ep);
 8001510:	f042 0201 	orr.w	r2, r2, #1
  osp = usbp->epc[ep]->out_state;
 8001514:	699b      	ldr	r3, [r3, #24]
  usbp->receiving |= (uint16_t)((unsigned)1U << (unsigned)ep);
 8001516:	8162      	strh	r2, [r4, #10]
      usbStartReceiveI(usbp, 0, (uint8_t *)usbp->ep0next, usbp->ep0n);
 8001518:	e9d4 511d 	ldrd	r5, r1, [r4, #116]	; 0x74
  osp->rxcnt  = 0;
 800151c:	2400      	movs	r4, #0
  osp->rxsize = n;
 800151e:	6019      	str	r1, [r3, #0]
  osp->rxbuf  = buf;
 8001520:	609d      	str	r5, [r3, #8]
  usb_lld_start_out(usbp, ep);
 8001522:	4621      	mov	r1, r4
  osp->rxcnt  = 0;
 8001524:	605c      	str	r4, [r3, #4]
  usb_lld_start_out(usbp, ep);
 8001526:	f7ff f8eb 	bl	8000700 <usb_lld_start_out>
 800152a:	f384 8811 	msr	BASEPRI, r4
}
 800152e:	bd70      	pop	{r4, r5, r6, pc}
    if (((usbp->setup[0] & USB_RTYPE_TYPE_MASK) != USB_RTYPE_TYPE_STD) ||
 8001530:	f894 1080 	ldrb.w	r1, [r4, #128]	; 0x80
 8001534:	f011 0660 	ands.w	r6, r1, #96	; 0x60
 8001538:	4608      	mov	r0, r1
 800153a:	d11c      	bne.n	8001576 <_usb_ep0setup+0xc6>
           ((uint32_t)usbp->setup[1] << 8U))) {
 800153c:	f894 2081 	ldrb.w	r2, [r4, #129]	; 0x81
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
 8001540:	f001 037f 	and.w	r3, r1, #127	; 0x7f
                                        USB_RTYPE_TYPE_MASK)) |
 8001544:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
 8001548:	f240 3202 	movw	r2, #770	; 0x302
 800154c:	4293      	cmp	r3, r2
 800154e:	f000 8169 	beq.w	8001824 <_usb_ep0setup+0x374>
 8001552:	d847      	bhi.n	80015e4 <_usb_ep0setup+0x134>
 8001554:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 8001558:	f000 8113 	beq.w	8001782 <_usb_ep0setup+0x2d2>
 800155c:	d923      	bls.n	80015a6 <_usb_ep0setup+0xf6>
 800155e:	f5b3 7f81 	cmp.w	r3, #258	; 0x102
 8001562:	f000 811d 	beq.w	80017a0 <_usb_ep0setup+0x2f0>
 8001566:	f5b3 7f40 	cmp.w	r3, #768	; 0x300
 800156a:	d104      	bne.n	8001576 <_usb_ep0setup+0xc6>
    if (usbp->setup[2] == USB_FEATURE_DEVICE_REMOTE_WAKEUP) {
 800156c:	f894 3082 	ldrb.w	r3, [r4, #130]	; 0x82
 8001570:	2b01      	cmp	r3, #1
 8001572:	f000 80da 	beq.w	800172a <_usb_ep0setup+0x27a>
 8001576:	f8d4 0090 	ldr.w	r0, [r4, #144]	; 0x90
  usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_STALL;
 800157a:	f8d0 3900 	ldr.w	r3, [r0, #2304]	; 0x900
      _usb_isr_invoke_event_cb(usbp, USB_EVENT_STALLED);
 800157e:	6862      	ldr	r2, [r4, #4]
 8001580:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
 8001584:	6812      	ldr	r2, [r2, #0]
 8001586:	f8c0 3900 	str.w	r3, [r0, #2304]	; 0x900
  usbp->otg->oe[ep].DOEPCTL |= DOEPCTL_STALL;
 800158a:	f8d0 3b00 	ldr.w	r3, [r0, #2816]	; 0xb00
 800158e:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
 8001592:	f8c0 3b00 	str.w	r3, [r0, #2816]	; 0xb00
 8001596:	b112      	cbz	r2, 800159e <_usb_ep0setup+0xee>
 8001598:	2106      	movs	r1, #6
 800159a:	4620      	mov	r0, r4
 800159c:	4790      	blx	r2
      usbp->ep0state = USB_EP0_ERROR;
 800159e:	2306      	movs	r3, #6
 80015a0:	f884 3070 	strb.w	r3, [r4, #112]	; 0x70
}
 80015a4:	bd70      	pop	{r4, r5, r6, pc}
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
 80015a6:	2b01      	cmp	r3, #1
 80015a8:	d062      	beq.n	8001670 <_usb_ep0setup+0x1c0>
 80015aa:	2b02      	cmp	r3, #2
 80015ac:	d152      	bne.n	8001654 <_usb_ep0setup+0x1a4>
    if ((usbp->setup[4] & 0x80U) != 0U) {
 80015ae:	f994 0084 	ldrsb.w	r0, [r4, #132]	; 0x84
 80015b2:	f894 2084 	ldrb.w	r2, [r4, #132]	; 0x84
 80015b6:	2800      	cmp	r0, #0
 80015b8:	f8d4 0090 	ldr.w	r0, [r4, #144]	; 0x90
  ctl = usbp->otg->ie[ep].DIEPCTL;
 80015bc:	f002 020f 	and.w	r2, r2, #15
 80015c0:	f2c0 80ac 	blt.w	800171c <_usb_ep0setup+0x26c>
  ctl = usbp->otg->oe[ep].DOEPCTL;
 80015c4:	3258      	adds	r2, #88	; 0x58
 80015c6:	0152      	lsls	r2, r2, #5
 80015c8:	5882      	ldr	r2, [r0, r2]
  if (!(ctl & DOEPCTL_USBAEP))
 80015ca:	0415      	lsls	r5, r2, #16
 80015cc:	d5d5      	bpl.n	800157a <_usb_ep0setup+0xca>
  if (ctl & DIEPCTL_STALL)
 80015ce:	0296      	lsls	r6, r2, #10
        usbSetupTransfer(usbp, (uint8_t *)active_status, 2, NULL);
 80015d0:	f04f 0202 	mov.w	r2, #2
        usbSetupTransfer(usbp, (uint8_t *)halted_status, 2, NULL);
 80015d4:	bf4c      	ite	mi
 80015d6:	48a6      	ldrmi	r0, [pc, #664]	; (8001870 <_usb_ep0setup+0x3c0>)
        usbSetupTransfer(usbp, (uint8_t *)active_status, 2, NULL);
 80015d8:	48a6      	ldrpl	r0, [pc, #664]	; (8001874 <_usb_ep0setup+0x3c4>)
 80015da:	e9c4 021d 	strd	r0, r2, [r4, #116]	; 0x74
 80015de:	2200      	movs	r2, #0
 80015e0:	67e2      	str	r2, [r4, #124]	; 0x7c
        return true;
 80015e2:	e780      	b.n	80014e6 <_usb_ep0setup+0x36>
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
 80015e4:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
 80015e8:	f000 8114 	beq.w	8001814 <_usb_ep0setup+0x364>
 80015ec:	d947      	bls.n	800167e <_usb_ep0setup+0x1ce>
 80015ee:	f5b3 6f10 	cmp.w	r3, #2304	; 0x900
 80015f2:	d139      	bne.n	8001668 <_usb_ep0setup+0x1b8>
      if (usbp->state == USB_ACTIVE) {
 80015f4:	7823      	ldrb	r3, [r4, #0]
 80015f6:	2b04      	cmp	r3, #4
 80015f8:	f000 80a1 	beq.w	800173e <_usb_ep0setup+0x28e>
      if (usbp->setup[2] != 0U) {
 80015fc:	f894 3082 	ldrb.w	r3, [r4, #130]	; 0x82
 8001600:	b14b      	cbz	r3, 8001616 <_usb_ep0setup+0x166>
        usbp->state = USB_ACTIVE;
 8001602:	2104      	movs	r1, #4
        _usb_isr_invoke_event_cb(usbp, USB_EVENT_CONFIGURED);
 8001604:	6862      	ldr	r2, [r4, #4]
        usbp->configuration = usbp->setup[2];
 8001606:	f884 308b 	strb.w	r3, [r4, #139]	; 0x8b
        usbp->state = USB_ACTIVE;
 800160a:	7021      	strb	r1, [r4, #0]
        _usb_isr_invoke_event_cb(usbp, USB_EVENT_CONFIGURED);
 800160c:	6813      	ldr	r3, [r2, #0]
 800160e:	b113      	cbz	r3, 8001616 <_usb_ep0setup+0x166>
 8001610:	2102      	movs	r1, #2
 8001612:	4620      	mov	r0, r4
 8001614:	4798      	blx	r3
    usbSetupTransfer(usbp, NULL, 0, NULL);
 8001616:	2300      	movs	r3, #0
  if ((usbp->setup[0] & USB_RTYPE_DIR_MASK) == USB_RTYPE_DIR_DEV2HOST) {
 8001618:	f894 0080 	ldrb.w	r0, [r4, #128]	; 0x80
    usbSetupTransfer(usbp, NULL, 0, NULL);
 800161c:	e9c4 331d 	strd	r3, r3, [r4, #116]	; 0x74
 8001620:	67e3      	str	r3, [r4, #124]	; 0x7c
  if ((usbp->setup[0] & USB_RTYPE_DIR_MASK) == USB_RTYPE_DIR_DEV2HOST) {
 8001622:	0603      	lsls	r3, r0, #24
 8001624:	d463      	bmi.n	80016ee <_usb_ep0setup+0x23e>
      usbp->ep0state = USB_EP0_IN_SENDING_STS;
 8001626:	220b      	movs	r2, #11
 8001628:	2330      	movs	r3, #48	; 0x30
 800162a:	f884 2070 	strb.w	r2, [r4, #112]	; 0x70
 800162e:	f383 8811 	msr	BASEPRI, r3
  usbp->transmitting |= (uint16_t)((unsigned)1U << (unsigned)ep);
 8001632:	8922      	ldrh	r2, [r4, #8]
  isp->txbuf  = buf;
 8001634:	2500      	movs	r5, #0
  isp = usbp->epc[ep]->in_state;
 8001636:	68e3      	ldr	r3, [r4, #12]
  usb_lld_start_in(usbp, ep);
 8001638:	4620      	mov	r0, r4
  usbp->transmitting |= (uint16_t)((unsigned)1U << (unsigned)ep);
 800163a:	f042 0201 	orr.w	r2, r2, #1
  usb_lld_start_in(usbp, ep);
 800163e:	4629      	mov	r1, r5
  isp = usbp->epc[ep]->in_state;
 8001640:	695b      	ldr	r3, [r3, #20]
  usbp->transmitting |= (uint16_t)((unsigned)1U << (unsigned)ep);
 8001642:	8122      	strh	r2, [r4, #8]
  isp->txbuf  = buf;
 8001644:	609d      	str	r5, [r3, #8]
  isp->txcnt  = 0;
 8001646:	e9c3 5500 	strd	r5, r5, [r3]
  usb_lld_start_in(usbp, ep);
 800164a:	f7ff f8a1 	bl	8000790 <usb_lld_start_in>
 800164e:	f385 8811 	msr	BASEPRI, r5
}
 8001652:	bd70      	pop	{r4, r5, r6, pc}
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
 8001654:	2b00      	cmp	r3, #0
 8001656:	d18e      	bne.n	8001576 <_usb_ep0setup+0xc6>
    usbSetupTransfer(usbp, (uint8_t *)&usbp->status, 2, NULL);
 8001658:	2202      	movs	r2, #2
 800165a:	f104 0088 	add.w	r0, r4, #136	; 0x88
 800165e:	67e3      	str	r3, [r4, #124]	; 0x7c
 8001660:	6760      	str	r0, [r4, #116]	; 0x74
 8001662:	4613      	mov	r3, r2
 8001664:	67a2      	str	r2, [r4, #120]	; 0x78
    return true;
 8001666:	e73e      	b.n	80014e6 <_usb_ep0setup+0x36>
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
 8001668:	f640 4202 	movw	r2, #3074	; 0xc02
 800166c:	4293      	cmp	r3, r2
 800166e:	d182      	bne.n	8001576 <_usb_ep0setup+0xc6>
    usbSetupTransfer(usbp, (uint8_t *)zero_status, 2, NULL);
 8001670:	2302      	movs	r3, #2
 8001672:	4881      	ldr	r0, [pc, #516]	; (8001878 <_usb_ep0setup+0x3c8>)
 8001674:	2200      	movs	r2, #0
 8001676:	e9c4 031d 	strd	r0, r3, [r4, #116]	; 0x74
 800167a:	67e2      	str	r2, [r4, #124]	; 0x7c
    return true;
 800167c:	e733      	b.n	80014e6 <_usb_ep0setup+0x36>
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
 800167e:	f5b3 6fa0 	cmp.w	r3, #1280	; 0x500
 8001682:	f000 80a9 	beq.w	80017d8 <_usb_ep0setup+0x328>
 8001686:	f5a3 63c0 	sub.w	r3, r3, #1536	; 0x600
 800168a:	2b01      	cmp	r3, #1
 800168c:	f63f af73 	bhi.w	8001576 <_usb_ep0setup+0xc6>
    dp = usbp->config->get_descriptor_cb(usbp, usbp->setup[3],
 8001690:	6861      	ldr	r1, [r4, #4]
 8001692:	4620      	mov	r0, r4
 8001694:	f8b4 3084 	ldrh.w	r3, [r4, #132]	; 0x84
 8001698:	684d      	ldr	r5, [r1, #4]
 800169a:	f894 2082 	ldrb.w	r2, [r4, #130]	; 0x82
 800169e:	f894 1083 	ldrb.w	r1, [r4, #131]	; 0x83
 80016a2:	47a8      	blx	r5
    if (dp == NULL) {
 80016a4:	2800      	cmp	r0, #0
 80016a6:	f43f af66 	beq.w	8001576 <_usb_ep0setup+0xc6>
    usbSetupTransfer(usbp, (uint8_t *)dp->ud_string, dp->ud_size, NULL);
 80016aa:	f894 1080 	ldrb.w	r1, [r4, #128]	; 0x80
 80016ae:	e9d0 3200 	ldrd	r3, r2, [r0]
 80016b2:	67e6      	str	r6, [r4, #124]	; 0x7c
 80016b4:	e9c4 231d 	strd	r2, r3, [r4, #116]	; 0x74
    return true;
 80016b8:	e715      	b.n	80014e6 <_usb_ep0setup+0x36>
    if (usbp->ep0n != 0U) {
 80016ba:	b1c2      	cbz	r2, 80016ee <_usb_ep0setup+0x23e>
      usbp->ep0state = USB_EP0_IN_TX;
 80016bc:	2209      	movs	r2, #9
 80016be:	2330      	movs	r3, #48	; 0x30
 80016c0:	f884 2070 	strb.w	r2, [r4, #112]	; 0x70
 80016c4:	f383 8811 	msr	BASEPRI, r3
  usbp->transmitting |= (uint16_t)((unsigned)1U << (unsigned)ep);
 80016c8:	8922      	ldrh	r2, [r4, #8]
  usb_lld_start_in(usbp, ep);
 80016ca:	4620      	mov	r0, r4
  isp = usbp->epc[ep]->in_state;
 80016cc:	68e3      	ldr	r3, [r4, #12]
  usbp->transmitting |= (uint16_t)((unsigned)1U << (unsigned)ep);
 80016ce:	f042 0201 	orr.w	r2, r2, #1
  isp = usbp->epc[ep]->in_state;
 80016d2:	695b      	ldr	r3, [r3, #20]
  usbp->transmitting |= (uint16_t)((unsigned)1U << (unsigned)ep);
 80016d4:	8122      	strh	r2, [r4, #8]
      usbStartTransmitI(usbp, 0, usbp->ep0next, usbp->ep0n);
 80016d6:	e9d4 511d 	ldrd	r5, r1, [r4, #116]	; 0x74
  isp->txcnt  = 0;
 80016da:	2400      	movs	r4, #0
  isp->txsize = n;
 80016dc:	6019      	str	r1, [r3, #0]
  isp->txbuf  = buf;
 80016de:	609d      	str	r5, [r3, #8]
  usb_lld_start_in(usbp, ep);
 80016e0:	4621      	mov	r1, r4
  isp->txcnt  = 0;
 80016e2:	605c      	str	r4, [r3, #4]
  usb_lld_start_in(usbp, ep);
 80016e4:	f7ff f854 	bl	8000790 <usb_lld_start_in>
 80016e8:	f384 8811 	msr	BASEPRI, r4
}
 80016ec:	bd70      	pop	{r4, r5, r6, pc}
      usbp->ep0state = USB_EP0_OUT_WAITING_STS;
 80016ee:	2214      	movs	r2, #20
 80016f0:	2330      	movs	r3, #48	; 0x30
 80016f2:	f884 2070 	strb.w	r2, [r4, #112]	; 0x70
 80016f6:	f383 8811 	msr	BASEPRI, r3
  usbp->receiving |= (uint16_t)((unsigned)1U << (unsigned)ep);
 80016fa:	8962      	ldrh	r2, [r4, #10]
  osp->rxbuf  = buf;
 80016fc:	2500      	movs	r5, #0
  osp = usbp->epc[ep]->out_state;
 80016fe:	68e3      	ldr	r3, [r4, #12]
  usb_lld_start_out(usbp, ep);
 8001700:	4620      	mov	r0, r4
  usbp->receiving |= (uint16_t)((unsigned)1U << (unsigned)ep);
 8001702:	f042 0201 	orr.w	r2, r2, #1
  usb_lld_start_out(usbp, ep);
 8001706:	4629      	mov	r1, r5
  osp = usbp->epc[ep]->out_state;
 8001708:	699b      	ldr	r3, [r3, #24]
  usbp->receiving |= (uint16_t)((unsigned)1U << (unsigned)ep);
 800170a:	8162      	strh	r2, [r4, #10]
  osp->rxbuf  = buf;
 800170c:	609d      	str	r5, [r3, #8]
  osp->rxcnt  = 0;
 800170e:	e9c3 5500 	strd	r5, r5, [r3]
  usb_lld_start_out(usbp, ep);
 8001712:	f7fe fff5 	bl	8000700 <usb_lld_start_out>
 8001716:	f385 8811 	msr	BASEPRI, r5
}
 800171a:	bd70      	pop	{r4, r5, r6, pc}
  ctl = usbp->otg->ie[ep].DIEPCTL;
 800171c:	3248      	adds	r2, #72	; 0x48
 800171e:	0152      	lsls	r2, r2, #5
 8001720:	5882      	ldr	r2, [r0, r2]
  if (!(ctl & DIEPCTL_USBAEP))
 8001722:	0415      	lsls	r5, r2, #16
 8001724:	f57f af29 	bpl.w	800157a <_usb_ep0setup+0xca>
 8001728:	e751      	b.n	80015ce <_usb_ep0setup+0x11e>
      usbp->status |= 2U;
 800172a:	f8b4 3088 	ldrh.w	r3, [r4, #136]	; 0x88
      usbSetupTransfer(usbp, NULL, 0, NULL);
 800172e:	67e6      	str	r6, [r4, #124]	; 0x7c
      usbp->status |= 2U;
 8001730:	f043 0302 	orr.w	r3, r3, #2
      usbSetupTransfer(usbp, NULL, 0, NULL);
 8001734:	e9c4 661d 	strd	r6, r6, [r4, #116]	; 0x74
      usbp->status |= 2U;
 8001738:	f8a4 3088 	strh.w	r3, [r4, #136]	; 0x88
      return true;
 800173c:	e771      	b.n	8001622 <_usb_ep0setup+0x172>
 800173e:	2330      	movs	r3, #48	; 0x30
 8001740:	f383 8811 	msr	BASEPRI, r3
  usbp->transmitting &= 1U;
 8001744:	68a3      	ldr	r3, [r4, #8]
    usbp->epc[i] = NULL;
 8001746:	2220      	movs	r2, #32
 8001748:	4631      	mov	r1, r6
 800174a:	f104 0010 	add.w	r0, r4, #16
  usbp->transmitting &= 1U;
 800174e:	f003 1301 	and.w	r3, r3, #65537	; 0x10001
 8001752:	60a3      	str	r3, [r4, #8]
    usbp->epc[i] = NULL;
 8001754:	f004 f8c6 	bl	80058e4 <memset>
  otg_disable_ep(usbp);
 8001758:	e9d4 0124 	ldrd	r0, r1, [r4, #144]	; 0x90
  usbp->pmnext = usbp->otgparams->rx_fifo_size;
 800175c:	680b      	ldr	r3, [r1, #0]
 800175e:	f8c4 3098 	str.w	r3, [r4, #152]	; 0x98
  otg_disable_ep(usbp);
 8001762:	f7ff fb25 	bl	8000db0 <otg_disable_ep.isra.0>
 8001766:	f386 8811 	msr	BASEPRI, r6
        usbp->state = USB_SELECTED;
 800176a:	2103      	movs	r1, #3
        _usb_isr_invoke_event_cb(usbp, USB_EVENT_UNCONFIGURED);
 800176c:	6863      	ldr	r3, [r4, #4]
        usbp->configuration = 0U;
 800176e:	f884 608b 	strb.w	r6, [r4, #139]	; 0x8b
        usbp->state = USB_SELECTED;
 8001772:	7021      	strb	r1, [r4, #0]
        _usb_isr_invoke_event_cb(usbp, USB_EVENT_UNCONFIGURED);
 8001774:	681b      	ldr	r3, [r3, #0]
 8001776:	2b00      	cmp	r3, #0
 8001778:	f43f af40 	beq.w	80015fc <_usb_ep0setup+0x14c>
 800177c:	4620      	mov	r0, r4
 800177e:	4798      	blx	r3
 8001780:	e73c      	b.n	80015fc <_usb_ep0setup+0x14c>
    if (usbp->setup[2] == USB_FEATURE_DEVICE_REMOTE_WAKEUP) {
 8001782:	f894 3082 	ldrb.w	r3, [r4, #130]	; 0x82
 8001786:	2b01      	cmp	r3, #1
 8001788:	f47f aef5 	bne.w	8001576 <_usb_ep0setup+0xc6>
      usbp->status &= ~2U;
 800178c:	f8b4 3088 	ldrh.w	r3, [r4, #136]	; 0x88
      usbSetupTransfer(usbp, NULL, 0, NULL);
 8001790:	67e6      	str	r6, [r4, #124]	; 0x7c
      usbp->status &= ~2U;
 8001792:	f023 0302 	bic.w	r3, r3, #2
      usbSetupTransfer(usbp, NULL, 0, NULL);
 8001796:	e9c4 661d 	strd	r6, r6, [r4, #116]	; 0x74
      usbp->status &= ~2U;
 800179a:	f8a4 3088 	strh.w	r3, [r4, #136]	; 0x88
      return true;
 800179e:	e740      	b.n	8001622 <_usb_ep0setup+0x172>
    if (usbp->setup[2] != USB_FEATURE_ENDPOINT_HALT) {
 80017a0:	f894 3082 	ldrb.w	r3, [r4, #130]	; 0x82
 80017a4:	2b00      	cmp	r3, #0
 80017a6:	f47f aee6 	bne.w	8001576 <_usb_ep0setup+0xc6>
    if ((usbp->setup[4] & 0x0FU) != 0U) {
 80017aa:	f894 3084 	ldrb.w	r3, [r4, #132]	; 0x84
 80017ae:	f013 020f 	ands.w	r2, r3, #15
 80017b2:	d00c      	beq.n	80017ce <_usb_ep0setup+0x31e>
      if ((usbp->setup[4] & 0x80U) != 0U) {
 80017b4:	f013 0f80 	tst.w	r3, #128	; 0x80
 80017b8:	f8d4 3090 	ldr.w	r3, [r4, #144]	; 0x90
 80017bc:	eb03 1342 	add.w	r3, r3, r2, lsl #5
 80017c0:	d148      	bne.n	8001854 <_usb_ep0setup+0x3a4>
 *
 * @notapi
 */
void usb_lld_clear_out(USBDriver *usbp, usbep_t ep) {

  usbp->otg->oe[ep].DOEPCTL &= ~DOEPCTL_STALL;
 80017c2:	f8d3 2b00 	ldr.w	r2, [r3, #2816]	; 0xb00
 80017c6:	f422 1200 	bic.w	r2, r2, #2097152	; 0x200000
 80017ca:	f8c3 2b00 	str.w	r2, [r3, #2816]	; 0xb00
    usbSetupTransfer(usbp, NULL, 0, NULL);
 80017ce:	2300      	movs	r3, #0
 80017d0:	e9c4 331d 	strd	r3, r3, [r4, #116]	; 0x74
 80017d4:	67e3      	str	r3, [r4, #124]	; 0x7c
    return true;
 80017d6:	e724      	b.n	8001622 <_usb_ep0setup+0x172>
    if ((usbp->setup[0] == USB_RTYPE_RECIPIENT_DEVICE) &&
 80017d8:	f8b4 3080 	ldrh.w	r3, [r4, #128]	; 0x80
 80017dc:	f5b3 6fa0 	cmp.w	r3, #1280	; 0x500
 80017e0:	d1f5      	bne.n	80017ce <_usb_ep0setup+0x31e>
  usbp->address = usbp->setup[2];
 80017e2:	f894 1082 	ldrb.w	r1, [r4, #130]	; 0x82
 80017e6:	f8d4 2090 	ldr.w	r2, [r4, #144]	; 0x90
 80017ea:	f884 108a 	strb.w	r1, [r4, #138]	; 0x8a
  otgp->DCFG = (otgp->DCFG & ~DCFG_DAD_MASK) | DCFG_DAD(usbp->address);
 80017ee:	f8d2 3800 	ldr.w	r3, [r2, #2048]	; 0x800
 80017f2:	f423 63fe 	bic.w	r3, r3, #2032	; 0x7f0
 80017f6:	ea43 1301 	orr.w	r3, r3, r1, lsl #4
  _usb_isr_invoke_event_cb(usbp, USB_EVENT_ADDRESS);
 80017fa:	6861      	ldr	r1, [r4, #4]
 80017fc:	680d      	ldr	r5, [r1, #0]
 80017fe:	f8c2 3800 	str.w	r3, [r2, #2048]	; 0x800
 8001802:	b125      	cbz	r5, 800180e <_usb_ep0setup+0x35e>
 8001804:	4620      	mov	r0, r4
 8001806:	2101      	movs	r1, #1
 8001808:	47a8      	blx	r5
  if ((usbp->setup[0] & USB_RTYPE_DIR_MASK) == USB_RTYPE_DIR_DEV2HOST) {
 800180a:	f894 0080 	ldrb.w	r0, [r4, #128]	; 0x80
  usbp->state = USB_SELECTED;
 800180e:	2303      	movs	r3, #3
 8001810:	7023      	strb	r3, [r4, #0]
}
 8001812:	e7dc      	b.n	80017ce <_usb_ep0setup+0x31e>
    usbSetupTransfer(usbp, &usbp->configuration, 1, NULL);
 8001814:	2201      	movs	r2, #1
 8001816:	f104 008b 	add.w	r0, r4, #139	; 0x8b
 800181a:	67e6      	str	r6, [r4, #124]	; 0x7c
 800181c:	4613      	mov	r3, r2
 800181e:	e9c4 021d 	strd	r0, r2, [r4, #116]	; 0x74
    return true;
 8001822:	e660      	b.n	80014e6 <_usb_ep0setup+0x36>
    if (usbp->setup[2] != USB_FEATURE_ENDPOINT_HALT) {
 8001824:	f894 3082 	ldrb.w	r3, [r4, #130]	; 0x82
 8001828:	2b00      	cmp	r3, #0
 800182a:	f47f aea4 	bne.w	8001576 <_usb_ep0setup+0xc6>
    if ((usbp->setup[4] & 0x0FU) != 0U) {
 800182e:	f894 3084 	ldrb.w	r3, [r4, #132]	; 0x84
 8001832:	f013 020f 	ands.w	r2, r3, #15
 8001836:	d0ca      	beq.n	80017ce <_usb_ep0setup+0x31e>
      if ((usbp->setup[4] & 0x80U) != 0U) {
 8001838:	f013 0f80 	tst.w	r3, #128	; 0x80
 800183c:	f8d4 3090 	ldr.w	r3, [r4, #144]	; 0x90
 8001840:	eb03 1342 	add.w	r3, r3, r2, lsl #5
 8001844:	d10d      	bne.n	8001862 <_usb_ep0setup+0x3b2>
  usbp->otg->oe[ep].DOEPCTL |= DOEPCTL_STALL;
 8001846:	f8d3 2b00 	ldr.w	r2, [r3, #2816]	; 0xb00
 800184a:	f442 1200 	orr.w	r2, r2, #2097152	; 0x200000
 800184e:	f8c3 2b00 	str.w	r2, [r3, #2816]	; 0xb00
}
 8001852:	e7bc      	b.n	80017ce <_usb_ep0setup+0x31e>
 *
 * @notapi
 */
void usb_lld_clear_in(USBDriver *usbp, usbep_t ep) {

  usbp->otg->ie[ep].DIEPCTL &= ~DIEPCTL_STALL;
 8001854:	f8d3 2900 	ldr.w	r2, [r3, #2304]	; 0x900
 8001858:	f422 1200 	bic.w	r2, r2, #2097152	; 0x200000
 800185c:	f8c3 2900 	str.w	r2, [r3, #2304]	; 0x900
}
 8001860:	e7b5      	b.n	80017ce <_usb_ep0setup+0x31e>
  usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_STALL;
 8001862:	f8d3 2900 	ldr.w	r2, [r3, #2304]	; 0x900
 8001866:	f442 1200 	orr.w	r2, r2, #2097152	; 0x200000
 800186a:	f8c3 2900 	str.w	r2, [r3, #2304]	; 0x900
}
 800186e:	e7ae      	b.n	80017ce <_usb_ep0setup+0x31e>
 8001870:	08005e20 	.word	0x08005e20
 8001874:	08005cec 	.word	0x08005cec
 8001878:	08005f60 	.word	0x08005f60
 800187c:	00000000 	.word	0x00000000

08001880 <chSchGoSleepS>:
void chSchGoSleepS(tstate_t newstate) {
 8001880:	b538      	push	{r3, r4, r5, lr}
  thread_t *otp = __instance_get_currthread(oip);
 8001882:	4b14      	ldr	r3, [pc, #80]	; (80018d4 <chSchGoSleepS+0x54>)
  ntp->state = CH_STATE_CURRENT;
 8001884:	2101      	movs	r1, #1
  ch_priority_queue_t *p = pqp->next;
 8001886:	681c      	ldr	r4, [r3, #0]
  thread_t *otp = __instance_get_currthread(oip);
 8001888:	68dd      	ldr	r5, [r3, #12]
  otp->state = newstate;
 800188a:	f885 0024 	strb.w	r0, [r5, #36]	; 0x24
  pqp->next       = p->next;
 800188e:	6822      	ldr	r2, [r4, #0]
  pqp->next->prev = pqp;
 8001890:	6053      	str	r3, [r2, #4]
  ntp->state = CH_STATE_CURRENT;
 8001892:	f884 1024 	strb.w	r1, [r4, #36]	; 0x24
 * @notapi
 */
void __trace_switch(thread_t *ntp, thread_t *otp) {
  os_instance_t *oip = currcore;

  if ((oip->trace_buffer.suspended & CH_DBG_TRACE_MASK_SWITCH) == 0U) {
 8001896:	f8b3 1088 	ldrh.w	r1, [r3, #136]	; 0x88
  pqp->next       = p->next;
 800189a:	601a      	str	r2, [r3, #0]
 800189c:	078a      	lsls	r2, r1, #30
  __instance_set_currthread(oip, ntp);
 800189e:	60dc      	str	r4, [r3, #12]
 80018a0:	d505      	bpl.n	80018ae <chSchGoSleepS+0x2e>
  chSysSwitch(ntp, otp);
 80018a2:	4629      	mov	r1, r5
 80018a4:	4620      	mov	r0, r4
}
 80018a6:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  chSysSwitch(ntp, otp);
 80018aa:	f7fe bd89 	b.w	80003c0 <__port_switch>
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_SWITCH;
 80018ae:	f895 2024 	ldrb.w	r2, [r5, #36]	; 0x24
 80018b2:	f8d3 108c 	ldr.w	r1, [r3, #140]	; 0x8c
 80018b6:	00d3      	lsls	r3, r2, #3
 80018b8:	6aa8      	ldr	r0, [r5, #40]	; 0x28
 80018ba:	f043 0302 	orr.w	r3, r3, #2
    oip->trace_buffer.ptr->state       = (uint8_t)otp->state;
    oip->trace_buffer.ptr->u.sw.ntp    = ntp;
    oip->trace_buffer.ptr->u.sw.wtobjp = otp->u.wtobjp;
 80018be:	e9c1 4002 	strd	r4, r0, [r1, #8]
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_SWITCH;
 80018c2:	700b      	strb	r3, [r1, #0]
    trace_next(oip);
 80018c4:	f7ff fa54 	bl	8000d70 <trace_next.constprop.0>
 80018c8:	4629      	mov	r1, r5
 80018ca:	4620      	mov	r0, r4
}
 80018cc:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  chSysSwitch(ntp, otp);
 80018d0:	f7fe bd76 	b.w	80003c0 <__port_switch>
 80018d4:	24000330 	.word	0x24000330
	...

080018e0 <chSchGoSleepTimeoutS>:
msg_t chSchGoSleepTimeoutS(tstate_t newstate, sysinterval_t timeout) {
 80018e0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  if (TIME_INFINITE != timeout) {
 80018e4:	1c4b      	adds	r3, r1, #1
  thread_t *tp = __instance_get_currthread(currcore);
 80018e6:	4d53      	ldr	r5, [pc, #332]	; (8001a34 <chSchGoSleepTimeoutS+0x154>)
msg_t chSchGoSleepTimeoutS(tstate_t newstate, sysinterval_t timeout) {
 80018e8:	b086      	sub	sp, #24
  thread_t *tp = __instance_get_currthread(currcore);
 80018ea:	f8d5 800c 	ldr.w	r8, [r5, #12]
  if (TIME_INFINITE != timeout) {
 80018ee:	d062      	beq.n	80019b6 <chSchGoSleepTimeoutS+0xd6>
  return (bool)(dlhp == dlhp->next);
 80018f0:	462f      	mov	r7, r5
  chDbgCheckClassI();
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (delay != TIME_IMMEDIATE));

  /* Timer initialization.*/
  vtp->par     = par;
  vtp->func    = vtfunc;
 80018f2:	4b51      	ldr	r3, [pc, #324]	; (8001a38 <chSchGoSleepTimeoutS+0x158>)
 80018f4:	4606      	mov	r6, r0
 80018f6:	f04f 4c80 	mov.w	ip, #1073741824	; 0x40000000
 80018fa:	f857 0f10 	ldr.w	r0, [r7, #16]!
 80018fe:	460a      	mov	r2, r1
 8001900:	e9cd 3803 	strd	r3, r8, [sp, #12]
    if (ch_dlist_isempty(&vtlp->dlist)) {
 8001904:	42b8      	cmp	r0, r7
  vtp->reload  = (sysinterval_t)0;
 8001906:	f04f 0300 	mov.w	r3, #0
 800190a:	9305      	str	r3, [sp, #20]
 800190c:	f8dc 1024 	ldr.w	r1, [ip, #36]	; 0x24
    if (ch_dlist_isempty(&vtlp->dlist)) {
 8001910:	f000 8083 	beq.w	8001a1a <chSchGoSleepTimeoutS+0x13a>
 8001914:	69eb      	ldr	r3, [r5, #28]
    if (delta < vtlp->dlist.next->delta) {
 8001916:	6884      	ldr	r4, [r0, #8]
 8001918:	1acb      	subs	r3, r1, r3
    if (delta < nowdelta) {
 800191a:	18d3      	adds	r3, r2, r3
 800191c:	bf28      	it	cs
 800191e:	4613      	movcs	r3, r2
    if (delta < vtlp->dlist.next->delta) {
 8001920:	429c      	cmp	r4, r3
 8001922:	d922      	bls.n	800196a <chSchGoSleepTimeoutS+0x8a>
  if (delay < currdelta) {
 8001924:	2a02      	cmp	r2, #2
 8001926:	bf38      	it	cc
 8001928:	2202      	movcc	r2, #2
  return systime + (systime_t)interval;
 800192a:	eb01 0e02 	add.w	lr, r1, r2
  STM32_ST_TIM->CCR[0] = (uint32_t)abstime;
 800192e:	f8cc e034 	str.w	lr, [ip, #52]	; 0x34
  return (systime_t)STM32_ST_TIM->CNT;
 8001932:	f8dc e024 	ldr.w	lr, [ip, #36]	; 0x24
  return (sysinterval_t)((systime_t)(end - start));
 8001936:	ebae 0101 	sub.w	r1, lr, r1
    if (likely(nowdelta < delay)) {
 800193a:	428a      	cmp	r2, r1
 800193c:	d815      	bhi.n	800196a <chSchGoSleepTimeoutS+0x8a>
 800193e:	2202      	movs	r2, #2
    currdelta += (sysinterval_t)1;
 8001940:	3201      	adds	r2, #1
  return systime + (systime_t)interval;
 8001942:	eb02 010e 	add.w	r1, r2, lr
  STM32_ST_TIM->CCR[0] = (uint32_t)abstime;
 8001946:	f8cc 1034 	str.w	r1, [ip, #52]	; 0x34
  return (systime_t)STM32_ST_TIM->CNT;
 800194a:	f8dc 1024 	ldr.w	r1, [ip, #36]	; 0x24
  return (sysinterval_t)((systime_t)(end - start));
 800194e:	eba1 0e0e 	sub.w	lr, r1, lr
    if (likely(nowdelta < delay)) {
 8001952:	4596      	cmp	lr, r2
 8001954:	d26a      	bcs.n	8001a2c <chSchGoSleepTimeoutS+0x14c>
  if (currdelta > CH_CFG_ST_TIMEDELTA) {
 8001956:	2a02      	cmp	r2, #2
 8001958:	d907      	bls.n	800196a <chSchGoSleepTimeoutS+0x8a>
 800195a:	6b6a      	ldr	r2, [r5, #52]	; 0x34
 800195c:	f042 0201 	orr.w	r2, r2, #1
 8001960:	636a      	str	r2, [r5, #52]	; 0x34
#else
  ch_system.rfcu.mask |= mask;
#endif

  CH_CFG_RUNTIME_FAULTS_HOOK(mask);
}
 8001962:	e002      	b.n	800196a <chSchGoSleepTimeoutS+0x8a>
  while (likely(dlp->delta < delta)) {
    /* Debug assert if the element is already in the list.*/
    chDbgAssert(dlp != dlep, "element already in list");

    delta -= dlp->delta;
    dlp = dlp->next;
 8001964:	6800      	ldr	r0, [r0, #0]
    delta -= dlp->delta;
 8001966:	1b1b      	subs	r3, r3, r4
  while (likely(dlp->delta < delta)) {
 8001968:	6884      	ldr	r4, [r0, #8]
 800196a:	429c      	cmp	r4, r3
 800196c:	d3fa      	bcc.n	8001964 <chSchGoSleepTimeoutS+0x84>
  dlp->delta      = delta;
 800196e:	9302      	str	r3, [sp, #8]
  dlp->prev->next = dlp;
 8001970:	466c      	mov	r4, sp

  /* The timer is inserted in the delta list.*/
  ch_dlist_insert_before(dlp, dlep, delta);

  /* Adjusting delta for the following element.*/
  dlp->delta -= delta;
 8001972:	6882      	ldr	r2, [r0, #8]
  dlp->next       = dlhp;
 8001974:	9000      	str	r0, [sp, #0]
  dlp->delta -= delta;
 8001976:	1ad2      	subs	r2, r2, r3
  dlp->prev       = dlp->next->prev;
 8001978:	6843      	ldr	r3, [r0, #4]
 800197a:	9301      	str	r3, [sp, #4]
  dlp->prev->next = dlp;
 800197c:	601c      	str	r4, [r3, #0]

  /* Special case when the inserted element is in last position in the list,
     the value in the header must be restored, just doing it is faster than
     checking then doing.*/
  dlhp->delta = (sysinterval_t)-1;
 800197e:	f04f 33ff 	mov.w	r3, #4294967295
  dlhp->prev      = dlp;
 8001982:	e9c0 4201 	strd	r4, r2, [r0, #4]
  dlhp->delta = (sysinterval_t)-1;
 8001986:	61ab      	str	r3, [r5, #24]
    chSchGoSleepS(newstate);
 8001988:	4630      	mov	r0, r6
 800198a:	f7ff ff79 	bl	8001880 <chSchGoSleepS>
 */
static inline bool chVTIsArmedI(const virtual_timer_t *vtp) {

  chDbgCheckClassI();

  return (bool)(vtp->dlist.next != NULL);
 800198e:	9b00      	ldr	r3, [sp, #0]
    if (chVTIsArmedI(&vt)) {
 8001990:	b163      	cbz	r3, 80019ac <chSchGoSleepTimeoutS+0xcc>
  systime_t now;
  sysinterval_t nowdelta, delta;

  /* If the timer is not the first of the list then it is simply unlinked
     else the operation is more complex.*/
  if (!ch_dlist_isfirst(&vtlp->dlist, &vtp->dlist)) {
 8001992:	692a      	ldr	r2, [r5, #16]
 8001994:	42a2      	cmp	r2, r4
 8001996:	d015      	beq.n	80019c4 <chSchGoSleepTimeoutS+0xe4>

    /* Removing the element from the delta list.*/
    (void) ch_dlist_dequeue(&vtp->dlist);

    /* Adding delta to the next element, if it is not the last one.*/
    vtp->dlist.next->delta += vtp->dlist.delta;
 8001998:	689a      	ldr	r2, [r3, #8]
 *
 * @notapi
 */
static inline ch_delta_list_t *ch_dlist_dequeue(ch_delta_list_t *dlp) {

  dlp->prev->next = dlp->next;
 800199a:	e9dd 1001 	ldrd	r1, r0, [sp, #4]
 800199e:	4402      	add	r2, r0
 80019a0:	600b      	str	r3, [r1, #0]
 80019a2:	e9c3 1201 	strd	r1, r2, [r3, #4]
    vtp->dlist.next = NULL;

    /* Special case when the removed element from the last position in the list,
       the value in the header must be restored, just doing it is faster than
       checking then doing.*/
    vtlp->dlist.delta = (sysinterval_t)-1;
 80019a6:	f04f 33ff 	mov.w	r3, #4294967295
 80019aa:	61ab      	str	r3, [r5, #24]
}
 80019ac:	f8d8 0028 	ldr.w	r0, [r8, #40]	; 0x28
 80019b0:	b006      	add	sp, #24
 80019b2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    chSchGoSleepS(newstate);
 80019b6:	f7ff ff63 	bl	8001880 <chSchGoSleepS>
}
 80019ba:	f8d8 0028 	ldr.w	r0, [r8, #40]	; 0x28
 80019be:	b006      	add	sp, #24
 80019c0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    return;
  }

  /* Removing the first timer from the list, marking it as not armed.*/
  ch_dlist_remove_first(&vtlp->dlist);
  vtp->dlist.next = NULL;
 80019c4:	2200      	movs	r2, #0

  /* If the list become empty then the alarm timer is stopped and done.*/
  if (ch_dlist_isempty(&vtlp->dlist)) {
 80019c6:	42bb      	cmp	r3, r7
  dlhp->next       = dlp->next;
 80019c8:	612b      	str	r3, [r5, #16]
  vtp->dlist.next = NULL;
 80019ca:	9200      	str	r2, [sp, #0]
  dlhp->next->prev = dlhp;
 80019cc:	605f      	str	r7, [r3, #4]
  if (ch_dlist_isempty(&vtlp->dlist)) {
 80019ce:	d029      	beq.n	8001a24 <chSchGoSleepTimeoutS+0x144>

    return;
  }

  /* The delta of the removed timer is added to the new first timer.*/
  vtlp->dlist.next->delta += vtp->dlist.delta;
 80019d0:	689a      	ldr	r2, [r3, #8]
 80019d2:	f04f 4080 	mov.w	r0, #1073741824	; 0x40000000
 80019d6:	9902      	ldr	r1, [sp, #8]
 80019d8:	440a      	add	r2, r1
 80019da:	609a      	str	r2, [r3, #8]

  /* Distance in ticks between the last alarm event and current time.*/
  now = chVTGetSystemTimeX();
  nowdelta = chTimeDiffX(vtlp->lasttime, now);
 80019dc:	69eb      	ldr	r3, [r5, #28]
 80019de:	6a41      	ldr	r1, [r0, #36]	; 0x24
 80019e0:	1acc      	subs	r4, r1, r3

  /* If the current time surpassed the time of the next element in list
     then the event interrupt is already pending, just return.*/
  if (nowdelta >= vtlp->dlist.next->delta) {
 80019e2:	42a2      	cmp	r2, r4
 80019e4:	d9e2      	bls.n	80019ac <chSchGoSleepTimeoutS+0xcc>
    return;
  }

  /* Distance from the next scheduled event and now.*/
  delta = vtlp->dlist.next->delta - nowdelta;
 80019e6:	1a5b      	subs	r3, r3, r1
 80019e8:	4413      	add	r3, r2
 80019ea:	2b02      	cmp	r3, #2
 80019ec:	bf38      	it	cc
 80019ee:	2302      	movcc	r3, #2
  return systime + (systime_t)interval;
 80019f0:	18ca      	adds	r2, r1, r3
  STM32_ST_TIM->CCR[0] = (uint32_t)abstime;
 80019f2:	6342      	str	r2, [r0, #52]	; 0x34
  return (systime_t)STM32_ST_TIM->CNT;
 80019f4:	6a42      	ldr	r2, [r0, #36]	; 0x24
  return (sysinterval_t)((systime_t)(end - start));
 80019f6:	1a51      	subs	r1, r2, r1
    if (likely(nowdelta < delay)) {
 80019f8:	4299      	cmp	r1, r3
 80019fa:	d3d7      	bcc.n	80019ac <chSchGoSleepTimeoutS+0xcc>
 80019fc:	2302      	movs	r3, #2
    currdelta += (sysinterval_t)1;
 80019fe:	3301      	adds	r3, #1
  return systime + (systime_t)interval;
 8001a00:	18d1      	adds	r1, r2, r3
  STM32_ST_TIM->CCR[0] = (uint32_t)abstime;
 8001a02:	6341      	str	r1, [r0, #52]	; 0x34
  return (systime_t)STM32_ST_TIM->CNT;
 8001a04:	6a41      	ldr	r1, [r0, #36]	; 0x24
  return (sysinterval_t)((systime_t)(end - start));
 8001a06:	1a8a      	subs	r2, r1, r2
    if (likely(nowdelta < delay)) {
 8001a08:	429a      	cmp	r2, r3
 8001a0a:	d211      	bcs.n	8001a30 <chSchGoSleepTimeoutS+0x150>
  if (currdelta > CH_CFG_ST_TIMEDELTA) {
 8001a0c:	2b02      	cmp	r3, #2
 8001a0e:	d9cd      	bls.n	80019ac <chSchGoSleepTimeoutS+0xcc>
  currcore->rfcu.mask |= mask;
 8001a10:	6b6b      	ldr	r3, [r5, #52]	; 0x34
 8001a12:	f043 0301 	orr.w	r3, r3, #1
 8001a16:	636b      	str	r3, [r5, #52]	; 0x34
}
 8001a18:	e7c8      	b.n	80019ac <chSchGoSleepTimeoutS+0xcc>
      vt_insert_first(vtlp, vtp, now, delay);
 8001a1a:	466c      	mov	r4, sp
 8001a1c:	4620      	mov	r0, r4
 8001a1e:	f7ff fc47 	bl	80012b0 <vt_insert_first.constprop.0>
      return;
 8001a22:	e7b1      	b.n	8001988 <chSchGoSleepTimeoutS+0xa8>
  STM32_ST_TIM->DIER = 0U;
 8001a24:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8001a28:	60da      	str	r2, [r3, #12]
 * @api
 */
void stStopAlarm(void) {

  st_lld_stop_alarm();
}
 8001a2a:	e7bf      	b.n	80019ac <chSchGoSleepTimeoutS+0xcc>
  return (systime_t)STM32_ST_TIM->CNT;
 8001a2c:	468e      	mov	lr, r1
 8001a2e:	e787      	b.n	8001940 <chSchGoSleepTimeoutS+0x60>
 8001a30:	460a      	mov	r2, r1
 8001a32:	e7e4      	b.n	80019fe <chSchGoSleepTimeoutS+0x11e>
 8001a34:	24000330 	.word	0x24000330
 8001a38:	08001211 	.word	0x08001211
 8001a3c:	00000000 	.word	0x00000000

08001a40 <oqWriteTimeout>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t oqWriteTimeout(output_queue_t *oqp, const uint8_t *bp,
                      size_t n, sysinterval_t timeout) {
 8001a40:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8001a44:	b083      	sub	sp, #12
 8001a46:	469a      	mov	sl, r3
  qnotify_t nfy = oqp->q_notify;
 8001a48:	69c7      	ldr	r7, [r0, #28]
 8001a4a:	f04f 0930 	mov.w	r9, #48	; 0x30
                      size_t n, sysinterval_t timeout) {
 8001a4e:	9201      	str	r2, [sp, #4]
 8001a50:	f389 8811 	msr	BASEPRI, r9

  osalDbgCheck(n > 0U);

  osalSysLock();

  while (n > 0U) {
 8001a54:	b392      	cbz	r2, 8001abc <oqWriteTimeout+0x7c>
 8001a56:	4604      	mov	r4, r0
 8001a58:	460e      	mov	r6, r1
 8001a5a:	f8dd b004 	ldr.w	fp, [sp, #4]
  if (n > oqGetEmptyI(oqp)) {
 8001a5e:	68a2      	ldr	r2, [r4, #8]
 8001a60:	4593      	cmp	fp, r2
 8001a62:	d932      	bls.n	8001aca <oqWriteTimeout+0x8a>
    n = oqGetEmptyI(oqp);
 8001a64:	68a5      	ldr	r5, [r4, #8]
  s1 = (size_t)(oqp->q_top - oqp->q_wrptr);
 8001a66:	e9d4 2004 	ldrd	r2, r0, [r4, #16]
 8001a6a:	eba2 0800 	sub.w	r8, r2, r0
  if (n < s1) {
 8001a6e:	45a8      	cmp	r8, r5
 8001a70:	d832      	bhi.n	8001ad8 <oqWriteTimeout+0x98>
  else if (n > s1) {
 8001a72:	d238      	bcs.n	8001ae6 <oqWriteTimeout+0xa6>
    s2 = n - s1;
 8001a74:	eba5 0308 	sub.w	r3, r5, r8
    memcpy((void *)oqp->q_wrptr, (const void *)bp, s1);
 8001a78:	4642      	mov	r2, r8
 8001a7a:	4631      	mov	r1, r6
    s2 = n - s1;
 8001a7c:	9300      	str	r3, [sp, #0]
    memcpy((void *)oqp->q_wrptr, (const void *)bp, s1);
 8001a7e:	f7fe fcb5 	bl	80003ec <memcpy>
    memcpy((void *)oqp->q_buffer, (const void *)bp, s2);
 8001a82:	eb06 0108 	add.w	r1, r6, r8
 8001a86:	f8dd 8000 	ldr.w	r8, [sp]
 8001a8a:	68e0      	ldr	r0, [r4, #12]
 8001a8c:	4642      	mov	r2, r8
 8001a8e:	f7fe fcad 	bl	80003ec <memcpy>
    oqp->q_wrptr = oqp->q_buffer + s2;
 8001a92:	68e1      	ldr	r1, [r4, #12]
 8001a94:	4441      	add	r1, r8
  oqp->q_counter -= n;
 8001a96:	68a2      	ldr	r2, [r4, #8]
    oqp->q_wrptr += n;
 8001a98:	6161      	str	r1, [r4, #20]
  oqp->q_counter -= n;
 8001a9a:	1b52      	subs	r2, r2, r5
 8001a9c:	60a2      	str	r2, [r4, #8]
    size_t done;

    done = oq_write(oqp, bp, n);
    if (done == (size_t)0) {
 8001a9e:	b345      	cbz	r5, 8001af2 <oqWriteTimeout+0xb2>
      }
    }
    else {
      /* Inform the low side that the queue has at least one character
         available.*/
      if (nfy != NULL) {
 8001aa0:	b10f      	cbz	r7, 8001aa6 <oqWriteTimeout+0x66>
        nfy(oqp);
 8001aa2:	4620      	mov	r0, r4
 8001aa4:	47b8      	blx	r7
 8001aa6:	2300      	movs	r3, #0
 8001aa8:	f383 8811 	msr	BASEPRI, r3
      }

      /* Giving a preemption chance in a controlled point.*/
      osalSysUnlock();

      n  -= done;
 8001aac:	ebab 0b05 	sub.w	fp, fp, r5
      bp += done;
 8001ab0:	442e      	add	r6, r5
 8001ab2:	f389 8811 	msr	BASEPRI, r9
  while (n > 0U) {
 8001ab6:	f1bb 0f00 	cmp.w	fp, #0
 8001aba:	d1d0      	bne.n	8001a5e <oqWriteTimeout+0x1e>
 8001abc:	9801      	ldr	r0, [sp, #4]
 8001abe:	2300      	movs	r3, #0
 8001ac0:	f383 8811 	msr	BASEPRI, r3
    }
  }

  osalSysUnlock();
  return max - n;
}
 8001ac4:	b003      	add	sp, #12
 8001ac6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  s1 = (size_t)(oqp->q_top - oqp->q_wrptr);
 8001aca:	e9d4 2004 	ldrd	r2, r0, [r4, #16]
 8001ace:	465d      	mov	r5, fp
 8001ad0:	eba2 0800 	sub.w	r8, r2, r0
  if (n < s1) {
 8001ad4:	45a8      	cmp	r8, r5
 8001ad6:	d9cc      	bls.n	8001a72 <oqWriteTimeout+0x32>
    memcpy((void *)oqp->q_wrptr, (const void *)bp, n);
 8001ad8:	4631      	mov	r1, r6
 8001ada:	462a      	mov	r2, r5
 8001adc:	f7fe fc86 	bl	80003ec <memcpy>
    oqp->q_wrptr += n;
 8001ae0:	6961      	ldr	r1, [r4, #20]
 8001ae2:	4429      	add	r1, r5
 8001ae4:	e7d7      	b.n	8001a96 <oqWriteTimeout+0x56>
    memcpy((void *)oqp->q_wrptr, (const void *)bp, n);
 8001ae6:	4631      	mov	r1, r6
 8001ae8:	462a      	mov	r2, r5
 8001aea:	f7fe fc7f 	bl	80003ec <memcpy>
    oqp->q_wrptr = oqp->q_buffer;
 8001aee:	68e1      	ldr	r1, [r4, #12]
 8001af0:	e7d1      	b.n	8001a96 <oqWriteTimeout+0x56>
  return __sch_get_currthread();
 8001af2:	4b0c      	ldr	r3, [pc, #48]	; (8001b24 <oqWriteTimeout+0xe4>)
 8001af4:	68da      	ldr	r2, [r3, #12]
  if (unlikely(TIME_IMMEDIATE == timeout)) {
 8001af6:	f1ba 0f00 	cmp.w	sl, #0
 8001afa:	d00a      	beq.n	8001b12 <oqWriteTimeout+0xd2>
  p->prev       = qp->prev;
 8001afc:	6861      	ldr	r1, [r4, #4]
  return chSchGoSleepTimeoutS(CH_STATE_QUEUED, timeout);
 8001afe:	2004      	movs	r0, #4
 8001b00:	e9c2 4100 	strd	r4, r1, [r2]
  p->prev->next = p;
 8001b04:	600a      	str	r2, [r1, #0]
 8001b06:	4651      	mov	r1, sl
  qp->prev      = p;
 8001b08:	6062      	str	r2, [r4, #4]
 8001b0a:	f7ff fee9 	bl	80018e0 <chSchGoSleepTimeoutS>
      if (msg != MSG_OK) {
 8001b0e:	2800      	cmp	r0, #0
 8001b10:	d0a5      	beq.n	8001a5e <oqWriteTimeout+0x1e>
  return max - n;
 8001b12:	9b01      	ldr	r3, [sp, #4]
 8001b14:	eba3 000b 	sub.w	r0, r3, fp
 8001b18:	2300      	movs	r3, #0
 8001b1a:	f383 8811 	msr	BASEPRI, r3
}
 8001b1e:	b003      	add	sp, #12
 8001b20:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8001b24:	24000330 	.word	0x24000330
	...

08001b30 <_write>:
  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp,
 8001b30:	f04f 33ff 	mov.w	r3, #4294967295
 8001b34:	3030      	adds	r0, #48	; 0x30
 8001b36:	f7ff bf83 	b.w	8001a40 <oqWriteTimeout>
 8001b3a:	bf00      	nop
 8001b3c:	0000      	movs	r0, r0
	...

08001b40 <_writet>:
  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp, n, timeout);
 8001b40:	3030      	adds	r0, #48	; 0x30
 8001b42:	f7ff bf7d 	b.w	8001a40 <oqWriteTimeout>
 8001b46:	bf00      	nop
	...

08001b50 <iqGetTimeout>:
msg_t iqGetTimeout(input_queue_t *iqp, sysinterval_t timeout) {
 8001b50:	b570      	push	{r4, r5, r6, lr}
 8001b52:	2330      	movs	r3, #48	; 0x30
 8001b54:	4604      	mov	r4, r0
 8001b56:	460d      	mov	r5, r1
 8001b58:	f383 8811 	msr	BASEPRI, r3
 8001b5c:	4e16      	ldr	r6, [pc, #88]	; (8001bb8 <iqGetTimeout+0x68>)
}
 8001b5e:	e008      	b.n	8001b72 <iqGetTimeout+0x22>
  p->prev       = qp->prev;
 8001b60:	6862      	ldr	r2, [r4, #4]
 8001b62:	e9c3 4200 	strd	r4, r2, [r3]
  p->prev->next = p;
 8001b66:	6013      	str	r3, [r2, #0]
  qp->prev      = p;
 8001b68:	6063      	str	r3, [r4, #4]
 8001b6a:	f7ff feb9 	bl	80018e0 <chSchGoSleepTimeoutS>
    if (msg < MSG_OK) {
 8001b6e:	2800      	cmp	r0, #0
 8001b70:	db08      	blt.n	8001b84 <iqGetTimeout+0x34>
  while (iqIsEmptyI(iqp)) {
 8001b72:	68a3      	ldr	r3, [r4, #8]
 8001b74:	4629      	mov	r1, r5
 8001b76:	2004      	movs	r0, #4
 8001b78:	b943      	cbnz	r3, 8001b8c <iqGetTimeout+0x3c>
 8001b7a:	68f3      	ldr	r3, [r6, #12]
  if (unlikely(TIME_IMMEDIATE == timeout)) {
 8001b7c:	2d00      	cmp	r5, #0
 8001b7e:	d1ef      	bne.n	8001b60 <iqGetTimeout+0x10>
    return MSG_TIMEOUT;
 8001b80:	f04f 30ff 	mov.w	r0, #4294967295
 8001b84:	2300      	movs	r3, #0
 8001b86:	f383 8811 	msr	BASEPRI, r3
}
 8001b8a:	bd70      	pop	{r4, r5, r6, pc}
  iqp->q_counter--;
 8001b8c:	68a3      	ldr	r3, [r4, #8]
  b = *iqp->q_rdptr++;
 8001b8e:	69a1      	ldr	r1, [r4, #24]
  iqp->q_counter--;
 8001b90:	3b01      	subs	r3, #1
  b = *iqp->q_rdptr++;
 8001b92:	1c4a      	adds	r2, r1, #1
  iqp->q_counter--;
 8001b94:	60a3      	str	r3, [r4, #8]
  if (iqp->q_rdptr >= iqp->q_top) {
 8001b96:	6923      	ldr	r3, [r4, #16]
  b = *iqp->q_rdptr++;
 8001b98:	61a2      	str	r2, [r4, #24]
  if (iqp->q_rdptr >= iqp->q_top) {
 8001b9a:	429a      	cmp	r2, r3
  b = *iqp->q_rdptr++;
 8001b9c:	780d      	ldrb	r5, [r1, #0]
  if (iqp->q_rdptr >= iqp->q_top) {
 8001b9e:	d301      	bcc.n	8001ba4 <iqGetTimeout+0x54>
    iqp->q_rdptr = iqp->q_buffer;
 8001ba0:	68e3      	ldr	r3, [r4, #12]
 8001ba2:	61a3      	str	r3, [r4, #24]
  if (iqp->q_notify != NULL) {
 8001ba4:	69e3      	ldr	r3, [r4, #28]
 8001ba6:	b10b      	cbz	r3, 8001bac <iqGetTimeout+0x5c>
    iqp->q_notify(iqp);
 8001ba8:	4620      	mov	r0, r4
 8001baa:	4798      	blx	r3
 8001bac:	2300      	movs	r3, #0
 8001bae:	f383 8811 	msr	BASEPRI, r3
  return (msg_t)b;
 8001bb2:	4628      	mov	r0, r5
}
 8001bb4:	bd70      	pop	{r4, r5, r6, pc}
 8001bb6:	bf00      	nop
 8001bb8:	24000330 	.word	0x24000330
 8001bbc:	00000000 	.word	0x00000000

08001bc0 <_get>:
  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, TIME_INFINITE);
 8001bc0:	f04f 31ff 	mov.w	r1, #4294967295
 8001bc4:	300c      	adds	r0, #12
 8001bc6:	f7ff bfc3 	b.w	8001b50 <iqGetTimeout>
 8001bca:	bf00      	nop
 8001bcc:	0000      	movs	r0, r0
	...

08001bd0 <_gett>:
  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, timeout);
 8001bd0:	300c      	adds	r0, #12
 8001bd2:	f7ff bfbd 	b.w	8001b50 <iqGetTimeout>
 8001bd6:	bf00      	nop
	...

08001be0 <iqReadTimeout>:
                     size_t n, sysinterval_t timeout) {
 8001be0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8001be4:	b083      	sub	sp, #12
 8001be6:	469a      	mov	sl, r3
  qnotify_t nfy = iqp->q_notify;
 8001be8:	69c7      	ldr	r7, [r0, #28]
 8001bea:	f04f 0930 	mov.w	r9, #48	; 0x30
                     size_t n, sysinterval_t timeout) {
 8001bee:	9201      	str	r2, [sp, #4]
 8001bf0:	f389 8811 	msr	BASEPRI, r9
  while (n > 0U) {
 8001bf4:	b392      	cbz	r2, 8001c5c <iqReadTimeout+0x7c>
 8001bf6:	4604      	mov	r4, r0
 8001bf8:	460e      	mov	r6, r1
 8001bfa:	f8dd b004 	ldr.w	fp, [sp, #4]
  if (n > iqGetFullI(iqp)) {
 8001bfe:	68a2      	ldr	r2, [r4, #8]
 8001c00:	4593      	cmp	fp, r2
 8001c02:	d932      	bls.n	8001c6a <iqReadTimeout+0x8a>
  s1 = (size_t)(iqp->q_top - iqp->q_rdptr);
 8001c04:	69a1      	ldr	r1, [r4, #24]
 8001c06:	6922      	ldr	r2, [r4, #16]
    n = iqGetFullI(iqp);
 8001c08:	68a5      	ldr	r5, [r4, #8]
  s1 = (size_t)(iqp->q_top - iqp->q_rdptr);
 8001c0a:	eba2 0801 	sub.w	r8, r2, r1
  if (n < s1) {
 8001c0e:	45a8      	cmp	r8, r5
 8001c10:	d832      	bhi.n	8001c78 <iqReadTimeout+0x98>
  else if (n > s1) {
 8001c12:	d238      	bcs.n	8001c86 <iqReadTimeout+0xa6>
    s2 = n - s1;
 8001c14:	eba5 0308 	sub.w	r3, r5, r8
    memcpy((void *)bp, (void *)iqp->q_rdptr, s1);
 8001c18:	4642      	mov	r2, r8
 8001c1a:	4630      	mov	r0, r6
    s2 = n - s1;
 8001c1c:	9300      	str	r3, [sp, #0]
    memcpy((void *)bp, (void *)iqp->q_rdptr, s1);
 8001c1e:	f7fe fbe5 	bl	80003ec <memcpy>
    memcpy((void *)bp, (void *)iqp->q_buffer, s2);
 8001c22:	eb06 0008 	add.w	r0, r6, r8
 8001c26:	f8dd 8000 	ldr.w	r8, [sp]
 8001c2a:	68e1      	ldr	r1, [r4, #12]
 8001c2c:	4642      	mov	r2, r8
 8001c2e:	f7fe fbdd 	bl	80003ec <memcpy>
    iqp->q_rdptr = iqp->q_buffer + s2;
 8001c32:	68e1      	ldr	r1, [r4, #12]
 8001c34:	4441      	add	r1, r8
  iqp->q_counter -= n;
 8001c36:	68a2      	ldr	r2, [r4, #8]
    iqp->q_rdptr += n;
 8001c38:	61a1      	str	r1, [r4, #24]
  iqp->q_counter -= n;
 8001c3a:	1b52      	subs	r2, r2, r5
 8001c3c:	60a2      	str	r2, [r4, #8]
    if (done == (size_t)0) {
 8001c3e:	b345      	cbz	r5, 8001c92 <iqReadTimeout+0xb2>
      if (nfy != NULL) {
 8001c40:	b10f      	cbz	r7, 8001c46 <iqReadTimeout+0x66>
        nfy(iqp);
 8001c42:	4620      	mov	r0, r4
 8001c44:	47b8      	blx	r7
 8001c46:	2300      	movs	r3, #0
 8001c48:	f383 8811 	msr	BASEPRI, r3
      n  -= done;
 8001c4c:	ebab 0b05 	sub.w	fp, fp, r5
      bp += done;
 8001c50:	442e      	add	r6, r5
 8001c52:	f389 8811 	msr	BASEPRI, r9
  while (n > 0U) {
 8001c56:	f1bb 0f00 	cmp.w	fp, #0
 8001c5a:	d1d0      	bne.n	8001bfe <iqReadTimeout+0x1e>
 8001c5c:	9801      	ldr	r0, [sp, #4]
 8001c5e:	2300      	movs	r3, #0
 8001c60:	f383 8811 	msr	BASEPRI, r3
}
 8001c64:	b003      	add	sp, #12
 8001c66:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  s1 = (size_t)(iqp->q_top - iqp->q_rdptr);
 8001c6a:	69a1      	ldr	r1, [r4, #24]
 8001c6c:	465d      	mov	r5, fp
 8001c6e:	6922      	ldr	r2, [r4, #16]
 8001c70:	eba2 0801 	sub.w	r8, r2, r1
  if (n < s1) {
 8001c74:	45a8      	cmp	r8, r5
 8001c76:	d9cc      	bls.n	8001c12 <iqReadTimeout+0x32>
    memcpy((void *)bp, (void *)iqp->q_rdptr, n);
 8001c78:	462a      	mov	r2, r5
 8001c7a:	4630      	mov	r0, r6
 8001c7c:	f7fe fbb6 	bl	80003ec <memcpy>
    iqp->q_rdptr += n;
 8001c80:	69a1      	ldr	r1, [r4, #24]
 8001c82:	4429      	add	r1, r5
 8001c84:	e7d7      	b.n	8001c36 <iqReadTimeout+0x56>
    memcpy((void *)bp, (void *)iqp->q_rdptr, n);
 8001c86:	462a      	mov	r2, r5
 8001c88:	4630      	mov	r0, r6
 8001c8a:	f7fe fbaf 	bl	80003ec <memcpy>
    iqp->q_rdptr = iqp->q_buffer;
 8001c8e:	68e1      	ldr	r1, [r4, #12]
 8001c90:	e7d1      	b.n	8001c36 <iqReadTimeout+0x56>
 8001c92:	4b0c      	ldr	r3, [pc, #48]	; (8001cc4 <iqReadTimeout+0xe4>)
 8001c94:	68da      	ldr	r2, [r3, #12]
  if (unlikely(TIME_IMMEDIATE == timeout)) {
 8001c96:	f1ba 0f00 	cmp.w	sl, #0
 8001c9a:	d00a      	beq.n	8001cb2 <iqReadTimeout+0xd2>
  p->prev       = qp->prev;
 8001c9c:	6861      	ldr	r1, [r4, #4]
  return chSchGoSleepTimeoutS(CH_STATE_QUEUED, timeout);
 8001c9e:	2004      	movs	r0, #4
 8001ca0:	e9c2 4100 	strd	r4, r1, [r2]
  p->prev->next = p;
 8001ca4:	600a      	str	r2, [r1, #0]
 8001ca6:	4651      	mov	r1, sl
  qp->prev      = p;
 8001ca8:	6062      	str	r2, [r4, #4]
 8001caa:	f7ff fe19 	bl	80018e0 <chSchGoSleepTimeoutS>
      if (msg != MSG_OK) {
 8001cae:	2800      	cmp	r0, #0
 8001cb0:	d0a5      	beq.n	8001bfe <iqReadTimeout+0x1e>
  return max - n;
 8001cb2:	9b01      	ldr	r3, [sp, #4]
 8001cb4:	eba3 000b 	sub.w	r0, r3, fp
 8001cb8:	2300      	movs	r3, #0
 8001cba:	f383 8811 	msr	BASEPRI, r3
}
 8001cbe:	b003      	add	sp, #12
 8001cc0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8001cc4:	24000330 	.word	0x24000330
	...

08001cd0 <_read>:
  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp,
 8001cd0:	f04f 33ff 	mov.w	r3, #4294967295
 8001cd4:	300c      	adds	r0, #12
 8001cd6:	f7ff bf83 	b.w	8001be0 <iqReadTimeout>
 8001cda:	bf00      	nop
 8001cdc:	0000      	movs	r0, r0
	...

08001ce0 <_readt>:
  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp, n, timeout);
 8001ce0:	300c      	adds	r0, #12
 8001ce2:	f7ff bf7d 	b.w	8001be0 <iqReadTimeout>
 8001ce6:	bf00      	nop
	...

08001cf0 <oqPutTimeout>:
msg_t oqPutTimeout(output_queue_t *oqp, uint8_t b, sysinterval_t timeout) {
 8001cf0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8001cf4:	2330      	movs	r3, #48	; 0x30
 8001cf6:	4604      	mov	r4, r0
 8001cf8:	460f      	mov	r7, r1
 8001cfa:	4616      	mov	r6, r2
 8001cfc:	f383 8811 	msr	BASEPRI, r3
 8001d00:	f8df 8060 	ldr.w	r8, [pc, #96]	; 8001d64 <oqPutTimeout+0x74>
 8001d04:	e008      	b.n	8001d18 <oqPutTimeout+0x28>
  p->prev       = qp->prev;
 8001d06:	6865      	ldr	r5, [r4, #4]
 8001d08:	e9c3 4500 	strd	r4, r5, [r3]
  p->prev->next = p;
 8001d0c:	602b      	str	r3, [r5, #0]
  qp->prev      = p;
 8001d0e:	6063      	str	r3, [r4, #4]
 8001d10:	f7ff fde6 	bl	80018e0 <chSchGoSleepTimeoutS>
    if (msg < MSG_OK) {
 8001d14:	2800      	cmp	r0, #0
 8001d16:	db09      	blt.n	8001d2c <oqPutTimeout+0x3c>
  while (oqIsFullI(oqp)) {
 8001d18:	68a3      	ldr	r3, [r4, #8]
 8001d1a:	4631      	mov	r1, r6
 8001d1c:	2004      	movs	r0, #4
 8001d1e:	b953      	cbnz	r3, 8001d36 <oqPutTimeout+0x46>
 8001d20:	f8d8 300c 	ldr.w	r3, [r8, #12]
  if (unlikely(TIME_IMMEDIATE == timeout)) {
 8001d24:	2e00      	cmp	r6, #0
 8001d26:	d1ee      	bne.n	8001d06 <oqPutTimeout+0x16>
    return MSG_TIMEOUT;
 8001d28:	f04f 30ff 	mov.w	r0, #4294967295
 8001d2c:	2300      	movs	r3, #0
 8001d2e:	f383 8811 	msr	BASEPRI, r3
}
 8001d32:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  *oqp->q_wrptr++ = b;
 8001d36:	6962      	ldr	r2, [r4, #20]
  oqp->q_counter--;
 8001d38:	68a3      	ldr	r3, [r4, #8]
  *oqp->q_wrptr++ = b;
 8001d3a:	1c51      	adds	r1, r2, #1
  oqp->q_counter--;
 8001d3c:	3b01      	subs	r3, #1
  *oqp->q_wrptr++ = b;
 8001d3e:	6161      	str	r1, [r4, #20]
  oqp->q_counter--;
 8001d40:	60a3      	str	r3, [r4, #8]
  *oqp->q_wrptr++ = b;
 8001d42:	7017      	strb	r7, [r2, #0]
  if (oqp->q_wrptr >= oqp->q_top) {
 8001d44:	e9d4 3204 	ldrd	r3, r2, [r4, #16]
 8001d48:	429a      	cmp	r2, r3
 8001d4a:	d301      	bcc.n	8001d50 <oqPutTimeout+0x60>
    oqp->q_wrptr = oqp->q_buffer;
 8001d4c:	68e3      	ldr	r3, [r4, #12]
 8001d4e:	6163      	str	r3, [r4, #20]
  if (oqp->q_notify != NULL) {
 8001d50:	69e3      	ldr	r3, [r4, #28]
 8001d52:	b10b      	cbz	r3, 8001d58 <oqPutTimeout+0x68>
    oqp->q_notify(oqp);
 8001d54:	4620      	mov	r0, r4
 8001d56:	4798      	blx	r3
 8001d58:	2000      	movs	r0, #0
 8001d5a:	f380 8811 	msr	BASEPRI, r0
}
 8001d5e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8001d62:	bf00      	nop
 8001d64:	24000330 	.word	0x24000330
	...

08001d70 <_put>:
  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, TIME_INFINITE);
 8001d70:	f04f 32ff 	mov.w	r2, #4294967295
 8001d74:	3030      	adds	r0, #48	; 0x30
 8001d76:	f7ff bfbb 	b.w	8001cf0 <oqPutTimeout>
 8001d7a:	bf00      	nop
 8001d7c:	0000      	movs	r0, r0
	...

08001d80 <_putt>:
  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, timeout);
 8001d80:	3030      	adds	r0, #48	; 0x30
 8001d82:	f7ff bfb5 	b.w	8001cf0 <oqPutTimeout>
 8001d86:	bf00      	nop
	...

08001d90 <_sdc_wait_for_transfer_state>:
bool _sdc_wait_for_transfer_state(SDCDriver *sdcp) {
 8001d90:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  sdcp->sdmmc->CMD = (uint32_t)cmd | SDMMC_CMD_WAITRESP_0 | SDMMC_CMD_CPSMEN;
 8001d94:	f241 150d 	movw	r5, #4365	; 0x110d
        MMCSD_R1_ERROR(resp[0])) {
 8001d98:	4c17      	ldr	r4, [pc, #92]	; (8001df8 <_sdc_wait_for_transfer_state+0x68>)
 8001d9a:	2630      	movs	r6, #48	; 0x30
bool _sdc_wait_for_transfer_state(SDCDriver *sdcp) {
 8001d9c:	4607      	mov	r7, r0
    if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_SEND_STATUS,
 8001d9e:	6bba      	ldr	r2, [r7, #56]	; 0x38
  sdcp->sdmmc->ARG = arg;
 8001da0:	6c7b      	ldr	r3, [r7, #68]	; 0x44
 8001da2:	609a      	str	r2, [r3, #8]
  sdcp->sdmmc->CMD = (uint32_t)cmd | SDMMC_CMD_WAITRESP_0 | SDMMC_CMD_CPSMEN;
 8001da4:	60dd      	str	r5, [r3, #12]
  while (((sta = sdcp->sdmmc->STA) & (SDMMC_STA_CMDREND | SDMMC_STA_CTIMEOUT |
 8001da6:	6b59      	ldr	r1, [r3, #52]	; 0x34
                                     SDMMC_STA_CCRCFAIL)) == 0)
 8001da8:	f011 0245 	ands.w	r2, r1, #69	; 0x45
 8001dac:	d0fb      	beq.n	8001da6 <_sdc_wait_for_transfer_state+0x16>
  if ((sta & (SDMMC_STA_CTIMEOUT | SDMMC_STA_CCRCFAIL)) != 0) {
 8001dae:	f011 0f05 	tst.w	r1, #5
  sdcp->sdmmc->ICR = sta & (SDMMC_STA_CMDREND | SDMMC_STA_CTIMEOUT |
 8001db2:	639a      	str	r2, [r3, #56]	; 0x38
  if ((sta & (SDMMC_STA_CTIMEOUT | SDMMC_STA_CCRCFAIL)) != 0) {
 8001db4:	d119      	bne.n	8001dea <_sdc_wait_for_transfer_state+0x5a>
  *resp = sdcp->sdmmc->RESP1;
 8001db6:	695b      	ldr	r3, [r3, #20]
                                   sdcp->rca, resp) ||
 8001db8:	ea13 0804 	ands.w	r8, r3, r4
 8001dbc:	d112      	bne.n	8001de4 <_sdc_wait_for_transfer_state+0x54>
    switch (MMCSD_R1_STS(resp[0])) {
 8001dbe:	f3c3 2343 	ubfx	r3, r3, #9, #4
 8001dc2:	2b04      	cmp	r3, #4
 8001dc4:	d00b      	beq.n	8001dde <_sdc_wait_for_transfer_state+0x4e>
 8001dc6:	3b05      	subs	r3, #5
 8001dc8:	2b02      	cmp	r3, #2
 8001dca:	d80b      	bhi.n	8001de4 <_sdc_wait_for_transfer_state+0x54>
 8001dcc:	f386 8811 	msr	BASEPRI, r6
  (void) chSchGoSleepTimeoutS(CH_STATE_SLEEPING, ticks);
 8001dd0:	210a      	movs	r1, #10
 8001dd2:	2008      	movs	r0, #8
 8001dd4:	f7ff fd84 	bl	80018e0 <chSchGoSleepTimeoutS>
 8001dd8:	f388 8811 	msr	BASEPRI, r8
    if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_SEND_STATUS,
 8001ddc:	e7df      	b.n	8001d9e <_sdc_wait_for_transfer_state+0xe>
      return HAL_SUCCESS;
 8001dde:	4640      	mov	r0, r8
}
 8001de0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    switch (MMCSD_R1_STS(resp[0])) {
 8001de4:	2001      	movs	r0, #1
}
 8001de6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    sdc_lld_collect_errors(sdcp, sta);
 8001dea:	4638      	mov	r0, r7
 8001dec:	f7fe fde8 	bl	80009c0 <sdc_lld_collect_errors>
      return HAL_FAILED;
 8001df0:	2001      	movs	r0, #1
}
 8001df2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8001df6:	bf00      	nop
 8001df8:	fdffe008 	.word	0xfdffe008
 8001dfc:	00000000 	.word	0x00000000

08001e00 <sdcDisconnect>:
bool sdcDisconnect(SDCDriver *sdcp) {
 8001e00:	b538      	push	{r3, r4, r5, lr}
 8001e02:	2330      	movs	r3, #48	; 0x30
 8001e04:	f383 8811 	msr	BASEPRI, r3
  if (sdcp->state == BLK_ACTIVE) {
 8001e08:	7903      	ldrb	r3, [r0, #4]
 8001e0a:	2b02      	cmp	r3, #2
 8001e0c:	d012      	beq.n	8001e34 <sdcDisconnect+0x34>
  sdcp->state = BLK_DISCONNECTING;
 8001e0e:	2304      	movs	r3, #4
 8001e10:	4604      	mov	r4, r0
 8001e12:	2500      	movs	r5, #0
 8001e14:	7103      	strb	r3, [r0, #4]
 8001e16:	f385 8811 	msr	BASEPRI, r5
  if (_sdc_wait_for_transfer_state(sdcp)) {
 8001e1a:	f7ff ffb9 	bl	8001d90 <_sdc_wait_for_transfer_state>
 8001e1e:	6c63      	ldr	r3, [r4, #68]	; 0x44
    sdcp->state = BLK_ACTIVE;
 8001e20:	2202      	movs	r2, #2
  if (_sdc_wait_for_transfer_state(sdcp)) {
 8001e22:	b918      	cbnz	r0, 8001e2c <sdcDisconnect+0x2c>
  sdcp->sdmmc->CLKCR = 0;
 8001e24:	6058      	str	r0, [r3, #4]
  sdcp->sdmmc->POWER = 0;
 8001e26:	6018      	str	r0, [r3, #0]
  sdcp->state = BLK_ACTIVE;
 8001e28:	7122      	strb	r2, [r4, #4]
}
 8001e2a:	bd38      	pop	{r3, r4, r5, pc}
  sdcp->sdmmc->CLKCR = 0;
 8001e2c:	605d      	str	r5, [r3, #4]
  sdcp->sdmmc->POWER = 0;
 8001e2e:	601d      	str	r5, [r3, #0]
    sdcp->state = BLK_ACTIVE;
 8001e30:	7122      	strb	r2, [r4, #4]
}
 8001e32:	bd38      	pop	{r3, r4, r5, pc}
 8001e34:	2000      	movs	r0, #0
 8001e36:	f380 8811 	msr	BASEPRI, r0
 8001e3a:	bd38      	pop	{r3, r4, r5, pc}
 8001e3c:	0000      	movs	r0, r0
	...

08001e40 <sdc_lld_wait_transaction_end.constprop.0>:
 8001e40:	2330      	movs	r3, #48	; 0x30
static bool sdc_lld_wait_transaction_end(SDCDriver *sdcp, uint32_t n,
 8001e42:	b510      	push	{r4, lr}
 8001e44:	f383 8811 	msr	BASEPRI, r3
  if (sdcp->sdmmc->MASK != 0)
 8001e48:	6c43      	ldr	r3, [r0, #68]	; 0x44
 8001e4a:	6bda      	ldr	r2, [r3, #60]	; 0x3c
 8001e4c:	b98a      	cbnz	r2, 8001e72 <sdc_lld_wait_transaction_end.constprop.0+0x32>
  sdcp->sdmmc->IDMACTRL = 0;
 8001e4e:	2000      	movs	r0, #0
 8001e50:	6518      	str	r0, [r3, #80]	; 0x50
  sdcp->sdmmc->MASK     = 0;
 8001e52:	63d8      	str	r0, [r3, #60]	; 0x3c
  sdcp->sdmmc->DCTRL    = 0;
 8001e54:	62d8      	str	r0, [r3, #44]	; 0x2c
  if ((sdcp->sdmmc->STA & SDMMC_STA_DATAEND) == 0) {
 8001e56:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8001e58:	f412 7280 	ands.w	r2, r2, #256	; 0x100
 8001e5c:	d005      	beq.n	8001e6a <sdc_lld_wait_transaction_end.constprop.0+0x2a>
  sdcp->sdmmc->ICR      = SDMMC_ICR_ALL_FLAGS;
 8001e5e:	f04f 32ff 	mov.w	r2, #4294967295
 8001e62:	639a      	str	r2, [r3, #56]	; 0x38
 8001e64:	f380 8811 	msr	BASEPRI, r0
}
 8001e68:	bd10      	pop	{r4, pc}
 8001e6a:	f382 8811 	msr	BASEPRI, r2
    return HAL_FAILED;
 8001e6e:	2001      	movs	r0, #1
}
 8001e70:	bd10      	pop	{r4, pc}
  return __sch_get_currthread();
 8001e72:	4a06      	ldr	r2, [pc, #24]	; (8001e8c <sdc_lld_wait_transaction_end.constprop.0+0x4c>)
  *trp = tp;
 8001e74:	4603      	mov	r3, r0
 8001e76:	4604      	mov	r4, r0
    chSchGoSleepS(newstate);
 8001e78:	2003      	movs	r0, #3
 8001e7a:	68d2      	ldr	r2, [r2, #12]
 8001e7c:	f843 2f40 	str.w	r2, [r3, #64]!
  tp->u.wttrp = trp;
 8001e80:	6293      	str	r3, [r2, #40]	; 0x28
 8001e82:	f7ff fcfd 	bl	8001880 <chSchGoSleepS>
  sdcp->sdmmc->IDMACTRL = 0;
 8001e86:	6c63      	ldr	r3, [r4, #68]	; 0x44
 8001e88:	e7e1      	b.n	8001e4e <sdc_lld_wait_transaction_end.constprop.0+0xe>
 8001e8a:	bf00      	nop
 8001e8c:	24000330 	.word	0x24000330

08001e90 <sdcRead>:
bool sdcRead(SDCDriver *sdcp, uint32_t startblk, uint8_t *buf, uint32_t n) {
 8001e90:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8001e94:	4616      	mov	r6, r2
  if ((startblk + n - 1U) > sdcp->capacity) {
 8001e96:	1e5a      	subs	r2, r3, #1
bool sdcRead(SDCDriver *sdcp, uint32_t startblk, uint8_t *buf, uint32_t n) {
 8001e98:	460d      	mov	r5, r1
 8001e9a:	b083      	sub	sp, #12
  if ((startblk + n - 1U) > sdcp->capacity) {
 8001e9c:	440a      	add	r2, r1
 8001e9e:	6a81      	ldr	r1, [r0, #40]	; 0x28
bool sdcRead(SDCDriver *sdcp, uint32_t startblk, uint8_t *buf, uint32_t n) {
 8001ea0:	4604      	mov	r4, r0
  if ((startblk + n - 1U) > sdcp->capacity) {
 8001ea2:	428a      	cmp	r2, r1
 8001ea4:	d907      	bls.n	8001eb6 <sdcRead+0x26>
    sdcp->errors |= SDC_OVERFLOW_ERROR;
 8001ea6:	6b43      	ldr	r3, [r0, #52]	; 0x34
    return HAL_FAILED;
 8001ea8:	2001      	movs	r0, #1
    sdcp->errors |= SDC_OVERFLOW_ERROR;
 8001eaa:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8001eae:	6363      	str	r3, [r4, #52]	; 0x34
}
 8001eb0:	b003      	add	sp, #12
 8001eb2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  sdcp->state = BLK_READING;
 8001eb6:	2206      	movs	r2, #6
 8001eb8:	7102      	strb	r2, [r0, #4]
  for (i = 0; i < blocks; i++) {
 8001eba:	2b00      	cmp	r3, #0
 8001ebc:	d049      	beq.n	8001f52 <sdcRead+0xc2>
 8001ebe:	18ef      	adds	r7, r5, r3
  sdcp->sdmmc->DTIMER = STM32_SDC_SDMMC_READ_TIMEOUT;
 8001ec0:	f8df 80b4 	ldr.w	r8, [pc, #180]	; 8001f78 <sdcRead+0xe8>
  sdcp->sdmmc->ICR   = SDMMC_ICR_ALL_FLAGS;
 8001ec4:	f04f 39ff 	mov.w	r9, #4294967295
                                   startblk, resp) || MMCSD_R1_ERROR(resp[0]))
 8001ec8:	f8df a0b0 	ldr.w	sl, [pc, #176]	; 8001f7c <sdcRead+0xec>
  sdcp->sdmmc->DTIMER = STM32_SDC_SDMMC_READ_TIMEOUT;
 8001ecc:	6c63      	ldr	r3, [r4, #68]	; 0x44
  if (_sdc_wait_for_transfer_state(sdcp))
 8001ece:	4620      	mov	r0, r4
    if (sdc_lld_read_aligned(sdcp, startblk, sdcp->buf, 1))
 8001ed0:	f8d4 b03c 	ldr.w	fp, [r4, #60]	; 0x3c
  sdcp->sdmmc->DTIMER = STM32_SDC_SDMMC_READ_TIMEOUT;
 8001ed4:	f8c3 8024 	str.w	r8, [r3, #36]	; 0x24
  if (_sdc_wait_for_transfer_state(sdcp))
 8001ed8:	f7ff ff5a 	bl	8001d90 <_sdc_wait_for_transfer_state>
 8001edc:	b120      	cbz	r0, 8001ee8 <sdcRead+0x58>
  sdcp->state = BLK_READY;
 8001ede:	2305      	movs	r3, #5
 8001ee0:	7123      	strb	r3, [r4, #4]
}
 8001ee2:	b003      	add	sp, #12
 8001ee4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  sdcp->sdmmc->ICR   = SDMMC_ICR_ALL_FLAGS;
 8001ee8:	6c62      	ldr	r2, [r4, #68]	; 0x44
  sdcp->sdmmc->MASK  = SDMMC_MASK_DCRCFAILIE |
 8001eea:	f44f 7395 	mov.w	r3, #298	; 0x12a
  if (sdc_lld_prepare_read(sdcp, startblk, blocks, sdcp->resp) == true)
 8001eee:	6ce1      	ldr	r1, [r4, #76]	; 0x4c
  sdcp->sdmmc->ICR   = SDMMC_ICR_ALL_FLAGS;
 8001ef0:	f8c2 9038 	str.w	r9, [r2, #56]	; 0x38
  sdcp->sdmmc->MASK  = SDMMC_MASK_DCRCFAILIE |
 8001ef4:	63d3      	str	r3, [r2, #60]	; 0x3c
  sdcp->sdmmc->DLEN  = blocks * MMCSD_BLOCK_SIZE;
 8001ef6:	f44f 7300 	mov.w	r3, #512	; 0x200
 8001efa:	6293      	str	r3, [r2, #40]	; 0x28
  sdcp->sdmmc->DCTRL = SDMMC_DCTRL_DTDIR |
 8001efc:	2392      	movs	r3, #146	; 0x92
 8001efe:	62d3      	str	r3, [r2, #44]	; 0x2c
  sdcp->sdmmc->IDMACTRL  = SDMMC_IDMA_IDMAEN;
 8001f00:	2301      	movs	r3, #1
  sdcp->sdmmc->IDMABASE0 = (uint32_t)buf;
 8001f02:	f8c2 b058 	str.w	fp, [r2, #88]	; 0x58
  sdcp->sdmmc->IDMACTRL  = SDMMC_IDMA_IDMAEN;
 8001f06:	6513      	str	r3, [r2, #80]	; 0x50
  if (!(sdcp->cardmode & SDC_MODE_HIGH_CAPACITY))
 8001f08:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8001f0a:	06db      	lsls	r3, r3, #27
 8001f0c:	bf54      	ite	pl
 8001f0e:	026b      	lslpl	r3, r5, #9
 8001f10:	462b      	movmi	r3, r5
  sdcp->sdmmc->ARG = arg;
 8001f12:	6093      	str	r3, [r2, #8]
  sdcp->sdmmc->CMD = (uint32_t)cmd | SDMMC_CMD_WAITRESP_0 | SDMMC_CMD_CPSMEN;
 8001f14:	f241 1351 	movw	r3, #4433	; 0x1151
 8001f18:	60d3      	str	r3, [r2, #12]
  while (((sta = sdcp->sdmmc->STA) & (SDMMC_STA_CMDREND | SDMMC_STA_CTIMEOUT |
 8001f1a:	6b53      	ldr	r3, [r2, #52]	; 0x34
                                     SDMMC_STA_CCRCFAIL)) == 0)
 8001f1c:	f013 0045 	ands.w	r0, r3, #69	; 0x45
 8001f20:	d0fb      	beq.n	8001f1a <sdcRead+0x8a>
  if ((sta & (SDMMC_STA_CTIMEOUT | SDMMC_STA_CCRCFAIL)) != 0) {
 8001f22:	f013 0f05 	tst.w	r3, #5
  sdcp->sdmmc->ICR = sta & (SDMMC_STA_CMDREND | SDMMC_STA_CTIMEOUT |
 8001f26:	6390      	str	r0, [r2, #56]	; 0x38
  if ((sta & (SDMMC_STA_CTIMEOUT | SDMMC_STA_CCRCFAIL)) != 0) {
 8001f28:	d115      	bne.n	8001f56 <sdcRead+0xc6>
  *resp = sdcp->sdmmc->RESP1;
 8001f2a:	6953      	ldr	r3, [r2, #20]
                                   startblk, resp) || MMCSD_R1_ERROR(resp[0]))
 8001f2c:	ea13 0f0a 	tst.w	r3, sl
  *resp = sdcp->sdmmc->RESP1;
 8001f30:	600b      	str	r3, [r1, #0]
                                   startblk, resp) || MMCSD_R1_ERROR(resp[0]))
 8001f32:	d116      	bne.n	8001f62 <sdcRead+0xd2>
  if (sdc_lld_wait_transaction_end(sdcp, blocks, sdcp->resp) == true)
 8001f34:	4620      	mov	r0, r4
 8001f36:	f7ff ff83 	bl	8001e40 <sdc_lld_wait_transaction_end.constprop.0>
 8001f3a:	b9d0      	cbnz	r0, 8001f72 <sdcRead+0xe2>
    startblk++;
 8001f3c:	3501      	adds	r5, #1
    memcpy(buf, sdcp->buf, MMCSD_BLOCK_SIZE);
 8001f3e:	4630      	mov	r0, r6
 8001f40:	f44f 7200 	mov.w	r2, #512	; 0x200
 8001f44:	6be1      	ldr	r1, [r4, #60]	; 0x3c
 8001f46:	f7fe fa51 	bl	80003ec <memcpy>
  for (i = 0; i < blocks; i++) {
 8001f4a:	42bd      	cmp	r5, r7
    buf += MMCSD_BLOCK_SIZE;
 8001f4c:	f506 7600 	add.w	r6, r6, #512	; 0x200
  for (i = 0; i < blocks; i++) {
 8001f50:	d1bc      	bne.n	8001ecc <sdcRead+0x3c>
  return HAL_SUCCESS;
 8001f52:	2000      	movs	r0, #0
 8001f54:	e7c3      	b.n	8001ede <sdcRead+0x4e>
    sdc_lld_collect_errors(sdcp, sta);
 8001f56:	4619      	mov	r1, r3
 8001f58:	4620      	mov	r0, r4
 8001f5a:	9201      	str	r2, [sp, #4]
 8001f5c:	f7fe fd30 	bl	80009c0 <sdc_lld_collect_errors>
    return HAL_FAILED;
 8001f60:	9a01      	ldr	r2, [sp, #4]
  uint32_t sta = sdcp->sdmmc->STA;
 8001f62:	6b53      	ldr	r3, [r2, #52]	; 0x34
  sdc_lld_collect_errors(sdcp, sta);
 8001f64:	4620      	mov	r0, r4
  sta = sdcp->sdmmc->STA;
 8001f66:	6b51      	ldr	r1, [r2, #52]	; 0x34
  sdcp->sdmmc->ICR = sta;
 8001f68:	6391      	str	r1, [r2, #56]	; 0x38
  sdc_lld_collect_errors(sdcp, sta);
 8001f6a:	f7fe fd29 	bl	80009c0 <sdc_lld_collect_errors>
      return HAL_FAILED;
 8001f6e:	2001      	movs	r0, #1
 8001f70:	e7b5      	b.n	8001ede <sdcRead+0x4e>
  uint32_t sta = sdcp->sdmmc->STA;
 8001f72:	6c62      	ldr	r2, [r4, #68]	; 0x44
 8001f74:	e7f5      	b.n	8001f62 <sdcRead+0xd2>
 8001f76:	bf00      	nop
 8001f78:	000f4240 	.word	0x000f4240
 8001f7c:	fdffe008 	.word	0xfdffe008

08001f80 <sdcWrite>:
              const uint8_t *buf, uint32_t n) {
 8001f80:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8001f84:	4616      	mov	r6, r2
  if ((startblk + n - 1U) > sdcp->capacity) {
 8001f86:	1e5a      	subs	r2, r3, #1
              const uint8_t *buf, uint32_t n) {
 8001f88:	460d      	mov	r5, r1
 8001f8a:	b083      	sub	sp, #12
  if ((startblk + n - 1U) > sdcp->capacity) {
 8001f8c:	440a      	add	r2, r1
 8001f8e:	6a81      	ldr	r1, [r0, #40]	; 0x28
              const uint8_t *buf, uint32_t n) {
 8001f90:	4604      	mov	r4, r0
  if ((startblk + n - 1U) > sdcp->capacity) {
 8001f92:	428a      	cmp	r2, r1
 8001f94:	d907      	bls.n	8001fa6 <sdcWrite+0x26>
    sdcp->errors |= SDC_OVERFLOW_ERROR;
 8001f96:	6b43      	ldr	r3, [r0, #52]	; 0x34
    return HAL_FAILED;
 8001f98:	2001      	movs	r0, #1
    sdcp->errors |= SDC_OVERFLOW_ERROR;
 8001f9a:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8001f9e:	6363      	str	r3, [r4, #52]	; 0x34
}
 8001fa0:	b003      	add	sp, #12
 8001fa2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  sdcp->state = BLK_WRITING;
 8001fa6:	2207      	movs	r2, #7
 8001fa8:	7102      	strb	r2, [r0, #4]
  for (i = 0; i < blocks; i++) {
 8001faa:	2b00      	cmp	r3, #0
 8001fac:	d048      	beq.n	8002040 <sdcWrite+0xc0>
 8001fae:	18ef      	adds	r7, r5, r3
    memcpy(sdcp->buf, buf, MMCSD_BLOCK_SIZE);
 8001fb0:	f44f 7900 	mov.w	r9, #512	; 0x200
  sdcp->sdmmc->DTIMER = STM32_SDC_SDMMC_WRITE_TIMEOUT;
 8001fb4:	f8df 80ac 	ldr.w	r8, [pc, #172]	; 8002064 <sdcWrite+0xe4>
                                   startblk, resp) || MMCSD_R1_ERROR(resp[0]))
 8001fb8:	f8df a0ac 	ldr.w	sl, [pc, #172]	; 8002068 <sdcWrite+0xe8>
    memcpy(sdcp->buf, buf, MMCSD_BLOCK_SIZE);
 8001fbc:	f44f 7200 	mov.w	r2, #512	; 0x200
 8001fc0:	4631      	mov	r1, r6
 8001fc2:	6be0      	ldr	r0, [r4, #60]	; 0x3c
    buf += MMCSD_BLOCK_SIZE;
 8001fc4:	4416      	add	r6, r2
    memcpy(sdcp->buf, buf, MMCSD_BLOCK_SIZE);
 8001fc6:	f7fe fa11 	bl	80003ec <memcpy>
  sdcp->sdmmc->DTIMER = STM32_SDC_SDMMC_WRITE_TIMEOUT;
 8001fca:	6c63      	ldr	r3, [r4, #68]	; 0x44
  if (_sdc_wait_for_transfer_state(sdcp))
 8001fcc:	4620      	mov	r0, r4
    if (sdc_lld_write_aligned(sdcp, startblk, sdcp->buf, 1))
 8001fce:	f8d4 b03c 	ldr.w	fp, [r4, #60]	; 0x3c
  sdcp->sdmmc->DTIMER = STM32_SDC_SDMMC_WRITE_TIMEOUT;
 8001fd2:	f8c3 8024 	str.w	r8, [r3, #36]	; 0x24
  if (_sdc_wait_for_transfer_state(sdcp))
 8001fd6:	f7ff fedb 	bl	8001d90 <_sdc_wait_for_transfer_state>
 8001fda:	b120      	cbz	r0, 8001fe6 <sdcWrite+0x66>
  sdcp->state = BLK_READY;
 8001fdc:	2305      	movs	r3, #5
 8001fde:	7123      	strb	r3, [r4, #4]
}
 8001fe0:	b003      	add	sp, #12
 8001fe2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  sdcp->sdmmc->ICR   = SDMMC_ICR_ALL_FLAGS;
 8001fe6:	6c62      	ldr	r2, [r4, #68]	; 0x44
 8001fe8:	f04f 33ff 	mov.w	r3, #4294967295
  if (sdc_lld_prepare_write(sdcp, startblk, blocks, sdcp->resp) == true)
 8001fec:	6ce1      	ldr	r1, [r4, #76]	; 0x4c
  sdcp->sdmmc->ICR   = SDMMC_ICR_ALL_FLAGS;
 8001fee:	6393      	str	r3, [r2, #56]	; 0x38
  sdcp->sdmmc->MASK  = SDMMC_MASK_DCRCFAILIE |
 8001ff0:	f44f 738d 	mov.w	r3, #282	; 0x11a
 8001ff4:	63d3      	str	r3, [r2, #60]	; 0x3c
  sdcp->sdmmc->DCTRL = SDMMC_DCTRL_DBLOCKSIZE_3 |
 8001ff6:	2390      	movs	r3, #144	; 0x90
  sdcp->sdmmc->DLEN  = blocks * MMCSD_BLOCK_SIZE;
 8001ff8:	f8c2 9028 	str.w	r9, [r2, #40]	; 0x28
  sdcp->sdmmc->DCTRL = SDMMC_DCTRL_DBLOCKSIZE_3 |
 8001ffc:	62d3      	str	r3, [r2, #44]	; 0x2c
  sdcp->sdmmc->IDMACTRL  = SDMMC_IDMA_IDMAEN;
 8001ffe:	2301      	movs	r3, #1
  sdcp->sdmmc->IDMABASE0 = (uint32_t)buf;
 8002000:	f8c2 b058 	str.w	fp, [r2, #88]	; 0x58
  sdcp->sdmmc->IDMACTRL  = SDMMC_IDMA_IDMAEN;
 8002004:	6513      	str	r3, [r2, #80]	; 0x50
  if (!(sdcp->cardmode & SDC_MODE_HIGH_CAPACITY))
 8002006:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8002008:	06db      	lsls	r3, r3, #27
 800200a:	bf54      	ite	pl
 800200c:	026b      	lslpl	r3, r5, #9
 800200e:	462b      	movmi	r3, r5
  sdcp->sdmmc->ARG = arg;
 8002010:	6093      	str	r3, [r2, #8]
  sdcp->sdmmc->CMD = (uint32_t)cmd | SDMMC_CMD_WAITRESP_0 | SDMMC_CMD_CPSMEN;
 8002012:	f241 1358 	movw	r3, #4440	; 0x1158
 8002016:	60d3      	str	r3, [r2, #12]
  while (((sta = sdcp->sdmmc->STA) & (SDMMC_STA_CMDREND | SDMMC_STA_CTIMEOUT |
 8002018:	6b53      	ldr	r3, [r2, #52]	; 0x34
                                     SDMMC_STA_CCRCFAIL)) == 0)
 800201a:	f013 0045 	ands.w	r0, r3, #69	; 0x45
 800201e:	d0fb      	beq.n	8002018 <sdcWrite+0x98>
  if ((sta & (SDMMC_STA_CTIMEOUT | SDMMC_STA_CCRCFAIL)) != 0) {
 8002020:	f013 0f05 	tst.w	r3, #5
  sdcp->sdmmc->ICR = sta & (SDMMC_STA_CMDREND | SDMMC_STA_CTIMEOUT |
 8002024:	6390      	str	r0, [r2, #56]	; 0x38
  if ((sta & (SDMMC_STA_CTIMEOUT | SDMMC_STA_CCRCFAIL)) != 0) {
 8002026:	d10d      	bne.n	8002044 <sdcWrite+0xc4>
  *resp = sdcp->sdmmc->RESP1;
 8002028:	6953      	ldr	r3, [r2, #20]
                                   startblk, resp) || MMCSD_R1_ERROR(resp[0]))
 800202a:	ea13 0f0a 	tst.w	r3, sl
  *resp = sdcp->sdmmc->RESP1;
 800202e:	600b      	str	r3, [r1, #0]
                                   startblk, resp) || MMCSD_R1_ERROR(resp[0]))
 8002030:	d10e      	bne.n	8002050 <sdcWrite+0xd0>
  if (sdc_lld_wait_transaction_end(sdcp, blocks, sdcp->resp) == true)
 8002032:	4620      	mov	r0, r4
 8002034:	f7ff ff04 	bl	8001e40 <sdc_lld_wait_transaction_end.constprop.0>
 8002038:	b990      	cbnz	r0, 8002060 <sdcWrite+0xe0>
    startblk++;
 800203a:	3501      	adds	r5, #1
  for (i = 0; i < blocks; i++) {
 800203c:	42bd      	cmp	r5, r7
 800203e:	d1bd      	bne.n	8001fbc <sdcWrite+0x3c>
  return HAL_SUCCESS;
 8002040:	2000      	movs	r0, #0
 8002042:	e7cb      	b.n	8001fdc <sdcWrite+0x5c>
    sdc_lld_collect_errors(sdcp, sta);
 8002044:	4619      	mov	r1, r3
 8002046:	4620      	mov	r0, r4
 8002048:	9201      	str	r2, [sp, #4]
 800204a:	f7fe fcb9 	bl	80009c0 <sdc_lld_collect_errors>
    return HAL_FAILED;
 800204e:	9a01      	ldr	r2, [sp, #4]
  uint32_t sta = sdcp->sdmmc->STA;
 8002050:	6b53      	ldr	r3, [r2, #52]	; 0x34
  sdc_lld_collect_errors(sdcp, sta);
 8002052:	4620      	mov	r0, r4
  sta = sdcp->sdmmc->STA;
 8002054:	6b51      	ldr	r1, [r2, #52]	; 0x34
  sdcp->sdmmc->ICR = sta;
 8002056:	6391      	str	r1, [r2, #56]	; 0x38
  sdc_lld_collect_errors(sdcp, sta);
 8002058:	f7fe fcb2 	bl	80009c0 <sdc_lld_collect_errors>
      return HAL_FAILED;
 800205c:	2001      	movs	r0, #1
 800205e:	e7bd      	b.n	8001fdc <sdcWrite+0x5c>
  uint32_t sta = sdcp->sdmmc->STA;
 8002060:	6c62      	ldr	r2, [r4, #68]	; 0x44
 8002062:	e7f5      	b.n	8002050 <sdcWrite+0xd0>
 8002064:	000f4240 	.word	0x000f4240
 8002068:	fdffe008 	.word	0xfdffe008
 800206c:	00000000 	.word	0x00000000

08002070 <sdc_lld_read_special>:
                          uint8_t cmd, uint32_t arg) {
 8002070:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8002074:	4690      	mov	r8, r2
 8002076:	461e      	mov	r6, r3
  sdcp->sdmmc->DTIMER = STM32_SDC_SDMMC_READ_TIMEOUT;
 8002078:	4a1e      	ldr	r2, [pc, #120]	; (80020f4 <sdc_lld_read_special+0x84>)
                          uint8_t cmd, uint32_t arg) {
 800207a:	4605      	mov	r5, r0
  sdcp->sdmmc->DTIMER = STM32_SDC_SDMMC_READ_TIMEOUT;
 800207c:	6c43      	ldr	r3, [r0, #68]	; 0x44
                          uint8_t cmd, uint32_t arg) {
 800207e:	460f      	mov	r7, r1
  sdcp->sdmmc->DTIMER = STM32_SDC_SDMMC_READ_TIMEOUT;
 8002080:	625a      	str	r2, [r3, #36]	; 0x24
  if (_sdc_wait_for_transfer_state(sdcp))
 8002082:	f7ff fe85 	bl	8001d90 <_sdc_wait_for_transfer_state>
  sdcp->sdmmc->ICR   = SDMMC_ICR_ALL_FLAGS;
 8002086:	6c6c      	ldr	r4, [r5, #68]	; 0x44
  if (_sdc_wait_for_transfer_state(sdcp))
 8002088:	b9f8      	cbnz	r0, 80020ca <sdc_lld_read_special+0x5a>
  sdcp->sdmmc->ICR   = SDMMC_ICR_ALL_FLAGS;
 800208a:	f04f 32ff 	mov.w	r2, #4294967295
  sdcp->sdmmc->CMD = (uint32_t)cmd | SDMMC_CMD_WAITRESP_0 | SDMMC_CMD_CPSMEN;
 800208e:	f446 568a 	orr.w	r6, r6, #4416	; 0x1140
  sdcp->sdmmc->ARG = arg;
 8002092:	9b06      	ldr	r3, [sp, #24]
  sdcp->sdmmc->ICR   = SDMMC_ICR_ALL_FLAGS;
 8002094:	63a2      	str	r2, [r4, #56]	; 0x38
  sdcp->sdmmc->MASK  = SDMMC_MASK_DCRCFAILIE |
 8002096:	f44f 7295 	mov.w	r2, #298	; 0x12a
  if (sdc_lld_send_cmd_short_crc(sdcp, SDMMC_CMD_CMDTRANS | cmd, arg, sdcp->resp) ||
 800209a:	6ce9      	ldr	r1, [r5, #76]	; 0x4c
  sdcp->sdmmc->MASK  = SDMMC_MASK_DCRCFAILIE |
 800209c:	63e2      	str	r2, [r4, #60]	; 0x3c
  sdcp->sdmmc->DCTRL = SDMMC_DCTRL_DTDIR |
 800209e:	2206      	movs	r2, #6
  sdcp->sdmmc->DLEN  = bytes;
 80020a0:	f8c4 8028 	str.w	r8, [r4, #40]	; 0x28
  sdcp->sdmmc->DCTRL = SDMMC_DCTRL_DTDIR |
 80020a4:	62e2      	str	r2, [r4, #44]	; 0x2c
  sdcp->sdmmc->IDMACTRL  = SDMMC_IDMA_IDMAEN;
 80020a6:	2201      	movs	r2, #1
  sdcp->sdmmc->IDMABASE0 = (uint32_t)buf;
 80020a8:	65a7      	str	r7, [r4, #88]	; 0x58
  sdcp->sdmmc->IDMACTRL  = SDMMC_IDMA_IDMAEN;
 80020aa:	6522      	str	r2, [r4, #80]	; 0x50
  sdcp->sdmmc->ARG = arg;
 80020ac:	60a3      	str	r3, [r4, #8]
  sdcp->sdmmc->CMD = (uint32_t)cmd | SDMMC_CMD_WAITRESP_0 | SDMMC_CMD_CPSMEN;
 80020ae:	60e6      	str	r6, [r4, #12]
  while (((sta = sdcp->sdmmc->STA) & (SDMMC_STA_CMDREND | SDMMC_STA_CTIMEOUT |
 80020b0:	6b63      	ldr	r3, [r4, #52]	; 0x34
                                     SDMMC_STA_CCRCFAIL)) == 0)
 80020b2:	f013 0245 	ands.w	r2, r3, #69	; 0x45
 80020b6:	d0fb      	beq.n	80020b0 <sdc_lld_read_special+0x40>
  if ((sta & (SDMMC_STA_CTIMEOUT | SDMMC_STA_CCRCFAIL)) != 0) {
 80020b8:	f013 0f05 	tst.w	r3, #5
  sdcp->sdmmc->ICR = sta & (SDMMC_STA_CMDREND | SDMMC_STA_CTIMEOUT |
 80020bc:	63a2      	str	r2, [r4, #56]	; 0x38
  if ((sta & (SDMMC_STA_CTIMEOUT | SDMMC_STA_CCRCFAIL)) != 0) {
 80020be:	d114      	bne.n	80020ea <sdc_lld_read_special+0x7a>
  *resp = sdcp->sdmmc->RESP1;
 80020c0:	6962      	ldr	r2, [r4, #20]
      MMCSD_R1_ERROR(sdcp->resp[0]))
 80020c2:	4b0d      	ldr	r3, [pc, #52]	; (80020f8 <sdc_lld_read_special+0x88>)
  *resp = sdcp->sdmmc->RESP1;
 80020c4:	600a      	str	r2, [r1, #0]
      MMCSD_R1_ERROR(sdcp->resp[0]))
 80020c6:	4013      	ands	r3, r2
  if (sdc_lld_send_cmd_short_crc(sdcp, SDMMC_CMD_CMDTRANS | cmd, arg, sdcp->resp) ||
 80020c8:	b143      	cbz	r3, 80020dc <sdc_lld_read_special+0x6c>
  uint32_t sta = sdcp->sdmmc->STA;
 80020ca:	6b63      	ldr	r3, [r4, #52]	; 0x34
  sdc_lld_collect_errors(sdcp, sta);
 80020cc:	4628      	mov	r0, r5
  sta = sdcp->sdmmc->STA;
 80020ce:	6b61      	ldr	r1, [r4, #52]	; 0x34
  sdcp->sdmmc->ICR = sta;
 80020d0:	63a1      	str	r1, [r4, #56]	; 0x38
  sdc_lld_collect_errors(sdcp, sta);
 80020d2:	f7fe fc75 	bl	80009c0 <sdc_lld_collect_errors>
  return HAL_FAILED;
 80020d6:	2001      	movs	r0, #1
}
 80020d8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  if (sdc_lld_wait_transaction_end(sdcp, 1, sdcp->resp))
 80020dc:	4628      	mov	r0, r5
 80020de:	f7ff feaf 	bl	8001e40 <sdc_lld_wait_transaction_end.constprop.0>
 80020e2:	2800      	cmp	r0, #0
 80020e4:	d0f8      	beq.n	80020d8 <sdc_lld_read_special+0x68>
  uint32_t sta = sdcp->sdmmc->STA;
 80020e6:	6c6c      	ldr	r4, [r5, #68]	; 0x44
 80020e8:	e7ef      	b.n	80020ca <sdc_lld_read_special+0x5a>
    sdc_lld_collect_errors(sdcp, sta);
 80020ea:	4619      	mov	r1, r3
 80020ec:	4628      	mov	r0, r5
 80020ee:	f7fe fc67 	bl	80009c0 <sdc_lld_collect_errors>
    return HAL_FAILED;
 80020f2:	e7ea      	b.n	80020ca <sdc_lld_read_special+0x5a>
 80020f4:	000f4240 	.word	0x000f4240
 80020f8:	fdffe008 	.word	0xfdffe008
 80020fc:	00000000 	.word	0x00000000

08002100 <sdcConnect>:
  if (f >= sdcp->clkfreq) {
 8002100:	4b6d      	ldr	r3, [pc, #436]	; (80022b8 <sdcConnect+0x1b8>)
  sdcp->state = BLK_CONNECTING;
 8002102:	2203      	movs	r2, #3
 8002104:	6c81      	ldr	r1, [r0, #72]	; 0x48
 8002106:	4299      	cmp	r1, r3
bool sdcConnect(SDCDriver *sdcp) {
 8002108:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  sdcp->state = BLK_CONNECTING;
 800210c:	7102      	strb	r2, [r0, #4]
bool sdcConnect(SDCDriver *sdcp) {
 800210e:	b083      	sub	sp, #12
 8002110:	4605      	mov	r5, r0
 8002112:	6c42      	ldr	r2, [r0, #68]	; 0x44
 8002114:	d93d      	bls.n	8002192 <sdcConnect+0x92>
  return (sdcp->clkfreq + (f * 2) - 1) / (f * 2);
 8002116:	4b69      	ldr	r3, [pc, #420]	; (80022bc <sdcConnect+0x1bc>)
 8002118:	4869      	ldr	r0, [pc, #420]	; (80022c0 <sdcConnect+0x1c0>)
 800211a:	440b      	add	r3, r1
 800211c:	0a1b      	lsrs	r3, r3, #8
 800211e:	fba0 0303 	umull	r0, r3, r0, r3
 8002122:	091b      	lsrs	r3, r3, #4
  sdcp->sdmmc->CLKCR  = sdc_lld_clkdiv(sdcp, 400000);
 8002124:	6053      	str	r3, [r2, #4]
 8002126:	2130      	movs	r1, #48	; 0x30
  sdcp->sdmmc->POWER |= SDMMC_POWER_PWRCTRL_0 | SDMMC_POWER_PWRCTRL_1;
 8002128:	6813      	ldr	r3, [r2, #0]
 800212a:	f043 0303 	orr.w	r3, r3, #3
 800212e:	6013      	str	r3, [r2, #0]
 8002130:	f381 8811 	msr	BASEPRI, r1
  (void) chSchGoSleepTimeoutS(CH_STATE_SLEEPING, ticks);
 8002134:	2164      	movs	r1, #100	; 0x64
 8002136:	2008      	movs	r0, #8
 8002138:	f7ff fbd2 	bl	80018e0 <chSchGoSleepTimeoutS>
 800213c:	2300      	movs	r3, #0
 800213e:	f383 8811 	msr	BASEPRI, r3
  sdcp->sdmmc->CMD = (uint32_t)cmd | SDMMC_CMD_CPSMEN;
 8002142:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 8002146:	6c6c      	ldr	r4, [r5, #68]	; 0x44
  sdcp->sdmmc->ARG = arg;
 8002148:	60a3      	str	r3, [r4, #8]
  sdcp->sdmmc->CMD = (uint32_t)cmd | SDMMC_CMD_CPSMEN;
 800214a:	60e2      	str	r2, [r4, #12]
  while ((sdcp->sdmmc->STA & SDMMC_STA_CMDSENT) == 0)
 800214c:	6b63      	ldr	r3, [r4, #52]	; 0x34
 800214e:	061b      	lsls	r3, r3, #24
 8002150:	d5fc      	bpl.n	800214c <sdcConnect+0x4c>
  sdcp->sdmmc->ICR = SDMMC_ICR_CMDSENTC;
 8002152:	2180      	movs	r1, #128	; 0x80
  sdcp->sdmmc->ARG = arg;
 8002154:	f44f 72d5 	mov.w	r2, #426	; 0x1aa
  sdcp->sdmmc->CMD = (uint32_t)cmd | SDMMC_CMD_WAITRESP_0 | SDMMC_CMD_CPSMEN;
 8002158:	f241 1308 	movw	r3, #4360	; 0x1108
  sdcp->sdmmc->ICR = SDMMC_ICR_CMDSENTC;
 800215c:	63a1      	str	r1, [r4, #56]	; 0x38
  sdcp->sdmmc->ARG = arg;
 800215e:	60a2      	str	r2, [r4, #8]
  sdcp->sdmmc->CMD = (uint32_t)cmd | SDMMC_CMD_WAITRESP_0 | SDMMC_CMD_CPSMEN;
 8002160:	60e3      	str	r3, [r4, #12]
  while (((sta = sdcp->sdmmc->STA) & (SDMMC_STA_CMDREND | SDMMC_STA_CTIMEOUT |
 8002162:	6b61      	ldr	r1, [r4, #52]	; 0x34
                                     SDMMC_STA_CCRCFAIL)) == 0)
 8002164:	f011 0345 	ands.w	r3, r1, #69	; 0x45
 8002168:	d0fb      	beq.n	8002162 <sdcConnect+0x62>
  if ((sta & (SDMMC_STA_CTIMEOUT | SDMMC_STA_CCRCFAIL)) != 0) {
 800216a:	f011 0005 	ands.w	r0, r1, #5
  sdcp->sdmmc->ICR = sta & (SDMMC_STA_CMDREND | SDMMC_STA_CTIMEOUT |
 800216e:	63a3      	str	r3, [r4, #56]	; 0x38
  if ((sta & (SDMMC_STA_CTIMEOUT | SDMMC_STA_CCRCFAIL)) != 0) {
 8002170:	d111      	bne.n	8002196 <sdcConnect+0x96>
  *resp = sdcp->sdmmc->RESP1;
 8002172:	6963      	ldr	r3, [r4, #20]
    sdcp->cardmode = SDC_MODE_CARDTYPE_SDV20;
 8002174:	2201      	movs	r2, #1
    if (((resp[0] >> 8U) & 0xFU) != 1U) {
 8002176:	f3c3 2303 	ubfx	r3, r3, #8, #4
    sdcp->cardmode = SDC_MODE_CARDTYPE_SDV20;
 800217a:	632a      	str	r2, [r5, #48]	; 0x30
    if (((resp[0] >> 8U) & 0xFU) != 1U) {
 800217c:	4293      	cmp	r3, r2
 800217e:	d043      	beq.n	8002208 <sdcConnect+0x108>
  sdcp->sdmmc->CLKCR = 0;
 8002180:	2300      	movs	r3, #0
  return HAL_FAILED;
 8002182:	2202      	movs	r2, #2
 8002184:	2001      	movs	r0, #1
 8002186:	6063      	str	r3, [r4, #4]
  sdcp->sdmmc->POWER = 0;
 8002188:	6023      	str	r3, [r4, #0]
  sdcp->state = BLK_READY;
 800218a:	712a      	strb	r2, [r5, #4]
}
 800218c:	b003      	add	sp, #12
 800218e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    return 0;
 8002192:	2300      	movs	r3, #0
 8002194:	e7c6      	b.n	8002124 <sdcConnect+0x24>
    sdc_lld_collect_errors(sdcp, sta);
 8002196:	4628      	mov	r0, r5
 8002198:	f7fe fc12 	bl	80009c0 <sdc_lld_collect_errors>
  sdcp->sdmmc->ARG = arg;
 800219c:	2200      	movs	r2, #0
  sdcp->sdmmc->CMD = (uint32_t)cmd | SDMMC_CMD_WAITRESP_0 | SDMMC_CMD_CPSMEN;
 800219e:	f241 1337 	movw	r3, #4407	; 0x1137
  sdcp->sdmmc->ARG = arg;
 80021a2:	60a2      	str	r2, [r4, #8]
  sdcp->sdmmc->CMD = (uint32_t)cmd | SDMMC_CMD_WAITRESP_0 | SDMMC_CMD_CPSMEN;
 80021a4:	60e3      	str	r3, [r4, #12]
  while (((sta = sdcp->sdmmc->STA) & (SDMMC_STA_CMDREND | SDMMC_STA_CTIMEOUT |
 80021a6:	6b61      	ldr	r1, [r4, #52]	; 0x34
                                     SDMMC_STA_CCRCFAIL)) == 0)
 80021a8:	f011 0345 	ands.w	r3, r1, #69	; 0x45
 80021ac:	d0fb      	beq.n	80021a6 <sdcConnect+0xa6>
  if ((sta & (SDMMC_STA_CTIMEOUT | SDMMC_STA_CCRCFAIL)) != 0) {
 80021ae:	f011 0f05 	tst.w	r1, #5
  sdcp->sdmmc->ICR = sta & (SDMMC_STA_CMDREND | SDMMC_STA_CTIMEOUT |
 80021b2:	63a3      	str	r3, [r4, #56]	; 0x38
  if ((sta & (SDMMC_STA_CTIMEOUT | SDMMC_STA_CCRCFAIL)) != 0) {
 80021b4:	f040 8151 	bne.w	800245a <sdcConnect+0x35a>
  *resp = sdcp->sdmmc->RESP1;
 80021b8:	6962      	ldr	r2, [r4, #20]
        MMCSD_R1_ERROR(resp[0])) {
 80021ba:	4b42      	ldr	r3, [pc, #264]	; (80022c4 <sdcConnect+0x1c4>)
 80021bc:	4013      	ands	r3, r2
    if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_APP_CMD, 0, resp) ||
 80021be:	2b00      	cmp	r3, #0
 80021c0:	d06d      	beq.n	800229e <sdcConnect+0x19e>
      sdcp->cardmode = SDC_MODE_CARDTYPE_MMC;
 80021c2:	2302      	movs	r3, #2
 80021c4:	2664      	movs	r6, #100	; 0x64
  sdcp->sdmmc->ARG = arg;
 80021c6:	f8df 8100 	ldr.w	r8, [pc, #256]	; 80022c8 <sdcConnect+0x1c8>
  sdcp->sdmmc->CMD = (uint32_t)cmd | SDMMC_CMD_WAITRESP_0 | SDMMC_CMD_CPSMEN;
 80021ca:	f241 1701 	movw	r7, #4353	; 0x1101
 80021ce:	f04f 0930 	mov.w	r9, #48	; 0x30
 80021d2:	632b      	str	r3, [r5, #48]	; 0x30
  sdcp->sdmmc->ARG = arg;
 80021d4:	f8c4 8008 	str.w	r8, [r4, #8]
  sdcp->sdmmc->CMD = (uint32_t)cmd | SDMMC_CMD_WAITRESP_0 | SDMMC_CMD_CPSMEN;
 80021d8:	60e7      	str	r7, [r4, #12]
  while (((sta = sdcp->sdmmc->STA) & (SDMMC_STA_CMDREND | SDMMC_STA_CTIMEOUT |
 80021da:	6b61      	ldr	r1, [r4, #52]	; 0x34
                                     SDMMC_STA_CCRCFAIL)) == 0)
 80021dc:	f011 0345 	ands.w	r3, r1, #69	; 0x45
 80021e0:	d0fb      	beq.n	80021da <sdcConnect+0xda>
  if ((sta & (SDMMC_STA_CTIMEOUT)) != 0) {
 80021e2:	f011 0a04 	ands.w	sl, r1, #4
  sdcp->sdmmc->ICR = sta & (SDMMC_STA_CMDREND | SDMMC_STA_CTIMEOUT |
 80021e6:	63a3      	str	r3, [r4, #56]	; 0x38
  if ((sta & (SDMMC_STA_CTIMEOUT)) != 0) {
 80021e8:	d11a      	bne.n	8002220 <sdcConnect+0x120>
  *resp = sdcp->sdmmc->RESP1;
 80021ea:	6963      	ldr	r3, [r4, #20]
    if ((resp[0] & 0x80000000U) != 0U) {
 80021ec:	2b00      	cmp	r3, #0
 80021ee:	db71      	blt.n	80022d4 <sdcConnect+0x1d4>
    if (++i >= (unsigned)SDC_INIT_RETRY) {
 80021f0:	3e01      	subs	r6, #1
 80021f2:	d0c5      	beq.n	8002180 <sdcConnect+0x80>
 80021f4:	f389 8811 	msr	BASEPRI, r9
 80021f8:	2164      	movs	r1, #100	; 0x64
 80021fa:	2008      	movs	r0, #8
 80021fc:	f7ff fb70 	bl	80018e0 <chSchGoSleepTimeoutS>
 8002200:	f38a 8811 	msr	BASEPRI, sl
  sdcp->sdmmc->ARG = arg;
 8002204:	6c6c      	ldr	r4, [r5, #68]	; 0x44
}
 8002206:	e7e5      	b.n	80021d4 <sdcConnect+0xd4>
  sdcp->sdmmc->CMD = (uint32_t)cmd | SDMMC_CMD_WAITRESP_0 | SDMMC_CMD_CPSMEN;
 8002208:	f241 1337 	movw	r3, #4407	; 0x1137
  sdcp->sdmmc->ARG = arg;
 800220c:	60a0      	str	r0, [r4, #8]
  sdcp->sdmmc->CMD = (uint32_t)cmd | SDMMC_CMD_WAITRESP_0 | SDMMC_CMD_CPSMEN;
 800220e:	60e3      	str	r3, [r4, #12]
  while (((sta = sdcp->sdmmc->STA) & (SDMMC_STA_CMDREND | SDMMC_STA_CTIMEOUT |
 8002210:	6b61      	ldr	r1, [r4, #52]	; 0x34
                                     SDMMC_STA_CCRCFAIL)) == 0)
 8002212:	f011 0345 	ands.w	r3, r1, #69	; 0x45
 8002216:	d0fb      	beq.n	8002210 <sdcConnect+0x110>
  if ((sta & (SDMMC_STA_CTIMEOUT | SDMMC_STA_CCRCFAIL)) != 0) {
 8002218:	f011 0f05 	tst.w	r1, #5
  sdcp->sdmmc->ICR = sta & (SDMMC_STA_CMDREND | SDMMC_STA_CTIMEOUT |
 800221c:	63a3      	str	r3, [r4, #56]	; 0x38
  if ((sta & (SDMMC_STA_CTIMEOUT | SDMMC_STA_CCRCFAIL)) != 0) {
 800221e:	d003      	beq.n	8002228 <sdcConnect+0x128>
    sdc_lld_collect_errors(sdcp, sta);
 8002220:	4628      	mov	r0, r5
 8002222:	f7fe fbcd 	bl	80009c0 <sdc_lld_collect_errors>
    return HAL_FAILED;
 8002226:	e7ab      	b.n	8002180 <sdcConnect+0x80>
  *resp = sdcp->sdmmc->RESP1;
 8002228:	6962      	ldr	r2, [r4, #20]
        MMCSD_R1_ERROR(resp[0])) {
 800222a:	4b26      	ldr	r3, [pc, #152]	; (80022c4 <sdcConnect+0x1c4>)
 800222c:	4013      	ands	r3, r2
    if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_APP_CMD, 0, resp) ||
 800222e:	2b00      	cmp	r3, #0
 8002230:	d1a6      	bne.n	8002180 <sdcConnect+0x80>
    ocr = SDC_INIT_OCR_V20;
 8002232:	f8df 9098 	ldr.w	r9, [pc, #152]	; 80022cc <sdcConnect+0x1cc>
 8002236:	f04f 0a64 	mov.w	sl, #100	; 0x64
  sdcp->sdmmc->ARG = arg;
 800223a:	2700      	movs	r7, #0
  sdcp->sdmmc->CMD = (uint32_t)cmd | SDMMC_CMD_WAITRESP_0 | SDMMC_CMD_CPSMEN;
 800223c:	f241 1637 	movw	r6, #4407	; 0x1137
        MMCSD_R1_ERROR(resp[0])) {
 8002240:	f8df 8080 	ldr.w	r8, [pc, #128]	; 80022c4 <sdcConnect+0x1c4>
  sdcp->sdmmc->ARG = arg;
 8002244:	60a7      	str	r7, [r4, #8]
  sdcp->sdmmc->CMD = (uint32_t)cmd | SDMMC_CMD_WAITRESP_0 | SDMMC_CMD_CPSMEN;
 8002246:	60e6      	str	r6, [r4, #12]
  while (((sta = sdcp->sdmmc->STA) & (SDMMC_STA_CMDREND | SDMMC_STA_CTIMEOUT |
 8002248:	6b61      	ldr	r1, [r4, #52]	; 0x34
                                     SDMMC_STA_CCRCFAIL)) == 0)
 800224a:	f011 0345 	ands.w	r3, r1, #69	; 0x45
 800224e:	d0fb      	beq.n	8002248 <sdcConnect+0x148>
  if ((sta & (SDMMC_STA_CTIMEOUT | SDMMC_STA_CCRCFAIL)) != 0) {
 8002250:	f011 0f05 	tst.w	r1, #5
  sdcp->sdmmc->ICR = sta & (SDMMC_STA_CMDREND | SDMMC_STA_CTIMEOUT |
 8002254:	63a3      	str	r3, [r4, #56]	; 0x38
  if ((sta & (SDMMC_STA_CTIMEOUT | SDMMC_STA_CCRCFAIL)) != 0) {
 8002256:	d1e3      	bne.n	8002220 <sdcConnect+0x120>
  *resp = sdcp->sdmmc->RESP1;
 8002258:	6963      	ldr	r3, [r4, #20]
    if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_APP_CMD, 0, resp) ||
 800225a:	ea13 0f08 	tst.w	r3, r8
 800225e:	d18f      	bne.n	8002180 <sdcConnect+0x80>
  sdcp->sdmmc->CMD = (uint32_t)cmd | SDMMC_CMD_WAITRESP_0 | SDMMC_CMD_CPSMEN;
 8002260:	f241 1329 	movw	r3, #4393	; 0x1129
  sdcp->sdmmc->ARG = arg;
 8002264:	f8c4 9008 	str.w	r9, [r4, #8]
  sdcp->sdmmc->CMD = (uint32_t)cmd | SDMMC_CMD_WAITRESP_0 | SDMMC_CMD_CPSMEN;
 8002268:	60e3      	str	r3, [r4, #12]
  while (((sta = sdcp->sdmmc->STA) & (SDMMC_STA_CMDREND | SDMMC_STA_CTIMEOUT |
 800226a:	6b61      	ldr	r1, [r4, #52]	; 0x34
                                     SDMMC_STA_CCRCFAIL)) == 0)
 800226c:	f011 0345 	ands.w	r3, r1, #69	; 0x45
 8002270:	d0fb      	beq.n	800226a <sdcConnect+0x16a>
  if ((sta & (SDMMC_STA_CTIMEOUT)) != 0) {
 8002272:	f011 0b04 	ands.w	fp, r1, #4
  sdcp->sdmmc->ICR = sta & (SDMMC_STA_CMDREND | SDMMC_STA_CTIMEOUT |
 8002276:	63a3      	str	r3, [r4, #56]	; 0x38
  if ((sta & (SDMMC_STA_CTIMEOUT)) != 0) {
 8002278:	d1d2      	bne.n	8002220 <sdcConnect+0x120>
  *resp = sdcp->sdmmc->RESP1;
 800227a:	6963      	ldr	r3, [r4, #20]
    if ((resp[0] & 0x80000000U) != 0U) {
 800227c:	2b00      	cmp	r3, #0
 800227e:	db29      	blt.n	80022d4 <sdcConnect+0x1d4>
    if (++i >= (unsigned)SDC_INIT_RETRY) {
 8002280:	f1ba 0a01 	subs.w	sl, sl, #1
 8002284:	f43f af7c 	beq.w	8002180 <sdcConnect+0x80>
 8002288:	2330      	movs	r3, #48	; 0x30
 800228a:	f383 8811 	msr	BASEPRI, r3
 800228e:	2164      	movs	r1, #100	; 0x64
 8002290:	2008      	movs	r0, #8
 8002292:	f7ff fb25 	bl	80018e0 <chSchGoSleepTimeoutS>
 8002296:	f38b 8811 	msr	BASEPRI, fp
  sdcp->sdmmc->ARG = arg;
 800229a:	6c6c      	ldr	r4, [r5, #68]	; 0x44
 800229c:	e7d2      	b.n	8002244 <sdcConnect+0x144>
  sdcp->sdmmc->CMD = (uint32_t)cmd | SDMMC_CMD_CPSMEN;
 800229e:	f44f 5280 	mov.w	r2, #4096	; 0x1000
      sdcp->cardmode = SDC_MODE_CARDTYPE_SDV11;
 80022a2:	632b      	str	r3, [r5, #48]	; 0x30
  sdcp->sdmmc->ARG = arg;
 80022a4:	60a3      	str	r3, [r4, #8]
  sdcp->sdmmc->CMD = (uint32_t)cmd | SDMMC_CMD_CPSMEN;
 80022a6:	60e2      	str	r2, [r4, #12]
  while ((sdcp->sdmmc->STA & SDMMC_STA_CMDSENT) == 0)
 80022a8:	6b63      	ldr	r3, [r4, #52]	; 0x34
 80022aa:	061f      	lsls	r7, r3, #24
 80022ac:	d5fc      	bpl.n	80022a8 <sdcConnect+0x1a8>
  sdcp->sdmmc->ICR = SDMMC_ICR_CMDSENTC;
 80022ae:	2380      	movs	r3, #128	; 0x80
    ocr = SDC_INIT_OCR;
 80022b0:	f8df 901c 	ldr.w	r9, [pc, #28]	; 80022d0 <sdcConnect+0x1d0>
 80022b4:	63a3      	str	r3, [r4, #56]	; 0x38
 80022b6:	e7be      	b.n	8002236 <sdcConnect+0x136>
 80022b8:	00061a80 	.word	0x00061a80
 80022bc:	000c34ff 	.word	0x000c34ff
 80022c0:	014f8b59 	.word	0x014f8b59
 80022c4:	fdffe008 	.word	0xfdffe008
 80022c8:	c0ff8000 	.word	0xc0ff8000
 80022cc:	50ff8000 	.word	0x50ff8000
 80022d0:	80100000 	.word	0x80100000
      if ((resp[0] & 0x40000000U) != 0U) {
 80022d4:	005e      	lsls	r6, r3, #1
 80022d6:	d503      	bpl.n	80022e0 <sdcConnect+0x1e0>
        sdcp->cardmode |= SDC_MODE_HIGH_CAPACITY;
 80022d8:	6b2b      	ldr	r3, [r5, #48]	; 0x30
 80022da:	f043 0310 	orr.w	r3, r3, #16
 80022de:	632b      	str	r3, [r5, #48]	; 0x30
  sdcp->sdmmc->ARG = arg;
 80022e0:	2200      	movs	r2, #0
  sdcp->sdmmc->CMD = (uint32_t)cmd | SDMMC_CMD_WAITRESP_0 | SDMMC_CMD_WAITRESP_1 |
 80022e2:	f241 3302 	movw	r3, #4866	; 0x1302
  sdcp->sdmmc->ARG = arg;
 80022e6:	60a2      	str	r2, [r4, #8]
  sdcp->sdmmc->CMD = (uint32_t)cmd | SDMMC_CMD_WAITRESP_0 | SDMMC_CMD_WAITRESP_1 |
 80022e8:	60e3      	str	r3, [r4, #12]
  while (((sta = sdcp->sdmmc->STA) & (SDMMC_STA_CMDREND | SDMMC_STA_CTIMEOUT |
 80022ea:	6b61      	ldr	r1, [r4, #52]	; 0x34
                                     SDMMC_STA_CCRCFAIL)) == 0)
 80022ec:	f011 0345 	ands.w	r3, r1, #69	; 0x45
 80022f0:	d0fb      	beq.n	80022ea <sdcConnect+0x1ea>
  sdcp->sdmmc->ICR = sta & (SDMMC_STA_CMDREND | SDMMC_STA_CTIMEOUT |
 80022f2:	63a3      	str	r3, [r4, #56]	; 0x38
  if ((sta & (SDMMC_STA_ERROR_MASK)) != 0) {
 80022f4:	f011 033f 	ands.w	r3, r1, #63	; 0x3f
 80022f8:	d192      	bne.n	8002220 <sdcConnect+0x120>
  *resp++ = sdcp->sdmmc->RESP4;
 80022fa:	6a21      	ldr	r1, [r4, #32]
  sdcp->sdmmc->CMD = (uint32_t)cmd | SDMMC_CMD_WAITRESP_0 | SDMMC_CMD_CPSMEN;
 80022fc:	f241 1203 	movw	r2, #4355	; 0x1103
  *resp++ = sdcp->sdmmc->RESP4;
 8002300:	60a9      	str	r1, [r5, #8]
  *resp++ = sdcp->sdmmc->RESP3;
 8002302:	69e1      	ldr	r1, [r4, #28]
 8002304:	60e9      	str	r1, [r5, #12]
  *resp++ = sdcp->sdmmc->RESP2;
 8002306:	69a1      	ldr	r1, [r4, #24]
 8002308:	6129      	str	r1, [r5, #16]
  *resp   = sdcp->sdmmc->RESP1;
 800230a:	6961      	ldr	r1, [r4, #20]
 800230c:	6169      	str	r1, [r5, #20]
  sdcp->sdmmc->ARG = arg;
 800230e:	60a3      	str	r3, [r4, #8]
  sdcp->sdmmc->CMD = (uint32_t)cmd | SDMMC_CMD_WAITRESP_0 | SDMMC_CMD_CPSMEN;
 8002310:	60e2      	str	r2, [r4, #12]
  while (((sta = sdcp->sdmmc->STA) & (SDMMC_STA_CMDREND | SDMMC_STA_CTIMEOUT |
 8002312:	6b61      	ldr	r1, [r4, #52]	; 0x34
                                     SDMMC_STA_CCRCFAIL)) == 0)
 8002314:	f011 0345 	ands.w	r3, r1, #69	; 0x45
 8002318:	d0fb      	beq.n	8002312 <sdcConnect+0x212>
  if ((sta & (SDMMC_STA_CTIMEOUT | SDMMC_STA_CCRCFAIL)) != 0) {
 800231a:	f011 0f05 	tst.w	r1, #5
  sdcp->sdmmc->ICR = sta & (SDMMC_STA_CMDREND | SDMMC_STA_CTIMEOUT |
 800231e:	63a3      	str	r3, [r4, #56]	; 0x38
  if ((sta & (SDMMC_STA_CTIMEOUT | SDMMC_STA_CCRCFAIL)) != 0) {
 8002320:	f47f af7e 	bne.w	8002220 <sdcConnect+0x120>
  *resp = sdcp->sdmmc->RESP1;
 8002324:	6962      	ldr	r2, [r4, #20]
  sdcp->sdmmc->CMD = (uint32_t)cmd | SDMMC_CMD_WAITRESP_0 | SDMMC_CMD_WAITRESP_1 |
 8002326:	f241 3309 	movw	r3, #4873	; 0x1309
  *resp = sdcp->sdmmc->RESP1;
 800232a:	63aa      	str	r2, [r5, #56]	; 0x38
  sdcp->sdmmc->ARG = arg;
 800232c:	60a2      	str	r2, [r4, #8]
  sdcp->sdmmc->CMD = (uint32_t)cmd | SDMMC_CMD_WAITRESP_0 | SDMMC_CMD_WAITRESP_1 |
 800232e:	60e3      	str	r3, [r4, #12]
  while (((sta = sdcp->sdmmc->STA) & (SDMMC_STA_CMDREND | SDMMC_STA_CTIMEOUT |
 8002330:	6b61      	ldr	r1, [r4, #52]	; 0x34
                                     SDMMC_STA_CCRCFAIL)) == 0)
 8002332:	f011 0345 	ands.w	r3, r1, #69	; 0x45
 8002336:	d0fb      	beq.n	8002330 <sdcConnect+0x230>
  if ((sta & (SDMMC_STA_ERROR_MASK)) != 0) {
 8002338:	0688      	lsls	r0, r1, #26
  sdcp->sdmmc->ICR = sta & (SDMMC_STA_CMDREND | SDMMC_STA_CTIMEOUT |
 800233a:	63a3      	str	r3, [r4, #56]	; 0x38
  if ((sta & (SDMMC_STA_ERROR_MASK)) != 0) {
 800233c:	f47f af70 	bne.w	8002220 <sdcConnect+0x120>
  *resp++ = sdcp->sdmmc->RESP4;
 8002340:	6a21      	ldr	r1, [r4, #32]
  sdcp->sdmmc->CMD = (uint32_t)cmd | SDMMC_CMD_WAITRESP_0 | SDMMC_CMD_CPSMEN;
 8002342:	f241 1307 	movw	r3, #4359	; 0x1107
  *resp++ = sdcp->sdmmc->RESP4;
 8002346:	61a9      	str	r1, [r5, #24]
  *resp++ = sdcp->sdmmc->RESP3;
 8002348:	69e1      	ldr	r1, [r4, #28]
 800234a:	61e9      	str	r1, [r5, #28]
  *resp++ = sdcp->sdmmc->RESP2;
 800234c:	69a1      	ldr	r1, [r4, #24]
 800234e:	6229      	str	r1, [r5, #32]
  *resp   = sdcp->sdmmc->RESP1;
 8002350:	6961      	ldr	r1, [r4, #20]
 8002352:	6269      	str	r1, [r5, #36]	; 0x24
  sdcp->sdmmc->ARG = arg;
 8002354:	60a2      	str	r2, [r4, #8]
  sdcp->sdmmc->CMD = (uint32_t)cmd | SDMMC_CMD_WAITRESP_0 | SDMMC_CMD_CPSMEN;
 8002356:	60e3      	str	r3, [r4, #12]
  while (((sta = sdcp->sdmmc->STA) & (SDMMC_STA_CMDREND | SDMMC_STA_CTIMEOUT |
 8002358:	6b61      	ldr	r1, [r4, #52]	; 0x34
                                     SDMMC_STA_CCRCFAIL)) == 0)
 800235a:	f011 0345 	ands.w	r3, r1, #69	; 0x45
 800235e:	d0fb      	beq.n	8002358 <sdcConnect+0x258>
  if ((sta & (SDMMC_STA_CTIMEOUT | SDMMC_STA_CCRCFAIL)) != 0) {
 8002360:	f011 0005 	ands.w	r0, r1, #5
  sdcp->sdmmc->ICR = sta & (SDMMC_STA_CMDREND | SDMMC_STA_CTIMEOUT |
 8002364:	63a3      	str	r3, [r4, #56]	; 0x38
  if ((sta & (SDMMC_STA_CTIMEOUT | SDMMC_STA_CCRCFAIL)) != 0) {
 8002366:	f47f af5b 	bne.w	8002220 <sdcConnect+0x120>
  if (SDC_MODE_CARDTYPE_MMC == (sdcp->cardmode & SDC_MODE_CARDTYPE_MASK)) {
 800236a:	6b2e      	ldr	r6, [r5, #48]	; 0x30
  *resp = sdcp->sdmmc->RESP1;
 800236c:	6963      	ldr	r3, [r4, #20]
 800236e:	f006 060f 	and.w	r6, r6, #15
 8002372:	2e02      	cmp	r6, #2
 8002374:	f000 80a5 	beq.w	80024c2 <sdcConnect+0x3c2>
  return (data[startidx] & endmask) >> startoff;        /* One piece case.  */
 8002378:	6a6b      	ldr	r3, [r5, #36]	; 0x24
  uint8_t *tmp = sdcp->buf;
 800237a:	6bef      	ldr	r7, [r5, #60]	; 0x3c
  if (0U == _mmcsd_get_slice(sdcp->csd, MMCSD_CSD_10_CSD_STRUCTURE_SLICE)) {
 800237c:	0f9b      	lsrs	r3, r3, #30
 800237e:	d170      	bne.n	8002462 <sdcConnect+0x362>
  if (f >= sdcp->clkfreq) {
 8002380:	6ca9      	ldr	r1, [r5, #72]	; 0x48
 8002382:	4a80      	ldr	r2, [pc, #512]	; (8002584 <sdcConnect+0x484>)
    sdcp->sdmmc->CLKCR = (sdcp->sdmmc->CLKCR & 0xFFFFFF00U) |
 8002384:	6863      	ldr	r3, [r4, #4]
  if (f >= sdcp->clkfreq) {
 8002386:	4291      	cmp	r1, r2
    sdcp->sdmmc->CLKCR = (sdcp->sdmmc->CLKCR & 0xFFFFFF00U) |
 8002388:	f023 03ff 	bic.w	r3, r3, #255	; 0xff
  if (f >= sdcp->clkfreq) {
 800238c:	d906      	bls.n	800239c <sdcConnect+0x29c>
  return (sdcp->clkfreq + (f * 2) - 1) / (f * 2);
 800238e:	4a7e      	ldr	r2, [pc, #504]	; (8002588 <sdcConnect+0x488>)
 8002390:	440a      	add	r2, r1
 8002392:	497e      	ldr	r1, [pc, #504]	; (800258c <sdcConnect+0x48c>)
 8002394:	fba1 1202 	umull	r1, r2, r1, r2
    sdcp->sdmmc->CLKCR = (sdcp->sdmmc->CLKCR & 0xFFFFFF00U) |
 8002398:	ea43 6312 	orr.w	r3, r3, r2, lsr #24
                         sdc_lld_clkdiv(sdcp, 25000000) | SDMMC_CLKCR_PWRSAV;
 800239c:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
  if (SDC_MODE_CARDTYPE_MMC == (sdcp->cardmode & SDC_MODE_CARDTYPE_MASK)) {
 80023a0:	2e02      	cmp	r6, #2
                                sdcp->rca, sdcp->csd)) {
 80023a2:	f105 0018 	add.w	r0, r5, #24
    sdcp->sdmmc->CLKCR = (sdcp->sdmmc->CLKCR & 0xFFFFFF00U) |
 80023a6:	6063      	str	r3, [r4, #4]
  if (SDC_MODE_CARDTYPE_MMC == (sdcp->cardmode & SDC_MODE_CARDTYPE_MASK)) {
 80023a8:	d06c      	beq.n	8002484 <sdcConnect+0x384>
    sdcp->capacity = _mmcsd_get_capacity(sdcp->csd);
 80023aa:	f7fe f8b9 	bl	8000520 <_mmcsd_get_capacity>
  sdcp->sdmmc->ARG = arg;
 80023ae:	6c6c      	ldr	r4, [r5, #68]	; 0x44
 80023b0:	f44f 7100 	mov.w	r1, #512	; 0x200
  sdcp->sdmmc->CMD = (uint32_t)cmd | SDMMC_CMD_WAITRESP_0 | SDMMC_CMD_CPSMEN;
 80023b4:	f241 1210 	movw	r2, #4368	; 0x1110
      sdcp->capacity = _mmcsd_get_capacity_ext(ext_csd);
 80023b8:	62a8      	str	r0, [r5, #40]	; 0x28
  sdcp->sdmmc->ARG = arg;
 80023ba:	60a1      	str	r1, [r4, #8]
  sdcp->sdmmc->CMD = (uint32_t)cmd | SDMMC_CMD_WAITRESP_0 | SDMMC_CMD_CPSMEN;
 80023bc:	60e2      	str	r2, [r4, #12]
  while (((sta = sdcp->sdmmc->STA) & (SDMMC_STA_CMDREND | SDMMC_STA_CTIMEOUT |
 80023be:	6b61      	ldr	r1, [r4, #52]	; 0x34
                                     SDMMC_STA_CCRCFAIL)) == 0)
 80023c0:	f011 0345 	ands.w	r3, r1, #69	; 0x45
 80023c4:	d0fb      	beq.n	80023be <sdcConnect+0x2be>
  if ((sta & (SDMMC_STA_CTIMEOUT | SDMMC_STA_CCRCFAIL)) != 0) {
 80023c6:	f011 0f05 	tst.w	r1, #5
  sdcp->sdmmc->ICR = sta & (SDMMC_STA_CMDREND | SDMMC_STA_CTIMEOUT |
 80023ca:	63a3      	str	r3, [r4, #56]	; 0x38
  if ((sta & (SDMMC_STA_CTIMEOUT | SDMMC_STA_CCRCFAIL)) != 0) {
 80023cc:	f47f af28 	bne.w	8002220 <sdcConnect+0x120>
  *resp = sdcp->sdmmc->RESP1;
 80023d0:	6962      	ldr	r2, [r4, #20]
      MMCSD_R1_ERROR(resp[0])) {
 80023d2:	4b6f      	ldr	r3, [pc, #444]	; (8002590 <sdcConnect+0x490>)
 80023d4:	4013      	ands	r3, r2
                                 MMCSD_BLOCK_SIZE, resp) ||
 80023d6:	2b00      	cmp	r3, #0
 80023d8:	f47f aed2 	bne.w	8002180 <sdcConnect+0x80>
  switch (sdcp->cardmode & SDC_MODE_CARDTYPE_MASK) {
 80023dc:	6b2b      	ldr	r3, [r5, #48]	; 0x30
 80023de:	f013 0f0e 	tst.w	r3, #14
 80023e2:	f003 020f 	and.w	r2, r3, #15
 80023e6:	f040 808f 	bne.w	8002508 <sdcConnect+0x408>
  if (SDC_MODE_1BIT == sdcp->config->bus_width) {
 80023ea:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
 80023ec:	781b      	ldrb	r3, [r3, #0]
 80023ee:	2b00      	cmp	r3, #0
 80023f0:	d030      	beq.n	8002454 <sdcConnect+0x354>
  else if (SDC_MODE_4BIT == sdcp->config->bus_width) {
 80023f2:	2b01      	cmp	r3, #1
 80023f4:	f47f aec4 	bne.w	8002180 <sdcConnect+0x80>
  uint32_t clk = sdcp->sdmmc->CLKCR & ~SDMMC_CLKCR_WIDBUS;
 80023f8:	6863      	ldr	r3, [r4, #4]
  sdcp->sdmmc->CMD = (uint32_t)cmd | SDMMC_CMD_WAITRESP_0 | SDMMC_CMD_CPSMEN;
 80023fa:	f241 1237 	movw	r2, #4407	; 0x1137
    if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_APP_CMD, sdcp->rca, resp) ||
 80023fe:	6ba9      	ldr	r1, [r5, #56]	; 0x38
  uint32_t clk = sdcp->sdmmc->CLKCR & ~SDMMC_CLKCR_WIDBUS;
 8002400:	f423 4340 	bic.w	r3, r3, #49152	; 0xc000
    sdcp->sdmmc->CLKCR = clk | SDMMC_CLKCR_WIDBUS_0;
 8002404:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 8002408:	6063      	str	r3, [r4, #4]
  sdcp->sdmmc->ARG = arg;
 800240a:	60a1      	str	r1, [r4, #8]
  sdcp->sdmmc->CMD = (uint32_t)cmd | SDMMC_CMD_WAITRESP_0 | SDMMC_CMD_CPSMEN;
 800240c:	60e2      	str	r2, [r4, #12]
  while (((sta = sdcp->sdmmc->STA) & (SDMMC_STA_CMDREND | SDMMC_STA_CTIMEOUT |
 800240e:	6b61      	ldr	r1, [r4, #52]	; 0x34
                                     SDMMC_STA_CCRCFAIL)) == 0)
 8002410:	f011 0345 	ands.w	r3, r1, #69	; 0x45
 8002414:	d0fb      	beq.n	800240e <sdcConnect+0x30e>
  if ((sta & (SDMMC_STA_CTIMEOUT | SDMMC_STA_CCRCFAIL)) != 0) {
 8002416:	f011 0f05 	tst.w	r1, #5
  sdcp->sdmmc->ICR = sta & (SDMMC_STA_CMDREND | SDMMC_STA_CTIMEOUT |
 800241a:	63a3      	str	r3, [r4, #56]	; 0x38
  if ((sta & (SDMMC_STA_CTIMEOUT | SDMMC_STA_CCRCFAIL)) != 0) {
 800241c:	f47f af00 	bne.w	8002220 <sdcConnect+0x120>
  *resp = sdcp->sdmmc->RESP1;
 8002420:	6962      	ldr	r2, [r4, #20]
        MMCSD_R1_ERROR(resp[0])) {
 8002422:	4b5b      	ldr	r3, [pc, #364]	; (8002590 <sdcConnect+0x490>)
 8002424:	4013      	ands	r3, r2
    if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_APP_CMD, sdcp->rca, resp) ||
 8002426:	2b00      	cmp	r3, #0
 8002428:	f47f aeaa 	bne.w	8002180 <sdcConnect+0x80>
  sdcp->sdmmc->ARG = arg;
 800242c:	2202      	movs	r2, #2
  sdcp->sdmmc->CMD = (uint32_t)cmd | SDMMC_CMD_WAITRESP_0 | SDMMC_CMD_CPSMEN;
 800242e:	f241 1306 	movw	r3, #4358	; 0x1106
  sdcp->sdmmc->ARG = arg;
 8002432:	60a2      	str	r2, [r4, #8]
  sdcp->sdmmc->CMD = (uint32_t)cmd | SDMMC_CMD_WAITRESP_0 | SDMMC_CMD_CPSMEN;
 8002434:	60e3      	str	r3, [r4, #12]
  while (((sta = sdcp->sdmmc->STA) & (SDMMC_STA_CMDREND | SDMMC_STA_CTIMEOUT |
 8002436:	6b61      	ldr	r1, [r4, #52]	; 0x34
                                     SDMMC_STA_CCRCFAIL)) == 0)
 8002438:	f011 0345 	ands.w	r3, r1, #69	; 0x45
 800243c:	d0fb      	beq.n	8002436 <sdcConnect+0x336>
  if ((sta & (SDMMC_STA_CTIMEOUT | SDMMC_STA_CCRCFAIL)) != 0) {
 800243e:	f011 0f05 	tst.w	r1, #5
  sdcp->sdmmc->ICR = sta & (SDMMC_STA_CMDREND | SDMMC_STA_CTIMEOUT |
 8002442:	63a3      	str	r3, [r4, #56]	; 0x38
  if ((sta & (SDMMC_STA_CTIMEOUT | SDMMC_STA_CCRCFAIL)) != 0) {
 8002444:	f47f aeec 	bne.w	8002220 <sdcConnect+0x120>
  *resp = sdcp->sdmmc->RESP1;
 8002448:	6962      	ldr	r2, [r4, #20]
      MMCSD_R1_ERROR(resp[0])) {
 800244a:	4b51      	ldr	r3, [pc, #324]	; (8002590 <sdcConnect+0x490>)
 800244c:	4013      	ands	r3, r2
  if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_SWITCH, cmdarg, resp) ||
 800244e:	2b00      	cmp	r3, #0
 8002450:	f47f ae96 	bne.w	8002180 <sdcConnect+0x80>
  return HAL_SUCCESS;
 8002454:	2205      	movs	r2, #5
 8002456:	2000      	movs	r0, #0
 8002458:	e697      	b.n	800218a <sdcConnect+0x8a>
    sdc_lld_collect_errors(sdcp, sta);
 800245a:	4628      	mov	r0, r5
 800245c:	f7fe fab0 	bl	80009c0 <sdc_lld_collect_errors>
    return HAL_FAILED;
 8002460:	e6af      	b.n	80021c2 <sdcConnect+0xc2>
  if (sdc_lld_read_special(sdcp, tmp, N, MMCSD_CMD_SWITCH, 0)) {
 8002462:	9000      	str	r0, [sp, #0]
 8002464:	2306      	movs	r3, #6
 8002466:	2240      	movs	r2, #64	; 0x40
 8002468:	4639      	mov	r1, r7
 800246a:	4628      	mov	r0, r5
 800246c:	f7ff fe00 	bl	8002070 <sdc_lld_read_special>
 8002470:	bb28      	cbnz	r0, 80024be <sdcConnect+0x3be>
  if ((sdc_cmd6_extract_info(SD_SWITCH_FUNCTION_SPEED, tmp) & 2U) == 2U) {
 8002472:	89bb      	ldrh	r3, [r7, #12]
 8002474:	ba5b      	rev16	r3, r3
 8002476:	079b      	lsls	r3, r3, #30
 8002478:	d460      	bmi.n	800253c <sdcConnect+0x43c>
  if (SDC_MODE_CARDTYPE_MMC == (sdcp->cardmode & SDC_MODE_CARDTYPE_MASK)) {
 800247a:	6b2e      	ldr	r6, [r5, #48]	; 0x30
 800247c:	6c6c      	ldr	r4, [r5, #68]	; 0x44
 800247e:	f006 060f 	and.w	r6, r6, #15
 8002482:	e77d      	b.n	8002380 <sdcConnect+0x280>
 8002484:	6a6b      	ldr	r3, [r5, #36]	; 0x24
    if (_mmcsd_get_slice(sdcp->csd, MMCSD_CSD_MMC_CSD_STRUCTURE_SLICE) > 1U) {
 8002486:	2b00      	cmp	r3, #0
 8002488:	da8f      	bge.n	80023aa <sdcConnect+0x2aa>
      uint8_t *ext_csd = sdcp->buf;
 800248a:	6bec      	ldr	r4, [r5, #60]	; 0x3c
      if (sdc_lld_read_special(sdcp, ext_csd, 512, MMCSD_CMD_SEND_EXT_CSD, 0)) {
 800248c:	2100      	movs	r1, #0
 800248e:	2308      	movs	r3, #8
 8002490:	f44f 7200 	mov.w	r2, #512	; 0x200
 8002494:	9100      	str	r1, [sp, #0]
 8002496:	4628      	mov	r0, r5
 8002498:	4621      	mov	r1, r4
 800249a:	f7ff fde9 	bl	8002070 <sdc_lld_read_special>
 800249e:	b970      	cbnz	r0, 80024be <sdcConnect+0x3be>
uint32_t _mmcsd_get_capacity_ext(const uint8_t *ext_csd) {

  osalDbgCheck(NULL != ext_csd);

  return ((uint32_t)ext_csd[215] << 24U) +
         ((uint32_t)ext_csd[214] << 16U) +
 80024a0:	f894 30d6 	ldrb.w	r3, [r4, #214]	; 0xd6
  return ((uint32_t)ext_csd[215] << 24U) +
 80024a4:	f894 00d7 	ldrb.w	r0, [r4, #215]	; 0xd7
         ((uint32_t)ext_csd[214] << 16U) +
 80024a8:	041b      	lsls	r3, r3, #16
         ((uint32_t)ext_csd[213] << 8U)  +
         (uint32_t)ext_csd[212];
 80024aa:	f894 10d4 	ldrb.w	r1, [r4, #212]	; 0xd4
         ((uint32_t)ext_csd[213] << 8U)  +
 80024ae:	f894 20d5 	ldrb.w	r2, [r4, #213]	; 0xd5
  return ((uint32_t)ext_csd[215] << 24U) +
 80024b2:	eb03 6300 	add.w	r3, r3, r0, lsl #24
         ((uint32_t)ext_csd[213] << 8U)  +
 80024b6:	440b      	add	r3, r1
 80024b8:	eb03 2002 	add.w	r0, r3, r2, lsl #8
 80024bc:	e777      	b.n	80023ae <sdcConnect+0x2ae>
 80024be:	6c6c      	ldr	r4, [r5, #68]	; 0x44
 80024c0:	e65e      	b.n	8002180 <sdcConnect+0x80>
  sdcp->sdmmc->ARG = arg;
 80024c2:	4a34      	ldr	r2, [pc, #208]	; (8002594 <sdcConnect+0x494>)
  sdcp->sdmmc->CMD = (uint32_t)cmd | SDMMC_CMD_WAITRESP_0 | SDMMC_CMD_CPSMEN;
 80024c4:	f241 1306 	movw	r3, #4358	; 0x1106
  sdcp->sdmmc->ARG = arg;
 80024c8:	60a2      	str	r2, [r4, #8]
  sdcp->sdmmc->CMD = (uint32_t)cmd | SDMMC_CMD_WAITRESP_0 | SDMMC_CMD_CPSMEN;
 80024ca:	60e3      	str	r3, [r4, #12]
  while (((sta = sdcp->sdmmc->STA) & (SDMMC_STA_CMDREND | SDMMC_STA_CTIMEOUT |
 80024cc:	6b61      	ldr	r1, [r4, #52]	; 0x34
                                     SDMMC_STA_CCRCFAIL)) == 0)
 80024ce:	f011 0345 	ands.w	r3, r1, #69	; 0x45
 80024d2:	d0fb      	beq.n	80024cc <sdcConnect+0x3cc>
  if ((sta & (SDMMC_STA_CTIMEOUT | SDMMC_STA_CCRCFAIL)) != 0) {
 80024d4:	f011 0f05 	tst.w	r1, #5
  sdcp->sdmmc->ICR = sta & (SDMMC_STA_CMDREND | SDMMC_STA_CTIMEOUT |
 80024d8:	63a3      	str	r3, [r4, #56]	; 0x38
  if ((sta & (SDMMC_STA_CTIMEOUT | SDMMC_STA_CCRCFAIL)) != 0) {
 80024da:	d12b      	bne.n	8002534 <sdcConnect+0x434>
  *resp = sdcp->sdmmc->RESP1;
 80024dc:	6962      	ldr	r2, [r4, #20]
                                   MMCSD_R1_ERROR(resp[0]))) {
 80024de:	4b2c      	ldr	r3, [pc, #176]	; (8002590 <sdcConnect+0x490>)
 80024e0:	4013      	ands	r3, r2
  if (!(sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_SWITCH, cmdarg, resp) ||
 80024e2:	2b00      	cmp	r3, #0
 80024e4:	f47f af4c 	bne.w	8002380 <sdcConnect+0x280>
 80024e8:	6ca9      	ldr	r1, [r5, #72]	; 0x48
  if (f >= sdcp->clkfreq) {
 80024ea:	4a2b      	ldr	r2, [pc, #172]	; (8002598 <sdcConnect+0x498>)
    sdcp->sdmmc->CLKCR = (sdcp->sdmmc->CLKCR & 0xFFFFFF00U) |
 80024ec:	6863      	ldr	r3, [r4, #4]
  if (f >= sdcp->clkfreq) {
 80024ee:	4291      	cmp	r1, r2
    sdcp->sdmmc->CLKCR = (sdcp->sdmmc->CLKCR & 0xFFFFFF00U) |
 80024f0:	f023 03ff 	bic.w	r3, r3, #255	; 0xff
  if (f >= sdcp->clkfreq) {
 80024f4:	f67f af52 	bls.w	800239c <sdcConnect+0x29c>
  return (sdcp->clkfreq + (f * 2) - 1) / (f * 2);
 80024f8:	4a28      	ldr	r2, [pc, #160]	; (800259c <sdcConnect+0x49c>)
 80024fa:	440a      	add	r2, r1
 80024fc:	4923      	ldr	r1, [pc, #140]	; (800258c <sdcConnect+0x48c>)
 80024fe:	fba1 1202 	umull	r1, r2, r1, r2
    sdcp->sdmmc->CLKCR = (sdcp->sdmmc->CLKCR & 0xFFFFFF00U) |
 8002502:	ea43 6352 	orr.w	r3, r3, r2, lsr #25
  return (sdcp->clkfreq + (f * 2) - 1) / (f * 2);
 8002506:	e749      	b.n	800239c <sdcConnect+0x29c>
  switch (sdcp->cardmode & SDC_MODE_CARDTYPE_MASK) {
 8002508:	2a02      	cmp	r2, #2
 800250a:	f47f ae39 	bne.w	8002180 <sdcConnect+0x80>
  switch (sdcp->config->bus_width) {
 800250e:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
 8002510:	781b      	ldrb	r3, [r3, #0]
 8002512:	2b01      	cmp	r3, #1
 8002514:	d02e      	beq.n	8002574 <sdcConnect+0x474>
 8002516:	2b02      	cmp	r3, #2
 8002518:	d024      	beq.n	8002564 <sdcConnect+0x464>
 800251a:	2b00      	cmp	r3, #0
 800251c:	d09a      	beq.n	8002454 <sdcConnect+0x354>
  uint32_t clk = sdcp->sdmmc->CLKCR & ~SDMMC_CLKCR_WIDBUS;
 800251e:	6863      	ldr	r3, [r4, #4]
  uint32_t cmdarg = mmc_cmd6_construct(MMC_SWITCH_WRITE_BYTE, 183, 0, 0);
 8002520:	4a1f      	ldr	r2, [pc, #124]	; (80025a0 <sdcConnect+0x4a0>)
  sdcp->sdmmc->CMD = (uint32_t)cmd | SDMMC_CMD_WAITRESP_0 | SDMMC_CMD_CPSMEN;
 8002522:	f241 1306 	movw	r3, #4358	; 0x1106
  sdcp->sdmmc->ARG = arg;
 8002526:	60a2      	str	r2, [r4, #8]
  sdcp->sdmmc->CMD = (uint32_t)cmd | SDMMC_CMD_WAITRESP_0 | SDMMC_CMD_CPSMEN;
 8002528:	60e3      	str	r3, [r4, #12]
  while (((sta = sdcp->sdmmc->STA) & (SDMMC_STA_CMDREND | SDMMC_STA_CTIMEOUT |
 800252a:	6b61      	ldr	r1, [r4, #52]	; 0x34
                                     SDMMC_STA_CCRCFAIL)) == 0)
 800252c:	f011 0345 	ands.w	r3, r1, #69	; 0x45
 8002530:	d0fb      	beq.n	800252a <sdcConnect+0x42a>
 8002532:	e784      	b.n	800243e <sdcConnect+0x33e>
    sdc_lld_collect_errors(sdcp, sta);
 8002534:	4628      	mov	r0, r5
 8002536:	f7fe fa43 	bl	80009c0 <sdc_lld_collect_errors>
    return HAL_FAILED;
 800253a:	e721      	b.n	8002380 <sdcConnect+0x280>
    if (sdc_lld_read_special(sdcp, tmp, N, MMCSD_CMD_SWITCH, cmdarg)) {
 800253c:	4919      	ldr	r1, [pc, #100]	; (80025a4 <sdcConnect+0x4a4>)
 800253e:	2306      	movs	r3, #6
 8002540:	2240      	movs	r2, #64	; 0x40
 8002542:	4628      	mov	r0, r5
 8002544:	9100      	str	r1, [sp, #0]
 8002546:	4639      	mov	r1, r7
 8002548:	f7ff fd92 	bl	8002070 <sdc_lld_read_special>
 800254c:	2800      	cmp	r0, #0
 800254e:	d1b6      	bne.n	80024be <sdcConnect+0x3be>
        (uint32_t)buf[16];
 8002550:	7c3b      	ldrb	r3, [r7, #16]
  if (SDC_MODE_CARDTYPE_MMC == (sdcp->cardmode & SDC_MODE_CARDTYPE_MASK)) {
 8002552:	6b2e      	ldr	r6, [r5, #48]	; 0x30
  status = (tmp >> ((uint32_t)function * 4U)) & 0xFU;
 8002554:	f003 030f 	and.w	r3, r3, #15
 8002558:	6c6c      	ldr	r4, [r5, #68]	; 0x44
  if (SDC_MODE_CARDTYPE_MMC == (sdcp->cardmode & SDC_MODE_CARDTYPE_MASK)) {
 800255a:	f006 060f 	and.w	r6, r6, #15
  if (0xFU != status) {
 800255e:	2b0f      	cmp	r3, #15
 8002560:	d1c2      	bne.n	80024e8 <sdcConnect+0x3e8>
 8002562:	e70d      	b.n	8002380 <sdcConnect+0x280>
  uint32_t clk = sdcp->sdmmc->CLKCR & ~SDMMC_CLKCR_WIDBUS;
 8002564:	6863      	ldr	r3, [r4, #4]
    cmdarg = mmc_cmd6_construct(MMC_SWITCH_WRITE_BYTE, 183, 2, 0);
 8002566:	4a10      	ldr	r2, [pc, #64]	; (80025a8 <sdcConnect+0x4a8>)
 8002568:	f423 4340 	bic.w	r3, r3, #49152	; 0xc000
    sdcp->sdmmc->CLKCR = clk | SDMMC_CLKCR_WIDBUS_1;
 800256c:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8002570:	6063      	str	r3, [r4, #4]
    break;
 8002572:	e7d6      	b.n	8002522 <sdcConnect+0x422>
  uint32_t clk = sdcp->sdmmc->CLKCR & ~SDMMC_CLKCR_WIDBUS;
 8002574:	6863      	ldr	r3, [r4, #4]
    cmdarg = mmc_cmd6_construct(MMC_SWITCH_WRITE_BYTE, 183, 1, 0);
 8002576:	4a0d      	ldr	r2, [pc, #52]	; (80025ac <sdcConnect+0x4ac>)
 8002578:	f423 4340 	bic.w	r3, r3, #49152	; 0xc000
    sdcp->sdmmc->CLKCR = clk | SDMMC_CLKCR_WIDBUS_0;
 800257c:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 8002580:	6063      	str	r3, [r4, #4]
    break;
 8002582:	e7ce      	b.n	8002522 <sdcConnect+0x422>
 8002584:	017d7840 	.word	0x017d7840
 8002588:	02faf07f 	.word	0x02faf07f
 800258c:	55e63b89 	.word	0x55e63b89
 8002590:	fdffe008 	.word	0xfdffe008
 8002594:	03b90100 	.word	0x03b90100
 8002598:	02faf080 	.word	0x02faf080
 800259c:	05f5e0ff 	.word	0x05f5e0ff
 80025a0:	03b70000 	.word	0x03b70000
 80025a4:	80fffff1 	.word	0x80fffff1
 80025a8:	03b70200 	.word	0x03b70200
 80025ac:	03b70100 	.word	0x03b70100

080025b0 <usb_event>:
  switch (event) {
 80025b0:	2902      	cmp	r1, #2
static void usb_event(USBDriver *usbp, usbevent_t event) {
 80025b2:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80025b4:	460c      	mov	r4, r1
  switch (event) {
 80025b6:	d00f      	beq.n	80025d8 <usb_event+0x28>
 80025b8:	d90b      	bls.n	80025d2 <usb_event+0x22>
 80025ba:	1ecc      	subs	r4, r1, #3
 80025bc:	2c01      	cmp	r4, #1
 80025be:	d807      	bhi.n	80025d0 <usb_event+0x20>
 80025c0:	2330      	movs	r3, #48	; 0x30
 80025c2:	f383 8811 	msr	BASEPRI, r3
      usb_midi_tx_ready = false;
 80025c6:	4a23      	ldr	r2, [pc, #140]	; (8002654 <usb_event+0xa4>)
 80025c8:	2300      	movs	r3, #0
 80025ca:	7013      	strb	r3, [r2, #0]
 80025cc:	f383 8811 	msr	BASEPRI, r3
}
 80025d0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  switch (event) {
 80025d2:	2900      	cmp	r1, #0
 80025d4:	d0f4      	beq.n	80025c0 <usb_event+0x10>
}
 80025d6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80025d8:	4605      	mov	r5, r0
 80025da:	2330      	movs	r3, #48	; 0x30
 80025dc:	f383 8811 	msr	BASEPRI, r3
  usbp->epc[ep] = epcp;
 80025e0:	4b1d      	ldr	r3, [pc, #116]	; (8002658 <usb_event+0xa8>)
    memset(epcp->out_state, 0, sizeof(USBOutEndpointState));
 80025e2:	2600      	movs	r6, #0
 80025e4:	4f1d      	ldr	r7, [pc, #116]	; (800265c <usb_event+0xac>)
  usb_lld_init_endpoint(usbp, ep);
 80025e6:	2101      	movs	r1, #1
  usbp->epc[ep] = epcp;
 80025e8:	6103      	str	r3, [r0, #16]
    memset(epcp->out_state, 0, sizeof(USBOutEndpointState));
 80025ea:	e9c7 6600 	strd	r6, r6, [r7]
 80025ee:	e9c7 6602 	strd	r6, r6, [r7, #8]
  usb_lld_init_endpoint(usbp, ep);
 80025f2:	f7fd ffe5 	bl	80005c0 <usb_lld_init_endpoint>
  usbp->epc[ep] = epcp;
 80025f6:	4b1a      	ldr	r3, [pc, #104]	; (8002660 <usb_event+0xb0>)
  usb_lld_init_endpoint(usbp, ep);
 80025f8:	4621      	mov	r1, r4
 80025fa:	4628      	mov	r0, r5
  usbp->epc[ep] = epcp;
 80025fc:	616b      	str	r3, [r5, #20]
    memset(epcp->in_state, 0, sizeof(USBInEndpointState));
 80025fe:	4b19      	ldr	r3, [pc, #100]	; (8002664 <usb_event+0xb4>)
 8002600:	e9c3 6600 	strd	r6, r6, [r3]
 8002604:	e9c3 6602 	strd	r6, r6, [r3, #8]
  usb_lld_init_endpoint(usbp, ep);
 8002608:	f7fd ffda 	bl	80005c0 <usb_lld_init_endpoint>
  usbp->receiving |= (uint16_t)((unsigned)1U << (unsigned)ep);
 800260c:	896b      	ldrh	r3, [r5, #10]
  osp->rxbuf  = buf;
 800260e:	4a16      	ldr	r2, [pc, #88]	; (8002668 <usb_event+0xb8>)
  usb_lld_start_out(usbp, ep);
 8002610:	4628      	mov	r0, r5
  usbp->receiving |= (uint16_t)((unsigned)1U << (unsigned)ep);
 8002612:	f043 0302 	orr.w	r3, r3, #2
  usb_lld_start_out(usbp, ep);
 8002616:	2101      	movs	r1, #1
  osp->rxcnt  = 0;
 8002618:	607e      	str	r6, [r7, #4]
  usbp->receiving |= (uint16_t)((unsigned)1U << (unsigned)ep);
 800261a:	816b      	strh	r3, [r5, #10]
  osp->rxsize = n;
 800261c:	2340      	movs	r3, #64	; 0x40
  osp->rxbuf  = buf;
 800261e:	60ba      	str	r2, [r7, #8]
  osp->rxsize = n;
 8002620:	603b      	str	r3, [r7, #0]
  usb_lld_start_out(usbp, ep);
 8002622:	f7fe f86d 	bl	8000700 <usb_lld_start_out>
 8002626:	4a11      	ldr	r2, [pc, #68]	; (800266c <usb_event+0xbc>)
      usb_midi_tx_ready = true;
 8002628:	2001      	movs	r0, #1
 800262a:	490a      	ldr	r1, [pc, #40]	; (8002654 <usb_event+0xa4>)
 800262c:	6893      	ldr	r3, [r2, #8]
 800262e:	7008      	strb	r0, [r1, #0]
 8002630:	42b3      	cmp	r3, r6
 8002632:	dd03      	ble.n	800263c <usb_event+0x8c>
 8002634:	2300      	movs	r3, #0
 8002636:	f383 8811 	msr	BASEPRI, r3
}
 800263a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  if (++sp->cnt <= (cnt_t)0) {
 800263c:	4403      	add	r3, r0
 800263e:	4283      	cmp	r3, r0
 8002640:	6093      	str	r3, [r2, #8]
 8002642:	d0f7      	beq.n	8002634 <usb_event+0x84>
  ch_queue_t *p = qp->next;
 8002644:	6810      	ldr	r0, [r2, #0]
  qp->next       = p->next;
 8002646:	6803      	ldr	r3, [r0, #0]
  qp->next->prev = qp;
 8002648:	605a      	str	r2, [r3, #4]
  qp->next       = p->next;
 800264a:	6013      	str	r3, [r2, #0]
    tp->u.rdymsg = MSG_OK;
 800264c:	6286      	str	r6, [r0, #40]	; 0x28
  return __sch_ready_behind(tp);
 800264e:	f7fe fc07 	bl	8000e60 <__sch_ready_behind.isra.0>
 8002652:	e7ef      	b.n	8002634 <usb_event+0x84>
 8002654:	2400153c 	.word	0x2400153c
 8002658:	08005dcc 	.word	0x08005dcc
 800265c:	24000e04 	.word	0x24000e04
 8002660:	08005df0 	.word	0x08005df0
 8002664:	24000e14 	.word	0x24000e14
 8002668:	240014c0 	.word	0x240014c0
 800266c:	2400152c 	.word	0x2400152c

08002670 <__cpu_init>:
 */
#if !defined(__DOXYGEN__)
__attribute__((weak))
#endif
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __cpu_init(void) {
 8002670:	b510      	push	{r4, lr}
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__STATIC_FORCEINLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
 8002672:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 8002676:	f3bf 8f6f 	isb	sy
__STATIC_INLINE void SCB_EnableICache (void)
{
  #if defined (__ICACHE_PRESENT) && (__ICACHE_PRESENT == 1U)
    __DSB();
    __ISB();
    SCB->ICIALLU = 0UL;                     /* invalidate I-Cache */
 800267a:	481c      	ldr	r0, [pc, #112]	; (80026ec <__cpu_init+0x7c>)
 800267c:	2200      	movs	r2, #0
 800267e:	f8c0 2250 	str.w	r2, [r0, #592]	; 0x250
  __ASM volatile ("dsb 0xF":::"memory");
 8002682:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 8002686:	f3bf 8f6f 	isb	sy
    __DSB();
    __ISB();
    SCB->CCR |=  (uint32_t)SCB_CCR_IC_Msk;  /* enable I-Cache */
 800268a:	6943      	ldr	r3, [r0, #20]
 800268c:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 8002690:	6143      	str	r3, [r0, #20]
  __ASM volatile ("dsb 0xF":::"memory");
 8002692:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 8002696:	f3bf 8f6f 	isb	sy
  #if defined (__DCACHE_PRESENT) && (__DCACHE_PRESENT == 1U)
    uint32_t ccsidr;
    uint32_t sets;
    uint32_t ways;

    SCB->CSSELR = 0U; /*(0U << 1U) | 0U;*/  /* Level 1 data cache */
 800269a:	f8c0 2084 	str.w	r2, [r0, #132]	; 0x84
  __ASM volatile ("dsb 0xF":::"memory");
 800269e:	f3bf 8f4f 	dsb	sy
    __DSB();

    ccsidr = SCB->CCSIDR;
 80026a2:	f8d0 3080 	ldr.w	r3, [r0, #128]	; 0x80
                                            /* invalidate D-Cache */
    sets = (uint32_t)(CCSIDR_SETS(ccsidr));
    do {
      ways = (uint32_t)(CCSIDR_WAYS(ccsidr));
      do {
        SCB->DCISW = (((sets << SCB_DCISW_SET_Pos) & SCB_DCISW_SET_Msk) |
 80026a6:	f643 74e0 	movw	r4, #16352	; 0x3fe0
    sets = (uint32_t)(CCSIDR_SETS(ccsidr));
 80026aa:	f3c3 3c4e 	ubfx	ip, r3, #13, #15
      ways = (uint32_t)(CCSIDR_WAYS(ccsidr));
 80026ae:	f3c3 0ec9 	ubfx	lr, r3, #3, #10
 80026b2:	ea4f 1c4c 	mov.w	ip, ip, lsl #5
        SCB->DCISW = (((sets << SCB_DCISW_SET_Pos) & SCB_DCISW_SET_Msk) |
 80026b6:	ea0c 0104 	and.w	r1, ip, r4
      ways = (uint32_t)(CCSIDR_WAYS(ccsidr));
 80026ba:	4673      	mov	r3, lr
        SCB->DCISW = (((sets << SCB_DCISW_SET_Pos) & SCB_DCISW_SET_Msk) |
 80026bc:	ea41 7283 	orr.w	r2, r1, r3, lsl #30
                      ((ways << SCB_DCISW_WAY_Pos) & SCB_DCISW_WAY_Msk)  );
        #if defined ( __CC_ARM )
          __schedule_barrier();
        #endif
      } while (ways-- != 0U);
 80026c0:	3b01      	subs	r3, #1
        SCB->DCISW = (((sets << SCB_DCISW_SET_Pos) & SCB_DCISW_SET_Msk) |
 80026c2:	f8c0 2260 	str.w	r2, [r0, #608]	; 0x260
      } while (ways-- != 0U);
 80026c6:	1c5a      	adds	r2, r3, #1
 80026c8:	d1f8      	bne.n	80026bc <__cpu_init+0x4c>
    } while(sets-- != 0U);
 80026ca:	f1ac 0c20 	sub.w	ip, ip, #32
 80026ce:	f11c 0f20 	cmn.w	ip, #32
 80026d2:	d1f0      	bne.n	80026b6 <__cpu_init+0x46>
 80026d4:	f3bf 8f4f 	dsb	sy
    __DSB();

    SCB->CCR |=  (uint32_t)SCB_CCR_DC_Msk;  /* enable D-Cache */
 80026d8:	6943      	ldr	r3, [r0, #20]
 80026da:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 80026de:	6143      	str	r3, [r0, #20]
 80026e0:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 80026e4:	f3bf 8f6f 	isb	sy

#if CORTEX_MODEL == 7
  SCB_EnableICache();
  SCB_EnableDCache();
#endif
}
 80026e8:	bd10      	pop	{r4, pc}
 80026ea:	bf00      	nop
 80026ec:	e000ed00 	.word	0xe000ed00

080026f0 <__late_init>:
 */
#if !defined(__DOXYGEN__)
__attribute__((weak))
#endif
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __late_init(void) {}
 80026f0:	4770      	bx	lr
 80026f2:	bf00      	nop
	...

08002700 <__default_exit>:
#endif
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __default_exit(void) {
/*lint -restore*/

  while (true) {
 8002700:	e7fe      	b.n	8002700 <__default_exit>
 8002702:	bf00      	nop
	...

08002710 <__init_ram_areas>:
#endif

/**
 * @brief   Performs the initialization of the various RAM areas.
 */
void __init_ram_areas(void) {
 8002710:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8002712:	4d15      	ldr	r5, [pc, #84]	; (8002768 <__init_ram_areas+0x58>)
 8002714:	4f15      	ldr	r7, [pc, #84]	; (800276c <__init_ram_areas+0x5c>)
 8002716:	4916      	ldr	r1, [pc, #88]	; (8002770 <__init_ram_areas+0x60>)
 8002718:	f105 0470 	add.w	r4, r5, #112	; 0x70
 800271c:	4815      	ldr	r0, [pc, #84]	; (8002774 <__init_ram_areas+0x64>)
 800271e:	4a16      	ldr	r2, [pc, #88]	; (8002778 <__init_ram_areas+0x68>)
  do {
    uint32_t *tp = rap->init_text_area;
    uint32_t *p = rap->init_area;

    /* Copying initialization data.*/
    while (p < rap->clear_area) {
 8002720:	4281      	cmp	r1, r0
 8002722:	d90d      	bls.n	8002740 <__init_ram_areas+0x30>
 8002724:	3a04      	subs	r2, #4
 8002726:	4603      	mov	r3, r0
      *p = *tp;
 8002728:	f852 6f04 	ldr.w	r6, [r2, #4]!
 800272c:	f843 6b04 	str.w	r6, [r3], #4
    while (p < rap->clear_area) {
 8002730:	4299      	cmp	r1, r3
 8002732:	d8f9      	bhi.n	8002728 <__init_ram_areas+0x18>
      p++;
 8002734:	1e4b      	subs	r3, r1, #1
 8002736:	1a1b      	subs	r3, r3, r0
 8002738:	f023 0303 	bic.w	r3, r3, #3
 800273c:	3304      	adds	r3, #4
 800273e:	4418      	add	r0, r3
      tp++;
    }

    /* Zeroing clear area.*/
    while (p < rap->no_init_area) {
 8002740:	4287      	cmp	r7, r0
 8002742:	d907      	bls.n	8002754 <__init_ram_areas+0x44>
      *p = 0;
 8002744:	3f01      	subs	r7, #1
 8002746:	2100      	movs	r1, #0
 8002748:	1a3f      	subs	r7, r7, r0
 800274a:	f027 0203 	bic.w	r2, r7, #3
 800274e:	3204      	adds	r2, #4
 8002750:	f003 f8c8 	bl	80058e4 <memset>
      p++;
    }
    rap++;
  }
  while (rap < &ram_areas[CRT0_AREAS_NUMBER]);
 8002754:	42a5      	cmp	r5, r4
 8002756:	d005      	beq.n	8002764 <__init_ram_areas+0x54>
    uint32_t *p = rap->init_area;
 8002758:	e9d5 2004 	ldrd	r2, r0, [r5, #16]
    while (p < rap->no_init_area) {
 800275c:	e9d5 1706 	ldrd	r1, r7, [r5, #24]
 8002760:	3510      	adds	r5, #16
 8002762:	e7dd      	b.n	8002720 <__init_ram_areas+0x10>
#endif
}
 8002764:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8002766:	bf00      	nop
 8002768:	08005e24 	.word	0x08005e24
 800276c:	24001830 	.word	0x24001830
 8002770:	24001830 	.word	0x24001830
 8002774:	24001830 	.word	0x24001830
 8002778:	08005f64 	.word	0x08005f64
 800277c:	00000000 	.word	0x00000000

08002780 <Vector104>:
/**
 * @brief   SDMMC1 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_SDMMC1_HANDLER) {
 8002780:	b538      	push	{r3, r4, r5, lr}
 * @notapi
 */
void __trace_isr_enter(const char *isr) {
  os_instance_t *oip = currcore;

  if ((oip->trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 8002782:	4d1f      	ldr	r5, [pc, #124]	; (8002800 <Vector104+0x80>)
 8002784:	f8b5 3088 	ldrh.w	r3, [r5, #136]	; 0x88
 8002788:	f013 0404 	ands.w	r4, r3, #4
 800278c:	d018      	beq.n	80027c0 <Vector104+0x40>
 */
void sdc_lld_serve_interrupt(SDCDriver *sdcp) {

  /* Disables the source but the status flags are not reset because the
     read/write functions needs to check them.*/
  sdcp->sdmmc->MASK = 0;
 800278e:	4b1d      	ldr	r3, [pc, #116]	; (8002804 <Vector104+0x84>)
 8002790:	2200      	movs	r2, #0
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8002792:	2130      	movs	r1, #48	; 0x30
 8002794:	6c58      	ldr	r0, [r3, #68]	; 0x44
 8002796:	63c2      	str	r2, [r0, #60]	; 0x3c
 8002798:	f381 8811 	msr	BASEPRI, r1
  if (*trp != NULL) {
 800279c:	6c18      	ldr	r0, [r3, #64]	; 0x40
 800279e:	b118      	cbz	r0, 80027a8 <Vector104+0x28>
    *trp = NULL;
 80027a0:	641a      	str	r2, [r3, #64]	; 0x40
    tp->u.rdymsg = msg;
 80027a2:	6282      	str	r2, [r0, #40]	; 0x28
 80027a4:	f7fe fb5c 	bl	8000e60 <__sch_ready_behind.isra.0>
 80027a8:	2300      	movs	r3, #0
 80027aa:	f383 8811 	msr	BASEPRI, r3
 * @notapi
 */
void __trace_isr_leave(const char *isr) {
  os_instance_t *oip = currcore;

  if ((oip->trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 80027ae:	f8b5 3088 	ldrh.w	r3, [r5, #136]	; 0x88
 80027b2:	f013 0404 	ands.w	r4, r3, #4
 80027b6:	d011      	beq.n	80027dc <Vector104+0x5c>
  sdc_lld_serve_interrupt(&SDCD1);
#endif
#endif

  OSAL_IRQ_EPILOGUE();
}
 80027b8:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  OSAL_IRQ_EPILOGUE();
 80027bc:	f7fe b998 	b.w	8000af0 <__port_irq_epilogue>
 80027c0:	2330      	movs	r3, #48	; 0x30
 80027c2:	f383 8811 	msr	BASEPRI, r3
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 80027c6:	2103      	movs	r1, #3
 80027c8:	f8d5 308c 	ldr.w	r3, [r5, #140]	; 0x8c
    oip->trace_buffer.ptr->u.isr.name  = isr;
 80027cc:	4a0e      	ldr	r2, [pc, #56]	; (8002808 <Vector104+0x88>)
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 80027ce:	7019      	strb	r1, [r3, #0]
    oip->trace_buffer.ptr->u.isr.name  = isr;
 80027d0:	609a      	str	r2, [r3, #8]
    trace_next(oip);
 80027d2:	f7fe facd 	bl	8000d70 <trace_next.constprop.0>
 80027d6:	f384 8811 	msr	BASEPRI, r4
}
 80027da:	e7d8      	b.n	800278e <Vector104+0xe>
 80027dc:	2330      	movs	r3, #48	; 0x30
 80027de:	f383 8811 	msr	BASEPRI, r3
    port_lock_from_isr();
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 80027e2:	2104      	movs	r1, #4
 80027e4:	f8d5 308c 	ldr.w	r3, [r5, #140]	; 0x8c
    oip->trace_buffer.ptr->state       = 0U;
    oip->trace_buffer.ptr->u.isr.name  = isr;
 80027e8:	4a07      	ldr	r2, [pc, #28]	; (8002808 <Vector104+0x88>)
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 80027ea:	7019      	strb	r1, [r3, #0]
    oip->trace_buffer.ptr->u.isr.name  = isr;
 80027ec:	609a      	str	r2, [r3, #8]
    trace_next(oip);
 80027ee:	f7fe fabf 	bl	8000d70 <trace_next.constprop.0>
 80027f2:	f384 8811 	msr	BASEPRI, r4
}
 80027f6:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  OSAL_IRQ_EPILOGUE();
 80027fa:	f7fe b979 	b.w	8000af0 <__port_irq_epilogue>
 80027fe:	bf00      	nop
 8002800:	24000330 	.word	0x24000330
 8002804:	240000d0 	.word	0x240000d0
 8002808:	08005a74 	.word	0x08005a74
 800280c:	00000000 	.word	0x00000000

08002810 <VectorDC>:
/**
 * @brief   USART3 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_USART3_HANDLER) {
 8002810:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  if ((oip->trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 8002814:	f8df 9200 	ldr.w	r9, [pc, #512]	; 8002a18 <VectorDC+0x208>
 8002818:	f8b9 3088 	ldrh.w	r3, [r9, #136]	; 0x88
 800281c:	f013 0404 	ands.w	r4, r3, #4
 8002820:	f000 80e0 	beq.w	80029e4 <VectorDC+0x1d4>
 * @brief   Common IRQ handler.
 *
 * @param[in] sdp       communication channel associated to the USART
 */
void sd_lld_serve_interrupt(SerialDriver *sdp) {
  USART_TypeDef *u = sdp->usart;
 8002824:	4c7d      	ldr	r4, [pc, #500]	; (8002a1c <VectorDC+0x20c>)
 8002826:	f8d4 b054 	ldr.w	fp, [r4, #84]	; 0x54
  uint32_t cr1 = u->CR1;
 800282a:	f8db a000 	ldr.w	sl, [fp]
  uint32_t isr;

  /* Reading and clearing status.*/
  isr = u->ISR;
 800282e:	f8db 501c 	ldr.w	r5, [fp, #28]
  u->ICR = isr;

  /* Error condition detection.*/
  if (isr & (USART_ISR_ORE | USART_ISR_NE | USART_ISR_FE  | USART_ISR_PE))
 8002832:	072b      	lsls	r3, r5, #28
  u->ICR = isr;
 8002834:	f8cb 5020 	str.w	r5, [fp, #32]
  if (isr & (USART_ISR_ORE | USART_ISR_NE | USART_ISR_FE  | USART_ISR_PE))
 8002838:	f040 80ba 	bne.w	80029b0 <VectorDC+0x1a0>
    set_error(sdp, isr);

  /* Special case, LIN break detection.*/
  if (isr & USART_ISR_LBDF) {
 800283c:	05ea      	lsls	r2, r5, #23
 800283e:	f100 80ac 	bmi.w	800299a <VectorDC+0x18a>
  /* Data available, note it is a while in order to handle two situations:
     1) Another byte arrived after removing the previous one, this would cause
        an extra interrupt to serve.
     2) FIFO mode is enabled on devices that support it, we need to empty
        the FIFO.*/
  while (isr & USART_ISR_RXNE) {
 8002842:	06a8      	lsls	r0, r5, #26
 8002844:	d541      	bpl.n	80028ca <VectorDC+0xba>
 8002846:	f04f 0830 	mov.w	r8, #48	; 0x30
  if (ch_queue_notempty(&tqp->queue)) {
 800284a:	4f75      	ldr	r7, [pc, #468]	; (8002a20 <VectorDC+0x210>)
  tp->u.rdymsg = msg;
 800284c:	2600      	movs	r6, #0
 800284e:	e01e      	b.n	800288e <VectorDC+0x7e>
  if (!iqIsFullI(iqp)) {
 8002850:	e9d4 3208 	ldrd	r3, r2, [r4, #32]
 8002854:	4293      	cmp	r3, r2
 8002856:	d02b      	beq.n	80028b0 <VectorDC+0xa0>
    iqp->q_counter++;
 8002858:	6962      	ldr	r2, [r4, #20]
    *iqp->q_wrptr++ = b;
 800285a:	1c59      	adds	r1, r3, #1
    iqp->q_counter++;
 800285c:	3201      	adds	r2, #1
    *iqp->q_wrptr++ = b;
 800285e:	6221      	str	r1, [r4, #32]
    iqp->q_counter++;
 8002860:	6162      	str	r2, [r4, #20]
    *iqp->q_wrptr++ = b;
 8002862:	701d      	strb	r5, [r3, #0]
    if (iqp->q_wrptr >= iqp->q_top) {
 8002864:	e9d4 3207 	ldrd	r3, r2, [r4, #28]
 8002868:	429a      	cmp	r2, r3
 800286a:	d301      	bcc.n	8002870 <VectorDC+0x60>
      iqp->q_wrptr = iqp->q_buffer;
 800286c:	69a3      	ldr	r3, [r4, #24]
 800286e:	6223      	str	r3, [r4, #32]
  return (bool)(qp->next != qp);
 8002870:	68e0      	ldr	r0, [r4, #12]
 8002872:	42b8      	cmp	r0, r7
 8002874:	d005      	beq.n	8002882 <VectorDC+0x72>
  qp->next       = p->next;
 8002876:	6803      	ldr	r3, [r0, #0]
 8002878:	60e3      	str	r3, [r4, #12]
  qp->next->prev = qp;
 800287a:	605f      	str	r7, [r3, #4]
 800287c:	6286      	str	r6, [r0, #40]	; 0x28
 800287e:	f7fe faef 	bl	8000e60 <__sch_ready_behind.isra.0>
 8002882:	f386 8811 	msr	BASEPRI, r6
    osalSysLockFromISR();
    sdIncomingDataI(sdp, (uint8_t)u->RDR & sdp->rxmask);
    osalSysUnlockFromISR();

    isr = u->ISR;
 8002886:	f8db 501c 	ldr.w	r5, [fp, #28]
  while (isr & USART_ISR_RXNE) {
 800288a:	06ab      	lsls	r3, r5, #26
 800288c:	d51d      	bpl.n	80028ca <VectorDC+0xba>
 800288e:	f388 8811 	msr	BASEPRI, r8
    sdIncomingDataI(sdp, (uint8_t)u->RDR & sdp->rxmask);
 8002892:	f8db 2024 	ldr.w	r2, [fp, #36]	; 0x24
 8002896:	f894 505c 	ldrb.w	r5, [r4, #92]	; 0x5c
void sdIncomingDataI(SerialDriver *sdp, uint8_t b) {

  osalDbgCheckClassI();
  osalDbgCheck(sdp != NULL);

  if (iqIsEmptyI(&sdp->iqueue))
 800289a:	6963      	ldr	r3, [r4, #20]
 800289c:	4015      	ands	r5, r2
 800289e:	2b00      	cmp	r3, #0
 80028a0:	d1d6      	bne.n	8002850 <VectorDC+0x40>
 * @iclass
 */
static inline void osalEventBroadcastFlagsI(event_source_t *esp,
                                            eventflags_t flags) {

  chEvtBroadcastFlagsI(esp, flags);
 80028a2:	2004      	movs	r0, #4
 80028a4:	f7fe fc84 	bl	80011b0 <chEvtBroadcastFlagsI.constprop.0>
  if (!iqIsFullI(iqp)) {
 80028a8:	e9d4 3208 	ldrd	r3, r2, [r4, #32]
 80028ac:	4293      	cmp	r3, r2
 80028ae:	d1d3      	bne.n	8002858 <VectorDC+0x48>
 80028b0:	6962      	ldr	r2, [r4, #20]
 80028b2:	2a00      	cmp	r2, #0
 80028b4:	d0d0      	beq.n	8002858 <VectorDC+0x48>
 80028b6:	f44f 6000 	mov.w	r0, #2048	; 0x800
 80028ba:	f7fe fc79 	bl	80011b0 <chEvtBroadcastFlagsI.constprop.0>
 80028be:	f386 8811 	msr	BASEPRI, r6
    isr = u->ISR;
 80028c2:	f8db 501c 	ldr.w	r5, [fp, #28]
  while (isr & USART_ISR_RXNE) {
 80028c6:	06ab      	lsls	r3, r5, #26
 80028c8:	d4e1      	bmi.n	800288e <VectorDC+0x7e>
     situations:
     1) The data registers has been emptied immediately after writing it, this
        would cause an extra interrupt to serve.
     2) FIFO mode is enabled on devices that support it, we need to fill
        the FIFO.*/
  if (cr1 & USART_CR1_TXEIE) {
 80028ca:	f01a 0f80 	tst.w	sl, #128	; 0x80
 80028ce:	d036      	beq.n	800293e <VectorDC+0x12e>
    while (isr & USART_ISR_TXE) {
 80028d0:	0629      	lsls	r1, r5, #24
 80028d2:	d534      	bpl.n	800293e <VectorDC+0x12e>
 80028d4:	f04f 0830 	mov.w	r8, #48	; 0x30
 80028d8:	4e52      	ldr	r6, [pc, #328]	; (8002a24 <VectorDC+0x214>)
 80028da:	2700      	movs	r7, #0
 80028dc:	e01c      	b.n	8002918 <VectorDC+0x108>
    oqp->q_counter++;
 80028de:	6ba1      	ldr	r1, [r4, #56]	; 0x38
    b = *oqp->q_rdptr++;
 80028e0:	1c58      	adds	r0, r3, #1
    if (oqp->q_rdptr >= oqp->q_top) {
 80028e2:	6c22      	ldr	r2, [r4, #64]	; 0x40
    oqp->q_counter++;
 80028e4:	3101      	adds	r1, #1
    b = *oqp->q_rdptr++;
 80028e6:	64a0      	str	r0, [r4, #72]	; 0x48
    if (oqp->q_rdptr >= oqp->q_top) {
 80028e8:	4290      	cmp	r0, r2
    oqp->q_counter++;
 80028ea:	63a1      	str	r1, [r4, #56]	; 0x38
    b = *oqp->q_rdptr++;
 80028ec:	781d      	ldrb	r5, [r3, #0]
    if (oqp->q_rdptr >= oqp->q_top) {
 80028ee:	d301      	bcc.n	80028f4 <VectorDC+0xe4>
      oqp->q_rdptr = oqp->q_buffer;
 80028f0:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 80028f2:	64a3      	str	r3, [r4, #72]	; 0x48
  return (bool)(qp->next != qp);
 80028f4:	6b23      	ldr	r3, [r4, #48]	; 0x30
 80028f6:	42b3      	cmp	r3, r6
 80028f8:	4618      	mov	r0, r3
 80028fa:	d005      	beq.n	8002908 <VectorDC+0xf8>
  qp->next       = p->next;
 80028fc:	681a      	ldr	r2, [r3, #0]
 80028fe:	6322      	str	r2, [r4, #48]	; 0x30
  qp->next->prev = qp;
 8002900:	6056      	str	r6, [r2, #4]
 8002902:	629f      	str	r7, [r3, #40]	; 0x28
 8002904:	f7fe faac 	bl	8000e60 <__sch_ready_behind.isra.0>
        chnAddFlagsI(sdp, CHN_OUTPUT_EMPTY);
        u->CR1 = cr1 & ~USART_CR1_TXEIE;
        osalSysUnlockFromISR();
        break;
      }
      u->TDR = b;
 8002908:	f8cb 5028 	str.w	r5, [fp, #40]	; 0x28
 800290c:	f387 8811 	msr	BASEPRI, r7
      osalSysUnlockFromISR();

      isr = u->ISR;
 8002910:	f8db 501c 	ldr.w	r5, [fp, #28]
    while (isr & USART_ISR_TXE) {
 8002914:	062b      	lsls	r3, r5, #24
 8002916:	d512      	bpl.n	800293e <VectorDC+0x12e>
 8002918:	f388 8811 	msr	BASEPRI, r8
  if (!oqIsEmptyI(oqp)) {
 800291c:	e9d4 2311 	ldrd	r2, r3, [r4, #68]	; 0x44
 8002920:	429a      	cmp	r2, r3
 8002922:	d1dc      	bne.n	80028de <VectorDC+0xce>
 8002924:	6ba2      	ldr	r2, [r4, #56]	; 0x38
 8002926:	2a00      	cmp	r2, #0
 8002928:	d0d9      	beq.n	80028de <VectorDC+0xce>
 800292a:	2008      	movs	r0, #8
 800292c:	f7fe fc40 	bl	80011b0 <chEvtBroadcastFlagsI.constprop.0>
        u->CR1 = cr1 & ~USART_CR1_TXEIE;
 8002930:	f02a 0380 	bic.w	r3, sl, #128	; 0x80
 8002934:	f8cb 3000 	str.w	r3, [fp]
 8002938:	2300      	movs	r3, #0
 800293a:	f383 8811 	msr	BASEPRI, r3
    }
  }

  /* Physical transmission end.*/
  if ((cr1 & USART_CR1_TCIE) && (isr & USART_ISR_TC)) {
 800293e:	f01a 0f40 	tst.w	sl, #64	; 0x40
 8002942:	d001      	beq.n	8002948 <VectorDC+0x138>
 8002944:	066a      	lsls	r2, r5, #25
 8002946:	d408      	bmi.n	800295a <VectorDC+0x14a>
  if ((oip->trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 8002948:	f8b9 3088 	ldrh.w	r3, [r9, #136]	; 0x88
 800294c:	f013 0404 	ands.w	r4, r3, #4
 8002950:	d012      	beq.n	8002978 <VectorDC+0x168>
  uart_lld_serve_interrupt(&UARTD3);
#endif
#endif

  OSAL_IRQ_EPILOGUE();
}
 8002952:	e8bd 4ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  OSAL_IRQ_EPILOGUE();
 8002956:	f7fe b8cb 	b.w	8000af0 <__port_irq_epilogue>
 800295a:	2330      	movs	r3, #48	; 0x30
 800295c:	f383 8811 	msr	BASEPRI, r3
    osalSysLockFromISR();
    if (oqIsEmptyI(&sdp->oqueue)) {
 8002960:	e9d4 2311 	ldrd	r2, r3, [r4, #68]	; 0x44
 8002964:	429a      	cmp	r2, r3
 8002966:	d04b      	beq.n	8002a00 <VectorDC+0x1f0>
 8002968:	2300      	movs	r3, #0
 800296a:	f383 8811 	msr	BASEPRI, r3
 800296e:	f8b9 3088 	ldrh.w	r3, [r9, #136]	; 0x88
 8002972:	f013 0404 	ands.w	r4, r3, #4
 8002976:	d1ec      	bne.n	8002952 <VectorDC+0x142>
 8002978:	2330      	movs	r3, #48	; 0x30
 800297a:	f383 8811 	msr	BASEPRI, r3
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 800297e:	2104      	movs	r1, #4
 8002980:	f8d9 308c 	ldr.w	r3, [r9, #140]	; 0x8c
    oip->trace_buffer.ptr->u.isr.name  = isr;
 8002984:	4a28      	ldr	r2, [pc, #160]	; (8002a28 <VectorDC+0x218>)
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 8002986:	7019      	strb	r1, [r3, #0]
    oip->trace_buffer.ptr->u.isr.name  = isr;
 8002988:	609a      	str	r2, [r3, #8]
    trace_next(oip);
 800298a:	f7fe f9f1 	bl	8000d70 <trace_next.constprop.0>
 800298e:	f384 8811 	msr	BASEPRI, r4
}
 8002992:	e8bd 4ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  OSAL_IRQ_EPILOGUE();
 8002996:	f7fe b8ab 	b.w	8000af0 <__port_irq_epilogue>
 800299a:	2330      	movs	r3, #48	; 0x30
 800299c:	f383 8811 	msr	BASEPRI, r3
 80029a0:	f44f 6080 	mov.w	r0, #1024	; 0x400
 80029a4:	f7fe fc04 	bl	80011b0 <chEvtBroadcastFlagsI.constprop.0>
 80029a8:	2300      	movs	r3, #0
 80029aa:	f383 8811 	msr	BASEPRI, r3
}
 80029ae:	e748      	b.n	8002842 <VectorDC+0x32>
  if (isr & USART_ISR_ORE)
 80029b0:	f3c5 00c0 	ubfx	r0, r5, #3, #1
  if (isr & USART_ISR_PE)
 80029b4:	07ef      	lsls	r7, r5, #31
 80029b6:	f04f 0330 	mov.w	r3, #48	; 0x30
  if (isr & USART_ISR_ORE)
 80029ba:	ea4f 2000 	mov.w	r0, r0, lsl #8
    sts |= SD_PARITY_ERROR;
 80029be:	bf48      	it	mi
 80029c0:	f040 0020 	orrmi.w	r0, r0, #32
  if (isr & USART_ISR_FE)
 80029c4:	07ae      	lsls	r6, r5, #30
    sts |= SD_FRAMING_ERROR;
 80029c6:	bf48      	it	mi
 80029c8:	f040 0040 	orrmi.w	r0, r0, #64	; 0x40
  if (isr & USART_ISR_NE)
 80029cc:	0769      	lsls	r1, r5, #29
    sts |= SD_NOISE_ERROR;
 80029ce:	bf48      	it	mi
 80029d0:	f040 0080 	orrmi.w	r0, r0, #128	; 0x80
 80029d4:	f383 8811 	msr	BASEPRI, r3
  chEvtBroadcastFlagsI(esp, flags);
 80029d8:	f7fe fbea 	bl	80011b0 <chEvtBroadcastFlagsI.constprop.0>
 80029dc:	2300      	movs	r3, #0
 80029de:	f383 8811 	msr	BASEPRI, r3
}
 80029e2:	e72b      	b.n	800283c <VectorDC+0x2c>
 80029e4:	2330      	movs	r3, #48	; 0x30
 80029e6:	f383 8811 	msr	BASEPRI, r3
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 80029ea:	2103      	movs	r1, #3
 80029ec:	f8d9 308c 	ldr.w	r3, [r9, #140]	; 0x8c
    oip->trace_buffer.ptr->u.isr.name  = isr;
 80029f0:	4a0d      	ldr	r2, [pc, #52]	; (8002a28 <VectorDC+0x218>)
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 80029f2:	7019      	strb	r1, [r3, #0]
    oip->trace_buffer.ptr->u.isr.name  = isr;
 80029f4:	609a      	str	r2, [r3, #8]
    trace_next(oip);
 80029f6:	f7fe f9bb 	bl	8000d70 <trace_next.constprop.0>
 80029fa:	f384 8811 	msr	BASEPRI, r4
}
 80029fe:	e711      	b.n	8002824 <VectorDC+0x14>
    if (oqIsEmptyI(&sdp->oqueue)) {
 8002a00:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8002a02:	2b00      	cmp	r3, #0
 8002a04:	d0b0      	beq.n	8002968 <VectorDC+0x158>
 8002a06:	2010      	movs	r0, #16
 8002a08:	f7fe fbd2 	bl	80011b0 <chEvtBroadcastFlagsI.constprop.0>
      chnAddFlagsI(sdp, CHN_TRANSMISSION_END);
      u->CR1 = cr1 & ~USART_CR1_TCIE;
 8002a0c:	f02a 0340 	bic.w	r3, sl, #64	; 0x40
 8002a10:	f8cb 3000 	str.w	r3, [fp]
 8002a14:	e7a8      	b.n	8002968 <VectorDC+0x158>
 8002a16:	bf00      	nop
 8002a18:	24000330 	.word	0x24000330
 8002a1c:	24000070 	.word	0x24000070
 8002a20:	2400007c 	.word	0x2400007c
 8002a24:	240000a0 	.word	0x240000a0
 8002a28:	080059f0 	.word	0x080059f0
 8002a2c:	00000000 	.word	0x00000000

08002a30 <VectorB0>:
/**
 * @brief   TIM2 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_TIM2_HANDLER) {
 8002a30:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  if ((oip->trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 8002a34:	4d5b      	ldr	r5, [pc, #364]	; (8002ba4 <VectorB0+0x174>)
 8002a36:	f8b5 3088 	ldrh.w	r3, [r5, #136]	; 0x88
 8002a3a:	f013 0404 	ands.w	r4, r3, #4
 8002a3e:	d013      	beq.n	8002a68 <VectorB0+0x38>
void st_lld_serve_interrupt(void) {
#if OSAL_ST_MODE == OSAL_ST_MODE_FREERUNNING
  uint32_t sr;
  stm32_tim_t *timp = STM32_ST_TIM;

  sr  = timp->SR;
 8002a40:	f04f 4680 	mov.w	r6, #1073741824	; 0x40000000
 8002a44:	6933      	ldr	r3, [r6, #16]
  sr &= timp->DIER & STM32_TIM_DIER_IRQ_MASK;
 8002a46:	68f2      	ldr	r2, [r6, #12]
 8002a48:	4013      	ands	r3, r2
 8002a4a:	b2da      	uxtb	r2, r3
  timp->SR = ~sr;

  if ((sr & TIM_SR_CC1IF) != 0U)
 8002a4c:	079b      	lsls	r3, r3, #30
  timp->SR = ~sr;
 8002a4e:	ea6f 0202 	mvn.w	r2, r2
 8002a52:	6132      	str	r2, [r6, #16]
  if ((sr & TIM_SR_CC1IF) != 0U)
 8002a54:	d427      	bmi.n	8002aa6 <VectorB0+0x76>
  if ((oip->trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 8002a56:	f8b5 3088 	ldrh.w	r3, [r5, #136]	; 0x88
 8002a5a:	f013 0404 	ands.w	r4, r3, #4
 8002a5e:	d011      	beq.n	8002a84 <VectorB0+0x54>
  st_lld_serve_interrupt();
#endif
#endif

  OSAL_IRQ_EPILOGUE();
}
 8002a60:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  OSAL_IRQ_EPILOGUE();
 8002a64:	f7fe b844 	b.w	8000af0 <__port_irq_epilogue>
 8002a68:	2330      	movs	r3, #48	; 0x30
 8002a6a:	f383 8811 	msr	BASEPRI, r3
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 8002a6e:	2103      	movs	r1, #3
 8002a70:	f8d5 308c 	ldr.w	r3, [r5, #140]	; 0x8c
    oip->trace_buffer.ptr->u.isr.name  = isr;
 8002a74:	4a4c      	ldr	r2, [pc, #304]	; (8002ba8 <VectorB0+0x178>)
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 8002a76:	7019      	strb	r1, [r3, #0]
    oip->trace_buffer.ptr->u.isr.name  = isr;
 8002a78:	609a      	str	r2, [r3, #8]
    trace_next(oip);
 8002a7a:	f7fe f979 	bl	8000d70 <trace_next.constprop.0>
 8002a7e:	f384 8811 	msr	BASEPRI, r4
}
 8002a82:	e7dd      	b.n	8002a40 <VectorB0+0x10>
 8002a84:	2330      	movs	r3, #48	; 0x30
 8002a86:	f383 8811 	msr	BASEPRI, r3
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 8002a8a:	2104      	movs	r1, #4
 8002a8c:	f8d5 308c 	ldr.w	r3, [r5, #140]	; 0x8c
    oip->trace_buffer.ptr->u.isr.name  = isr;
 8002a90:	4a45      	ldr	r2, [pc, #276]	; (8002ba8 <VectorB0+0x178>)
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 8002a92:	7019      	strb	r1, [r3, #0]
    oip->trace_buffer.ptr->u.isr.name  = isr;
 8002a94:	609a      	str	r2, [r3, #8]
    trace_next(oip);
 8002a96:	f7fe f96b 	bl	8000d70 <trace_next.constprop.0>
 8002a9a:	f384 8811 	msr	BASEPRI, r4
}
 8002a9e:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  OSAL_IRQ_EPILOGUE();
 8002aa2:	f7fe b825 	b.w	8000af0 <__port_irq_epilogue>
 8002aa6:	2330      	movs	r3, #48	; 0x30
 8002aa8:	f383 8811 	msr	BASEPRI, r3
 *          to acquire the lock if needed. This is done in order to reduce
 *          interrupts jitter when many timers are in use.
 *
 * @iclass
 */
void chVTDoTickI(void) {
 8002aac:	4f3f      	ldr	r7, [pc, #252]	; (8002bac <VectorB0+0x17c>)
    lasttime = chTimeAddX(vtlp->lasttime, vtp->dlist.delta);
    vtlp->lasttime = lasttime;

    /* Removing the timer from the list, marking it as not armed.*/
    (void) ch_dlist_dequeue(&vtp->dlist);
    vtp->dlist.next = NULL;
 8002aae:	f04f 0a00 	mov.w	sl, #0
 8002ab2:	f04f 0830 	mov.w	r8, #48	; 0x30
 8002ab6:	e009      	b.n	8002acc <VectorB0+0x9c>
 8002ab8:	f38a 8811 	msr	BASEPRI, sl
    /* The callback is invoked outside the kernel critical section, it
       is re-entered on the callback return. Note that "lasttime" can be
       modified within the callback if some timer function is called.*/
    chSysUnlockFromISR();

    vtp->func(vtp, vtp->par);
 8002abc:	e9d4 3103 	ldrd	r3, r1, [r4, #12]
 8002ac0:	4620      	mov	r0, r4
 8002ac2:	4798      	blx	r3
 8002ac4:	f388 8811 	msr	BASEPRI, r8

    chSysLockFromISR();

    /* If a reload is defined the timer needs to be restarted.*/
    if (unlikely(vtp->reload > (sysinterval_t)0)) {
 8002ac8:	6963      	ldr	r3, [r4, #20]
 8002aca:	b9b3      	cbnz	r3, 8002afa <VectorB0+0xca>
    nowdelta = chTimeDiffX(vtlp->lasttime, now);
 8002acc:	69ea      	ldr	r2, [r5, #28]
 8002ace:	6a71      	ldr	r1, [r6, #36]	; 0x24
    vtp = (virtual_timer_t *)vtlp->dlist.next;
 8002ad0:	692c      	ldr	r4, [r5, #16]
 8002ad2:	1a88      	subs	r0, r1, r2
    if (nowdelta < vtp->dlist.delta) {
 8002ad4:	68a3      	ldr	r3, [r4, #8]
 8002ad6:	4298      	cmp	r0, r3
  return systime + (systime_t)interval;
 8002ad8:	eb02 0903 	add.w	r9, r2, r3
 8002adc:	d32a      	bcc.n	8002b34 <VectorB0+0x104>
  dlp->prev->next = dlp->next;
 8002ade:	e9d4 3200 	ldrd	r3, r2, [r4]
    vtlp->lasttime = lasttime;
 8002ae2:	f8c5 901c 	str.w	r9, [r5, #28]
 8002ae6:	6013      	str	r3, [r2, #0]
  dlp->next->prev = dlp->prev;
 8002ae8:	605a      	str	r2, [r3, #4]
    vtp->dlist.next = NULL;
 8002aea:	f8c4 a000 	str.w	sl, [r4]
    if (ch_dlist_isempty(&vtlp->dlist)) {
 8002aee:	692b      	ldr	r3, [r5, #16]
 8002af0:	42bb      	cmp	r3, r7
 8002af2:	d1e1      	bne.n	8002ab8 <VectorB0+0x88>
  STM32_ST_TIM->DIER = 0U;
 8002af4:	f8c6 a00c 	str.w	sl, [r6, #12]
 8002af8:	e7de      	b.n	8002ab8 <VectorB0+0x88>
  return (systime_t)STM32_ST_TIM->CNT;
 8002afa:	6a71      	ldr	r1, [r6, #36]	; 0x24
  return (sysinterval_t)((systime_t)(end - start));
 8002afc:	eba1 0009 	sub.w	r0, r1, r9
      now = chVTGetSystemTimeX();
      nowdelta = chTimeDiffX(lasttime, now);

#if !defined(CH_VT_RFCU_DISABLED)
      /* Checking if the required reload is feasible.*/
      if (nowdelta > vtp->reload) {
 8002b00:	4283      	cmp	r3, r0
 8002b02:	d32a      	bcc.n	8002b5a <VectorB0+0x12a>
  return (bool)(dlhp == dlhp->next);
 8002b04:	692a      	ldr	r2, [r5, #16]
      /* Enqueuing the timer again using the calculated delta.*/
      delay = vtp->reload - nowdelta;
#endif

      /* Special case where the timers list is empty.*/
      if (ch_dlist_isempty(&vtlp->dlist)) {
 8002b06:	42ba      	cmp	r2, r7
 8002b08:	d041      	beq.n	8002b8e <VectorB0+0x15e>
  while (likely(dlp->delta < delta)) {
 8002b0a:	6891      	ldr	r1, [r2, #8]
 8002b0c:	428b      	cmp	r3, r1
 8002b0e:	d904      	bls.n	8002b1a <VectorB0+0xea>
    dlp = dlp->next;
 8002b10:	6812      	ldr	r2, [r2, #0]
    delta -= dlp->delta;
 8002b12:	1a5b      	subs	r3, r3, r1
  while (likely(dlp->delta < delta)) {
 8002b14:	6891      	ldr	r1, [r2, #8]
 8002b16:	4299      	cmp	r1, r3
 8002b18:	d3fa      	bcc.n	8002b10 <VectorB0+0xe0>
  dlp->delta      = delta;
 8002b1a:	60a3      	str	r3, [r4, #8]
  dlp->delta -= delta;
 8002b1c:	6891      	ldr	r1, [r2, #8]
  dlp->next       = dlhp;
 8002b1e:	6022      	str	r2, [r4, #0]
  dlp->delta -= delta;
 8002b20:	1ac9      	subs	r1, r1, r3
  dlp->prev       = dlp->next->prev;
 8002b22:	6853      	ldr	r3, [r2, #4]
 8002b24:	6063      	str	r3, [r4, #4]
  dlp->prev->next = dlp;
 8002b26:	601c      	str	r4, [r3, #0]
  dlhp->delta = (sysinterval_t)-1;
 8002b28:	f04f 33ff 	mov.w	r3, #4294967295
  dlp->delta -= delta;
 8002b2c:	e9c2 4101 	strd	r4, r1, [r2, #4]
  dlhp->delta = (sysinterval_t)-1;
 8002b30:	61ab      	str	r3, [r5, #24]
}
 8002b32:	e7be      	b.n	8002ab2 <VectorB0+0x82>
      ch_dlist_insert(&vtlp->dlist, &vtp->dlist, delta);
    }
  }

  /* If the list is empty, nothing else to do.*/
  if (ch_dlist_isempty(&vtlp->dlist)) {
 8002b34:	42bc      	cmp	r4, r7
 8002b36:	d00c      	beq.n	8002b52 <VectorB0+0x122>
  }

  /* The "unprocessed nowdelta" time slice is added to "last time"
     and subtracted to next timer's delta.*/
  vtlp->lasttime += nowdelta;
  vtp->dlist.delta -= nowdelta;
 8002b38:	1a5b      	subs	r3, r3, r1
  vtlp->lasttime += nowdelta;
 8002b3a:	61e9      	str	r1, [r5, #28]
  vtp->dlist.delta -= nowdelta;
 8002b3c:	4413      	add	r3, r2
 8002b3e:	2b02      	cmp	r3, #2
 8002b40:	60a3      	str	r3, [r4, #8]
  if (delay < currdelta) {
 8002b42:	bf38      	it	cc
 8002b44:	2302      	movcc	r3, #2
  return systime + (systime_t)interval;
 8002b46:	18ca      	adds	r2, r1, r3
  STM32_ST_TIM->CCR[0] = (uint32_t)abstime;
 8002b48:	6372      	str	r2, [r6, #52]	; 0x34
  return (systime_t)STM32_ST_TIM->CNT;
 8002b4a:	6a72      	ldr	r2, [r6, #36]	; 0x24
  return (sysinterval_t)((systime_t)(end - start));
 8002b4c:	1a51      	subs	r1, r2, r1
    if (likely(nowdelta < delay)) {
 8002b4e:	428b      	cmp	r3, r1
 8002b50:	d90c      	bls.n	8002b6c <VectorB0+0x13c>
 8002b52:	2300      	movs	r3, #0
 8002b54:	f383 8811 	msr	BASEPRI, r3
}
 8002b58:	e77d      	b.n	8002a56 <VectorB0+0x26>
  currcore->rfcu.mask |= mask;
 8002b5a:	6b6b      	ldr	r3, [r5, #52]	; 0x34
  return (bool)(dlhp == dlhp->next);
 8002b5c:	692a      	ldr	r2, [r5, #16]
 8002b5e:	f043 0302 	orr.w	r3, r3, #2
      if (ch_dlist_isempty(&vtlp->dlist)) {
 8002b62:	42ba      	cmp	r2, r7
 8002b64:	636b      	str	r3, [r5, #52]	; 0x34
 8002b66:	d019      	beq.n	8002b9c <VectorB0+0x16c>
 8002b68:	4603      	mov	r3, r0
 8002b6a:	e7ce      	b.n	8002b0a <VectorB0+0xda>
    if (likely(nowdelta < delay)) {
 8002b6c:	2302      	movs	r3, #2
  STM32_ST_TIM->CCR[0] = (uint32_t)abstime;
 8002b6e:	f04f 4180 	mov.w	r1, #1073741824	; 0x40000000
    currdelta += (sysinterval_t)1;
 8002b72:	3301      	adds	r3, #1
  return systime + (systime_t)interval;
 8002b74:	18d0      	adds	r0, r2, r3
 8002b76:	6348      	str	r0, [r1, #52]	; 0x34
  return (systime_t)STM32_ST_TIM->CNT;
 8002b78:	6a48      	ldr	r0, [r1, #36]	; 0x24
  return (sysinterval_t)((systime_t)(end - start));
 8002b7a:	1a82      	subs	r2, r0, r2
    if (likely(nowdelta < delay)) {
 8002b7c:	429a      	cmp	r2, r3
 8002b7e:	d20f      	bcs.n	8002ba0 <VectorB0+0x170>
  if (currdelta > CH_CFG_ST_TIMEDELTA) {
 8002b80:	2b02      	cmp	r3, #2
 8002b82:	d9e6      	bls.n	8002b52 <VectorB0+0x122>
 8002b84:	6b6b      	ldr	r3, [r5, #52]	; 0x34
 8002b86:	f043 0301 	orr.w	r3, r3, #1
 8002b8a:	636b      	str	r3, [r5, #52]	; 0x34
}
 8002b8c:	e7e1      	b.n	8002b52 <VectorB0+0x122>
        delay = vtp->reload - nowdelta;
 8002b8e:	1a5b      	subs	r3, r3, r1
 8002b90:	eb03 0209 	add.w	r2, r3, r9
        vt_insert_first(vtlp, vtp, now, delay);
 8002b94:	4620      	mov	r0, r4
 8002b96:	f7fe fb8b 	bl	80012b0 <vt_insert_first.constprop.0>
        return;
 8002b9a:	e7da      	b.n	8002b52 <VectorB0+0x122>
        delay = (sysinterval_t)0;
 8002b9c:	2200      	movs	r2, #0
 8002b9e:	e7f9      	b.n	8002b94 <VectorB0+0x164>
 8002ba0:	4602      	mov	r2, r0
 8002ba2:	e7e6      	b.n	8002b72 <VectorB0+0x142>
 8002ba4:	24000330 	.word	0x24000330
 8002ba8:	080059a8 	.word	0x080059a8
 8002bac:	24000340 	.word	0x24000340

08002bb0 <Vector88>:
OSAL_IRQ_HANDLER(STM32_ADC12_HANDLER) {
 8002bb0:	b538      	push	{r3, r4, r5, lr}
  if ((oip->trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 8002bb2:	4d1a      	ldr	r5, [pc, #104]	; (8002c1c <Vector88+0x6c>)
 8002bb4:	f8b5 3088 	ldrh.w	r3, [r5, #136]	; 0x88
 8002bb8:	f013 0404 	ands.w	r4, r3, #4
 8002bbc:	d00e      	beq.n	8002bdc <Vector88+0x2c>
  isr  = ADC1->ISR;
 8002bbe:	4b18      	ldr	r3, [pc, #96]	; (8002c20 <Vector88+0x70>)
  adc_lld_serve_interrupt(&ADCD1, isr);
 8002bc0:	4818      	ldr	r0, [pc, #96]	; (8002c24 <Vector88+0x74>)
  isr  = ADC1->ISR;
 8002bc2:	6819      	ldr	r1, [r3, #0]
  ADC1->ISR = isr;
 8002bc4:	6019      	str	r1, [r3, #0]
  adc_lld_serve_interrupt(&ADCD1, isr);
 8002bc6:	f7fe f973 	bl	8000eb0 <adc_lld_serve_interrupt>
  if ((oip->trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 8002bca:	f8b5 3088 	ldrh.w	r3, [r5, #136]	; 0x88
 8002bce:	f013 0404 	ands.w	r4, r3, #4
 8002bd2:	d011      	beq.n	8002bf8 <Vector88+0x48>
}
 8002bd4:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  OSAL_IRQ_EPILOGUE();
 8002bd8:	f7fd bf8a 	b.w	8000af0 <__port_irq_epilogue>
 8002bdc:	2330      	movs	r3, #48	; 0x30
 8002bde:	f383 8811 	msr	BASEPRI, r3
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 8002be2:	2103      	movs	r1, #3
 8002be4:	f8d5 308c 	ldr.w	r3, [r5, #140]	; 0x8c
    oip->trace_buffer.ptr->u.isr.name  = isr;
 8002be8:	4a0f      	ldr	r2, [pc, #60]	; (8002c28 <Vector88+0x78>)
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 8002bea:	7019      	strb	r1, [r3, #0]
    oip->trace_buffer.ptr->u.isr.name  = isr;
 8002bec:	609a      	str	r2, [r3, #8]
    trace_next(oip);
 8002bee:	f7fe f8bf 	bl	8000d70 <trace_next.constprop.0>
 8002bf2:	f384 8811 	msr	BASEPRI, r4
}
 8002bf6:	e7e2      	b.n	8002bbe <Vector88+0xe>
 8002bf8:	2330      	movs	r3, #48	; 0x30
 8002bfa:	f383 8811 	msr	BASEPRI, r3
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 8002bfe:	2104      	movs	r1, #4
 8002c00:	f8d5 308c 	ldr.w	r3, [r5, #140]	; 0x8c
    oip->trace_buffer.ptr->u.isr.name  = isr;
 8002c04:	4a08      	ldr	r2, [pc, #32]	; (8002c28 <Vector88+0x78>)
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 8002c06:	7019      	strb	r1, [r3, #0]
    oip->trace_buffer.ptr->u.isr.name  = isr;
 8002c08:	609a      	str	r2, [r3, #8]
    trace_next(oip);
 8002c0a:	f7fe f8b1 	bl	8000d70 <trace_next.constprop.0>
 8002c0e:	f384 8811 	msr	BASEPRI, r4
}
 8002c12:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  OSAL_IRQ_EPILOGUE();
 8002c16:	f7fd bf6b 	b.w	8000af0 <__port_irq_epilogue>
 8002c1a:	bf00      	nop
 8002c1c:	24000330 	.word	0x24000330
 8002c20:	40022000 	.word	0x40022000
 8002c24:	24000000 	.word	0x24000000
 8002c28:	080059fc 	.word	0x080059fc
 8002c2c:	00000000 	.word	0x00000000

08002c30 <Vector23C>:
OSAL_IRQ_HANDLER(STM32_ADC3_HANDLER) {
 8002c30:	b538      	push	{r3, r4, r5, lr}
  if ((oip->trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 8002c32:	4d1a      	ldr	r5, [pc, #104]	; (8002c9c <Vector23C+0x6c>)
 8002c34:	f8b5 3088 	ldrh.w	r3, [r5, #136]	; 0x88
 8002c38:	f013 0404 	ands.w	r4, r3, #4
 8002c3c:	d00e      	beq.n	8002c5c <Vector23C+0x2c>
  isr  = ADC3->ISR;
 8002c3e:	4b18      	ldr	r3, [pc, #96]	; (8002ca0 <Vector23C+0x70>)
  adc_lld_serve_interrupt(&ADCD3, isr);
 8002c40:	4818      	ldr	r0, [pc, #96]	; (8002ca4 <Vector23C+0x74>)
  isr  = ADC3->ISR;
 8002c42:	6819      	ldr	r1, [r3, #0]
  ADC3->ISR = isr;
 8002c44:	6019      	str	r1, [r3, #0]
  adc_lld_serve_interrupt(&ADCD3, isr);
 8002c46:	f7fe f933 	bl	8000eb0 <adc_lld_serve_interrupt>
  if ((oip->trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 8002c4a:	f8b5 3088 	ldrh.w	r3, [r5, #136]	; 0x88
 8002c4e:	f013 0404 	ands.w	r4, r3, #4
 8002c52:	d011      	beq.n	8002c78 <Vector23C+0x48>
}
 8002c54:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  OSAL_IRQ_EPILOGUE();
 8002c58:	f7fd bf4a 	b.w	8000af0 <__port_irq_epilogue>
 8002c5c:	2330      	movs	r3, #48	; 0x30
 8002c5e:	f383 8811 	msr	BASEPRI, r3
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 8002c62:	2103      	movs	r1, #3
 8002c64:	f8d5 308c 	ldr.w	r3, [r5, #140]	; 0x8c
    oip->trace_buffer.ptr->u.isr.name  = isr;
 8002c68:	4a0f      	ldr	r2, [pc, #60]	; (8002ca8 <Vector23C+0x78>)
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 8002c6a:	7019      	strb	r1, [r3, #0]
    oip->trace_buffer.ptr->u.isr.name  = isr;
 8002c6c:	609a      	str	r2, [r3, #8]
    trace_next(oip);
 8002c6e:	f7fe f87f 	bl	8000d70 <trace_next.constprop.0>
 8002c72:	f384 8811 	msr	BASEPRI, r4
}
 8002c76:	e7e2      	b.n	8002c3e <Vector23C+0xe>
 8002c78:	2330      	movs	r3, #48	; 0x30
 8002c7a:	f383 8811 	msr	BASEPRI, r3
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 8002c7e:	2104      	movs	r1, #4
 8002c80:	f8d5 308c 	ldr.w	r3, [r5, #140]	; 0x8c
    oip->trace_buffer.ptr->u.isr.name  = isr;
 8002c84:	4a08      	ldr	r2, [pc, #32]	; (8002ca8 <Vector23C+0x78>)
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 8002c86:	7019      	strb	r1, [r3, #0]
    oip->trace_buffer.ptr->u.isr.name  = isr;
 8002c88:	609a      	str	r2, [r3, #8]
    trace_next(oip);
 8002c8a:	f7fe f871 	bl	8000d70 <trace_next.constprop.0>
 8002c8e:	f384 8811 	msr	BASEPRI, r4
}
 8002c92:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  OSAL_IRQ_EPILOGUE();
 8002c96:	f7fd bf2b 	b.w	8000af0 <__port_irq_epilogue>
 8002c9a:	bf00      	nop
 8002c9c:	24000330 	.word	0x24000330
 8002ca0:	58026000 	.word	0x58026000
 8002ca4:	24000038 	.word	0x24000038
 8002ca8:	080059b4 	.word	0x080059b4
 8002cac:	00000000 	.word	0x00000000

08002cb0 <Vector244>:
/**
 * @brief   BDMA1 stream 0 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_BDMA1_CH0_HANDLER) {
 8002cb0:	b538      	push	{r3, r4, r5, lr}
  if ((oip->trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 8002cb2:	4d1c      	ldr	r5, [pc, #112]	; (8002d24 <Vector244+0x74>)
 8002cb4:	f8b5 3088 	ldrh.w	r3, [r5, #136]	; 0x88
 8002cb8:	f013 0404 	ands.w	r4, r3, #4
 8002cbc:	d012      	beq.n	8002ce4 <Vector244+0x34>
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (BDMA->ISR >> 0U) & STM32_BDMA_ISR_MASK;
 8002cbe:	4b1a      	ldr	r3, [pc, #104]	; (8002d28 <Vector244+0x78>)
  BDMA->IFCR = flags << 0U;
  if (bdma.streams[0].func)
 8002cc0:	481a      	ldr	r0, [pc, #104]	; (8002d2c <Vector244+0x7c>)
  flags = (BDMA->ISR >> 0U) & STM32_BDMA_ISR_MASK;
 8002cc2:	6819      	ldr	r1, [r3, #0]
  if (bdma.streams[0].func)
 8002cc4:	6842      	ldr	r2, [r0, #4]
  flags = (BDMA->ISR >> 0U) & STM32_BDMA_ISR_MASK;
 8002cc6:	f001 010e 	and.w	r1, r1, #14
  BDMA->IFCR = flags << 0U;
 8002cca:	6059      	str	r1, [r3, #4]
  if (bdma.streams[0].func)
 8002ccc:	b10a      	cbz	r2, 8002cd2 <Vector244+0x22>
    bdma.streams[0].func(bdma.streams[0].param, flags);
 8002cce:	6880      	ldr	r0, [r0, #8]
 8002cd0:	4790      	blx	r2
  if ((oip->trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 8002cd2:	f8b5 3088 	ldrh.w	r3, [r5, #136]	; 0x88
 8002cd6:	f013 0404 	ands.w	r4, r3, #4
 8002cda:	d011      	beq.n	8002d00 <Vector244+0x50>

  OSAL_IRQ_EPILOGUE();
}
 8002cdc:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  OSAL_IRQ_EPILOGUE();
 8002ce0:	f7fd bf06 	b.w	8000af0 <__port_irq_epilogue>
 8002ce4:	2330      	movs	r3, #48	; 0x30
 8002ce6:	f383 8811 	msr	BASEPRI, r3
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 8002cea:	2103      	movs	r1, #3
 8002cec:	f8d5 308c 	ldr.w	r3, [r5, #140]	; 0x8c
    oip->trace_buffer.ptr->u.isr.name  = isr;
 8002cf0:	4a0f      	ldr	r2, [pc, #60]	; (8002d30 <Vector244+0x80>)
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 8002cf2:	7019      	strb	r1, [r3, #0]
    oip->trace_buffer.ptr->u.isr.name  = isr;
 8002cf4:	609a      	str	r2, [r3, #8]
    trace_next(oip);
 8002cf6:	f7fe f83b 	bl	8000d70 <trace_next.constprop.0>
 8002cfa:	f384 8811 	msr	BASEPRI, r4
}
 8002cfe:	e7de      	b.n	8002cbe <Vector244+0xe>
 8002d00:	2330      	movs	r3, #48	; 0x30
 8002d02:	f383 8811 	msr	BASEPRI, r3
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 8002d06:	2104      	movs	r1, #4
 8002d08:	f8d5 308c 	ldr.w	r3, [r5, #140]	; 0x8c
    oip->trace_buffer.ptr->u.isr.name  = isr;
 8002d0c:	4a08      	ldr	r2, [pc, #32]	; (8002d30 <Vector244+0x80>)
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 8002d0e:	7019      	strb	r1, [r3, #0]
    oip->trace_buffer.ptr->u.isr.name  = isr;
 8002d10:	609a      	str	r2, [r3, #8]
    trace_next(oip);
 8002d12:	f7fe f82d 	bl	8000d70 <trace_next.constprop.0>
 8002d16:	f384 8811 	msr	BASEPRI, r4
}
 8002d1a:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  OSAL_IRQ_EPILOGUE();
 8002d1e:	f7fd bee7 	b.w	8000af0 <__port_irq_epilogue>
 8002d22:	bf00      	nop
 8002d24:	24000330 	.word	0x24000330
 8002d28:	58025400 	.word	0x58025400
 8002d2c:	240002e8 	.word	0x240002e8
 8002d30:	08005b1c 	.word	0x08005b1c
	...

08002d40 <Vector248>:
/**
 * @brief   BDMA1 stream 1 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_BDMA1_CH1_HANDLER) {
 8002d40:	b538      	push	{r3, r4, r5, lr}
  if ((oip->trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 8002d42:	4d1d      	ldr	r5, [pc, #116]	; (8002db8 <Vector248+0x78>)
 8002d44:	f8b5 3088 	ldrh.w	r3, [r5, #136]	; 0x88
 8002d48:	f013 0404 	ands.w	r4, r3, #4
 8002d4c:	d014      	beq.n	8002d78 <Vector248+0x38>
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (BDMA->ISR >> 4U) & STM32_BDMA_ISR_MASK;
 8002d4e:	4b1b      	ldr	r3, [pc, #108]	; (8002dbc <Vector248+0x7c>)
  BDMA->IFCR = flags << 4U;
  if (bdma.streams[1].func)
 8002d50:	4a1b      	ldr	r2, [pc, #108]	; (8002dc0 <Vector248+0x80>)
  flags = (BDMA->ISR >> 4U) & STM32_BDMA_ISR_MASK;
 8002d52:	6819      	ldr	r1, [r3, #0]
 8002d54:	0909      	lsrs	r1, r1, #4
 8002d56:	f001 010e 	and.w	r1, r1, #14
  BDMA->IFCR = flags << 4U;
 8002d5a:	0108      	lsls	r0, r1, #4
 8002d5c:	6058      	str	r0, [r3, #4]
  if (bdma.streams[1].func)
 8002d5e:	68d3      	ldr	r3, [r2, #12]
 8002d60:	b10b      	cbz	r3, 8002d66 <Vector248+0x26>
    bdma.streams[1].func(bdma.streams[1].param, flags);
 8002d62:	6910      	ldr	r0, [r2, #16]
 8002d64:	4798      	blx	r3
  if ((oip->trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 8002d66:	f8b5 3088 	ldrh.w	r3, [r5, #136]	; 0x88
 8002d6a:	f013 0404 	ands.w	r4, r3, #4
 8002d6e:	d011      	beq.n	8002d94 <Vector248+0x54>

  OSAL_IRQ_EPILOGUE();
}
 8002d70:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  OSAL_IRQ_EPILOGUE();
 8002d74:	f7fd bebc 	b.w	8000af0 <__port_irq_epilogue>
 8002d78:	2330      	movs	r3, #48	; 0x30
 8002d7a:	f383 8811 	msr	BASEPRI, r3
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 8002d7e:	2103      	movs	r1, #3
 8002d80:	f8d5 308c 	ldr.w	r3, [r5, #140]	; 0x8c
    oip->trace_buffer.ptr->u.isr.name  = isr;
 8002d84:	4a0f      	ldr	r2, [pc, #60]	; (8002dc4 <Vector248+0x84>)
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 8002d86:	7019      	strb	r1, [r3, #0]
    oip->trace_buffer.ptr->u.isr.name  = isr;
 8002d88:	609a      	str	r2, [r3, #8]
    trace_next(oip);
 8002d8a:	f7fd fff1 	bl	8000d70 <trace_next.constprop.0>
 8002d8e:	f384 8811 	msr	BASEPRI, r4
}
 8002d92:	e7dc      	b.n	8002d4e <Vector248+0xe>
 8002d94:	2330      	movs	r3, #48	; 0x30
 8002d96:	f383 8811 	msr	BASEPRI, r3
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 8002d9a:	2104      	movs	r1, #4
 8002d9c:	f8d5 308c 	ldr.w	r3, [r5, #140]	; 0x8c
    oip->trace_buffer.ptr->u.isr.name  = isr;
 8002da0:	4a08      	ldr	r2, [pc, #32]	; (8002dc4 <Vector248+0x84>)
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 8002da2:	7019      	strb	r1, [r3, #0]
    oip->trace_buffer.ptr->u.isr.name  = isr;
 8002da4:	609a      	str	r2, [r3, #8]
    trace_next(oip);
 8002da6:	f7fd ffe3 	bl	8000d70 <trace_next.constprop.0>
 8002daa:	f384 8811 	msr	BASEPRI, r4
}
 8002dae:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  OSAL_IRQ_EPILOGUE();
 8002db2:	f7fd be9d 	b.w	8000af0 <__port_irq_epilogue>
 8002db6:	bf00      	nop
 8002db8:	24000330 	.word	0x24000330
 8002dbc:	58025400 	.word	0x58025400
 8002dc0:	240002e8 	.word	0x240002e8
 8002dc4:	08005b04 	.word	0x08005b04
	...

08002dd0 <Vector24C>:
/**
 * @brief   BDMA1 stream 2 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_BDMA1_CH2_HANDLER) {
 8002dd0:	b538      	push	{r3, r4, r5, lr}
  if ((oip->trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 8002dd2:	4d1d      	ldr	r5, [pc, #116]	; (8002e48 <Vector24C+0x78>)
 8002dd4:	f8b5 3088 	ldrh.w	r3, [r5, #136]	; 0x88
 8002dd8:	f013 0404 	ands.w	r4, r3, #4
 8002ddc:	d014      	beq.n	8002e08 <Vector24C+0x38>
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (BDMA->ISR >> 8U) & STM32_BDMA_ISR_MASK;
 8002dde:	4b1b      	ldr	r3, [pc, #108]	; (8002e4c <Vector24C+0x7c>)
  BDMA->IFCR = flags << 8U;
  if (bdma.streams[2].func)
 8002de0:	4a1b      	ldr	r2, [pc, #108]	; (8002e50 <Vector24C+0x80>)
  flags = (BDMA->ISR >> 8U) & STM32_BDMA_ISR_MASK;
 8002de2:	6819      	ldr	r1, [r3, #0]
 8002de4:	0a09      	lsrs	r1, r1, #8
 8002de6:	f001 010e 	and.w	r1, r1, #14
  BDMA->IFCR = flags << 8U;
 8002dea:	0208      	lsls	r0, r1, #8
 8002dec:	6058      	str	r0, [r3, #4]
  if (bdma.streams[2].func)
 8002dee:	6953      	ldr	r3, [r2, #20]
 8002df0:	b10b      	cbz	r3, 8002df6 <Vector24C+0x26>
    bdma.streams[2].func(bdma.streams[2].param, flags);
 8002df2:	6990      	ldr	r0, [r2, #24]
 8002df4:	4798      	blx	r3
  if ((oip->trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 8002df6:	f8b5 3088 	ldrh.w	r3, [r5, #136]	; 0x88
 8002dfa:	f013 0404 	ands.w	r4, r3, #4
 8002dfe:	d011      	beq.n	8002e24 <Vector24C+0x54>

  OSAL_IRQ_EPILOGUE();
}
 8002e00:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  OSAL_IRQ_EPILOGUE();
 8002e04:	f7fd be74 	b.w	8000af0 <__port_irq_epilogue>
 8002e08:	2330      	movs	r3, #48	; 0x30
 8002e0a:	f383 8811 	msr	BASEPRI, r3
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 8002e0e:	2103      	movs	r1, #3
 8002e10:	f8d5 308c 	ldr.w	r3, [r5, #140]	; 0x8c
    oip->trace_buffer.ptr->u.isr.name  = isr;
 8002e14:	4a0f      	ldr	r2, [pc, #60]	; (8002e54 <Vector24C+0x84>)
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 8002e16:	7019      	strb	r1, [r3, #0]
    oip->trace_buffer.ptr->u.isr.name  = isr;
 8002e18:	609a      	str	r2, [r3, #8]
    trace_next(oip);
 8002e1a:	f7fd ffa9 	bl	8000d70 <trace_next.constprop.0>
 8002e1e:	f384 8811 	msr	BASEPRI, r4
}
 8002e22:	e7dc      	b.n	8002dde <Vector24C+0xe>
 8002e24:	2330      	movs	r3, #48	; 0x30
 8002e26:	f383 8811 	msr	BASEPRI, r3
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 8002e2a:	2104      	movs	r1, #4
 8002e2c:	f8d5 308c 	ldr.w	r3, [r5, #140]	; 0x8c
    oip->trace_buffer.ptr->u.isr.name  = isr;
 8002e30:	4a08      	ldr	r2, [pc, #32]	; (8002e54 <Vector24C+0x84>)
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 8002e32:	7019      	strb	r1, [r3, #0]
    oip->trace_buffer.ptr->u.isr.name  = isr;
 8002e34:	609a      	str	r2, [r3, #8]
    trace_next(oip);
 8002e36:	f7fd ff9b 	bl	8000d70 <trace_next.constprop.0>
 8002e3a:	f384 8811 	msr	BASEPRI, r4
}
 8002e3e:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  OSAL_IRQ_EPILOGUE();
 8002e42:	f7fd be55 	b.w	8000af0 <__port_irq_epilogue>
 8002e46:	bf00      	nop
 8002e48:	24000330 	.word	0x24000330
 8002e4c:	58025400 	.word	0x58025400
 8002e50:	240002e8 	.word	0x240002e8
 8002e54:	08005aec 	.word	0x08005aec
	...

08002e60 <Vector250>:
/**
 * @brief   BDMA1 stream 3 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_BDMA1_CH3_HANDLER) {
 8002e60:	b538      	push	{r3, r4, r5, lr}
  if ((oip->trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 8002e62:	4d1d      	ldr	r5, [pc, #116]	; (8002ed8 <Vector250+0x78>)
 8002e64:	f8b5 3088 	ldrh.w	r3, [r5, #136]	; 0x88
 8002e68:	f013 0404 	ands.w	r4, r3, #4
 8002e6c:	d014      	beq.n	8002e98 <Vector250+0x38>
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (BDMA->ISR >> 12U) & STM32_BDMA_ISR_MASK;
 8002e6e:	4b1b      	ldr	r3, [pc, #108]	; (8002edc <Vector250+0x7c>)
  BDMA->IFCR = flags << 12U;
  if (bdma.streams[3].func)
 8002e70:	4a1b      	ldr	r2, [pc, #108]	; (8002ee0 <Vector250+0x80>)
  flags = (BDMA->ISR >> 12U) & STM32_BDMA_ISR_MASK;
 8002e72:	6819      	ldr	r1, [r3, #0]
 8002e74:	0b09      	lsrs	r1, r1, #12
 8002e76:	f001 010e 	and.w	r1, r1, #14
  BDMA->IFCR = flags << 12U;
 8002e7a:	0308      	lsls	r0, r1, #12
 8002e7c:	6058      	str	r0, [r3, #4]
  if (bdma.streams[3].func)
 8002e7e:	69d3      	ldr	r3, [r2, #28]
 8002e80:	b10b      	cbz	r3, 8002e86 <Vector250+0x26>
    bdma.streams[3].func(bdma.streams[3].param, flags);
 8002e82:	6a10      	ldr	r0, [r2, #32]
 8002e84:	4798      	blx	r3
  if ((oip->trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 8002e86:	f8b5 3088 	ldrh.w	r3, [r5, #136]	; 0x88
 8002e8a:	f013 0404 	ands.w	r4, r3, #4
 8002e8e:	d011      	beq.n	8002eb4 <Vector250+0x54>

  OSAL_IRQ_EPILOGUE();
}
 8002e90:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  OSAL_IRQ_EPILOGUE();
 8002e94:	f7fd be2c 	b.w	8000af0 <__port_irq_epilogue>
 8002e98:	2330      	movs	r3, #48	; 0x30
 8002e9a:	f383 8811 	msr	BASEPRI, r3
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 8002e9e:	2103      	movs	r1, #3
 8002ea0:	f8d5 308c 	ldr.w	r3, [r5, #140]	; 0x8c
    oip->trace_buffer.ptr->u.isr.name  = isr;
 8002ea4:	4a0f      	ldr	r2, [pc, #60]	; (8002ee4 <Vector250+0x84>)
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 8002ea6:	7019      	strb	r1, [r3, #0]
    oip->trace_buffer.ptr->u.isr.name  = isr;
 8002ea8:	609a      	str	r2, [r3, #8]
    trace_next(oip);
 8002eaa:	f7fd ff61 	bl	8000d70 <trace_next.constprop.0>
 8002eae:	f384 8811 	msr	BASEPRI, r4
}
 8002eb2:	e7dc      	b.n	8002e6e <Vector250+0xe>
 8002eb4:	2330      	movs	r3, #48	; 0x30
 8002eb6:	f383 8811 	msr	BASEPRI, r3
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 8002eba:	2104      	movs	r1, #4
 8002ebc:	f8d5 308c 	ldr.w	r3, [r5, #140]	; 0x8c
    oip->trace_buffer.ptr->u.isr.name  = isr;
 8002ec0:	4a08      	ldr	r2, [pc, #32]	; (8002ee4 <Vector250+0x84>)
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 8002ec2:	7019      	strb	r1, [r3, #0]
    oip->trace_buffer.ptr->u.isr.name  = isr;
 8002ec4:	609a      	str	r2, [r3, #8]
    trace_next(oip);
 8002ec6:	f7fd ff53 	bl	8000d70 <trace_next.constprop.0>
 8002eca:	f384 8811 	msr	BASEPRI, r4
}
 8002ece:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  OSAL_IRQ_EPILOGUE();
 8002ed2:	f7fd be0d 	b.w	8000af0 <__port_irq_epilogue>
 8002ed6:	bf00      	nop
 8002ed8:	24000330 	.word	0x24000330
 8002edc:	58025400 	.word	0x58025400
 8002ee0:	240002e8 	.word	0x240002e8
 8002ee4:	08005ac8 	.word	0x08005ac8
	...

08002ef0 <Vector254>:
/**
 * @brief   BDMA1 stream 4 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_BDMA1_CH4_HANDLER) {
 8002ef0:	b538      	push	{r3, r4, r5, lr}
  if ((oip->trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 8002ef2:	4d1d      	ldr	r5, [pc, #116]	; (8002f68 <Vector254+0x78>)
 8002ef4:	f8b5 3088 	ldrh.w	r3, [r5, #136]	; 0x88
 8002ef8:	f013 0404 	ands.w	r4, r3, #4
 8002efc:	d014      	beq.n	8002f28 <Vector254+0x38>
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (BDMA->ISR >> 16U) & STM32_BDMA_ISR_MASK;
 8002efe:	4b1b      	ldr	r3, [pc, #108]	; (8002f6c <Vector254+0x7c>)
  BDMA->IFCR = flags << 16U;
  if (bdma.streams[4].func)
 8002f00:	4a1b      	ldr	r2, [pc, #108]	; (8002f70 <Vector254+0x80>)
  flags = (BDMA->ISR >> 16U) & STM32_BDMA_ISR_MASK;
 8002f02:	6819      	ldr	r1, [r3, #0]
 8002f04:	0c09      	lsrs	r1, r1, #16
 8002f06:	f001 010e 	and.w	r1, r1, #14
  BDMA->IFCR = flags << 16U;
 8002f0a:	0408      	lsls	r0, r1, #16
 8002f0c:	6058      	str	r0, [r3, #4]
  if (bdma.streams[4].func)
 8002f0e:	6a53      	ldr	r3, [r2, #36]	; 0x24
 8002f10:	b10b      	cbz	r3, 8002f16 <Vector254+0x26>
    bdma.streams[4].func(bdma.streams[4].param, flags);
 8002f12:	6a90      	ldr	r0, [r2, #40]	; 0x28
 8002f14:	4798      	blx	r3
  if ((oip->trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 8002f16:	f8b5 3088 	ldrh.w	r3, [r5, #136]	; 0x88
 8002f1a:	f013 0404 	ands.w	r4, r3, #4
 8002f1e:	d011      	beq.n	8002f44 <Vector254+0x54>

  OSAL_IRQ_EPILOGUE();
}
 8002f20:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  OSAL_IRQ_EPILOGUE();
 8002f24:	f7fd bde4 	b.w	8000af0 <__port_irq_epilogue>
 8002f28:	2330      	movs	r3, #48	; 0x30
 8002f2a:	f383 8811 	msr	BASEPRI, r3
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 8002f2e:	2103      	movs	r1, #3
 8002f30:	f8d5 308c 	ldr.w	r3, [r5, #140]	; 0x8c
    oip->trace_buffer.ptr->u.isr.name  = isr;
 8002f34:	4a0f      	ldr	r2, [pc, #60]	; (8002f74 <Vector254+0x84>)
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 8002f36:	7019      	strb	r1, [r3, #0]
    oip->trace_buffer.ptr->u.isr.name  = isr;
 8002f38:	609a      	str	r2, [r3, #8]
    trace_next(oip);
 8002f3a:	f7fd ff19 	bl	8000d70 <trace_next.constprop.0>
 8002f3e:	f384 8811 	msr	BASEPRI, r4
}
 8002f42:	e7dc      	b.n	8002efe <Vector254+0xe>
 8002f44:	2330      	movs	r3, #48	; 0x30
 8002f46:	f383 8811 	msr	BASEPRI, r3
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 8002f4a:	2104      	movs	r1, #4
 8002f4c:	f8d5 308c 	ldr.w	r3, [r5, #140]	; 0x8c
    oip->trace_buffer.ptr->u.isr.name  = isr;
 8002f50:	4a08      	ldr	r2, [pc, #32]	; (8002f74 <Vector254+0x84>)
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 8002f52:	7019      	strb	r1, [r3, #0]
    oip->trace_buffer.ptr->u.isr.name  = isr;
 8002f54:	609a      	str	r2, [r3, #8]
    trace_next(oip);
 8002f56:	f7fd ff0b 	bl	8000d70 <trace_next.constprop.0>
 8002f5a:	f384 8811 	msr	BASEPRI, r4
}
 8002f5e:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  OSAL_IRQ_EPILOGUE();
 8002f62:	f7fd bdc5 	b.w	8000af0 <__port_irq_epilogue>
 8002f66:	bf00      	nop
 8002f68:	24000330 	.word	0x24000330
 8002f6c:	58025400 	.word	0x58025400
 8002f70:	240002e8 	.word	0x240002e8
 8002f74:	08005aa4 	.word	0x08005aa4
	...

08002f80 <Vector258>:
/**
 * @brief   BDMA1 stream 5 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_BDMA1_CH5_HANDLER) {
 8002f80:	b538      	push	{r3, r4, r5, lr}
  if ((oip->trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 8002f82:	4d1d      	ldr	r5, [pc, #116]	; (8002ff8 <Vector258+0x78>)
 8002f84:	f8b5 3088 	ldrh.w	r3, [r5, #136]	; 0x88
 8002f88:	f013 0404 	ands.w	r4, r3, #4
 8002f8c:	d014      	beq.n	8002fb8 <Vector258+0x38>
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (BDMA->ISR >> 20U) & STM32_BDMA_ISR_MASK;
 8002f8e:	4b1b      	ldr	r3, [pc, #108]	; (8002ffc <Vector258+0x7c>)
  BDMA->IFCR = flags << 20U;
  if (bdma.streams[5].func)
 8002f90:	4a1b      	ldr	r2, [pc, #108]	; (8003000 <Vector258+0x80>)
  flags = (BDMA->ISR >> 20U) & STM32_BDMA_ISR_MASK;
 8002f92:	6819      	ldr	r1, [r3, #0]
 8002f94:	0d09      	lsrs	r1, r1, #20
 8002f96:	f001 010e 	and.w	r1, r1, #14
  BDMA->IFCR = flags << 20U;
 8002f9a:	0508      	lsls	r0, r1, #20
 8002f9c:	6058      	str	r0, [r3, #4]
  if (bdma.streams[5].func)
 8002f9e:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
 8002fa0:	b10b      	cbz	r3, 8002fa6 <Vector258+0x26>
    bdma.streams[5].func(bdma.streams[5].param, flags);
 8002fa2:	6b10      	ldr	r0, [r2, #48]	; 0x30
 8002fa4:	4798      	blx	r3
  if ((oip->trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 8002fa6:	f8b5 3088 	ldrh.w	r3, [r5, #136]	; 0x88
 8002faa:	f013 0404 	ands.w	r4, r3, #4
 8002fae:	d011      	beq.n	8002fd4 <Vector258+0x54>

  OSAL_IRQ_EPILOGUE();
}
 8002fb0:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  OSAL_IRQ_EPILOGUE();
 8002fb4:	f7fd bd9c 	b.w	8000af0 <__port_irq_epilogue>
 8002fb8:	2330      	movs	r3, #48	; 0x30
 8002fba:	f383 8811 	msr	BASEPRI, r3
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 8002fbe:	2103      	movs	r1, #3
 8002fc0:	f8d5 308c 	ldr.w	r3, [r5, #140]	; 0x8c
    oip->trace_buffer.ptr->u.isr.name  = isr;
 8002fc4:	4a0f      	ldr	r2, [pc, #60]	; (8003004 <Vector258+0x84>)
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 8002fc6:	7019      	strb	r1, [r3, #0]
    oip->trace_buffer.ptr->u.isr.name  = isr;
 8002fc8:	609a      	str	r2, [r3, #8]
    trace_next(oip);
 8002fca:	f7fd fed1 	bl	8000d70 <trace_next.constprop.0>
 8002fce:	f384 8811 	msr	BASEPRI, r4
}
 8002fd2:	e7dc      	b.n	8002f8e <Vector258+0xe>
 8002fd4:	2330      	movs	r3, #48	; 0x30
 8002fd6:	f383 8811 	msr	BASEPRI, r3
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 8002fda:	2104      	movs	r1, #4
 8002fdc:	f8d5 308c 	ldr.w	r3, [r5, #140]	; 0x8c
    oip->trace_buffer.ptr->u.isr.name  = isr;
 8002fe0:	4a08      	ldr	r2, [pc, #32]	; (8003004 <Vector258+0x84>)
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 8002fe2:	7019      	strb	r1, [r3, #0]
    oip->trace_buffer.ptr->u.isr.name  = isr;
 8002fe4:	609a      	str	r2, [r3, #8]
    trace_next(oip);
 8002fe6:	f7fd fec3 	bl	8000d70 <trace_next.constprop.0>
 8002fea:	f384 8811 	msr	BASEPRI, r4
}
 8002fee:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  OSAL_IRQ_EPILOGUE();
 8002ff2:	f7fd bd7d 	b.w	8000af0 <__port_irq_epilogue>
 8002ff6:	bf00      	nop
 8002ff8:	24000330 	.word	0x24000330
 8002ffc:	58025400 	.word	0x58025400
 8003000:	240002e8 	.word	0x240002e8
 8003004:	08005a80 	.word	0x08005a80
	...

08003010 <Vector25C>:
/**
 * @brief   BDMA1 stream 6 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_BDMA1_CH6_HANDLER) {
 8003010:	b538      	push	{r3, r4, r5, lr}
  if ((oip->trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 8003012:	4d1d      	ldr	r5, [pc, #116]	; (8003088 <Vector25C+0x78>)
 8003014:	f8b5 3088 	ldrh.w	r3, [r5, #136]	; 0x88
 8003018:	f013 0404 	ands.w	r4, r3, #4
 800301c:	d014      	beq.n	8003048 <Vector25C+0x38>
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (BDMA->ISR >> 24U) & STM32_BDMA_ISR_MASK;
 800301e:	4b1b      	ldr	r3, [pc, #108]	; (800308c <Vector25C+0x7c>)
  BDMA->IFCR = flags << 24U;
  if (bdma.streams[6].func)
 8003020:	4a1b      	ldr	r2, [pc, #108]	; (8003090 <Vector25C+0x80>)
  flags = (BDMA->ISR >> 24U) & STM32_BDMA_ISR_MASK;
 8003022:	6819      	ldr	r1, [r3, #0]
 8003024:	0e09      	lsrs	r1, r1, #24
 8003026:	f001 010e 	and.w	r1, r1, #14
  BDMA->IFCR = flags << 24U;
 800302a:	0608      	lsls	r0, r1, #24
 800302c:	6058      	str	r0, [r3, #4]
  if (bdma.streams[6].func)
 800302e:	6b53      	ldr	r3, [r2, #52]	; 0x34
 8003030:	b10b      	cbz	r3, 8003036 <Vector25C+0x26>
    bdma.streams[6].func(bdma.streams[6].param, flags);
 8003032:	6b90      	ldr	r0, [r2, #56]	; 0x38
 8003034:	4798      	blx	r3
  if ((oip->trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 8003036:	f8b5 3088 	ldrh.w	r3, [r5, #136]	; 0x88
 800303a:	f013 0404 	ands.w	r4, r3, #4
 800303e:	d011      	beq.n	8003064 <Vector25C+0x54>

  OSAL_IRQ_EPILOGUE();
}
 8003040:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  OSAL_IRQ_EPILOGUE();
 8003044:	f7fd bd54 	b.w	8000af0 <__port_irq_epilogue>
 8003048:	2330      	movs	r3, #48	; 0x30
 800304a:	f383 8811 	msr	BASEPRI, r3
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 800304e:	2103      	movs	r1, #3
 8003050:	f8d5 308c 	ldr.w	r3, [r5, #140]	; 0x8c
    oip->trace_buffer.ptr->u.isr.name  = isr;
 8003054:	4a0f      	ldr	r2, [pc, #60]	; (8003094 <Vector25C+0x84>)
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 8003056:	7019      	strb	r1, [r3, #0]
    oip->trace_buffer.ptr->u.isr.name  = isr;
 8003058:	609a      	str	r2, [r3, #8]
    trace_next(oip);
 800305a:	f7fd fe89 	bl	8000d70 <trace_next.constprop.0>
 800305e:	f384 8811 	msr	BASEPRI, r4
}
 8003062:	e7dc      	b.n	800301e <Vector25C+0xe>
 8003064:	2330      	movs	r3, #48	; 0x30
 8003066:	f383 8811 	msr	BASEPRI, r3
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 800306a:	2104      	movs	r1, #4
 800306c:	f8d5 308c 	ldr.w	r3, [r5, #140]	; 0x8c
    oip->trace_buffer.ptr->u.isr.name  = isr;
 8003070:	4a08      	ldr	r2, [pc, #32]	; (8003094 <Vector25C+0x84>)
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 8003072:	7019      	strb	r1, [r3, #0]
    oip->trace_buffer.ptr->u.isr.name  = isr;
 8003074:	609a      	str	r2, [r3, #8]
    trace_next(oip);
 8003076:	f7fd fe7b 	bl	8000d70 <trace_next.constprop.0>
 800307a:	f384 8811 	msr	BASEPRI, r4
}
 800307e:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  OSAL_IRQ_EPILOGUE();
 8003082:	f7fd bd35 	b.w	8000af0 <__port_irq_epilogue>
 8003086:	bf00      	nop
 8003088:	24000330 	.word	0x24000330
 800308c:	58025400 	.word	0x58025400
 8003090:	240002e8 	.word	0x240002e8
 8003094:	08005a08 	.word	0x08005a08
	...

080030a0 <Vector260>:
/**
 * @brief   BDMA1 stream 7 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_BDMA1_CH7_HANDLER) {
 80030a0:	b538      	push	{r3, r4, r5, lr}
  if ((oip->trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 80030a2:	4d1d      	ldr	r5, [pc, #116]	; (8003118 <Vector260+0x78>)
 80030a4:	f8b5 3088 	ldrh.w	r3, [r5, #136]	; 0x88
 80030a8:	f013 0404 	ands.w	r4, r3, #4
 80030ac:	d014      	beq.n	80030d8 <Vector260+0x38>
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (BDMA->ISR >> 28U) & STM32_BDMA_ISR_MASK;
 80030ae:	4b1b      	ldr	r3, [pc, #108]	; (800311c <Vector260+0x7c>)
  BDMA->IFCR = flags << 28U;
  if (bdma.streams[7].func)
 80030b0:	4a1b      	ldr	r2, [pc, #108]	; (8003120 <Vector260+0x80>)
  flags = (BDMA->ISR >> 28U) & STM32_BDMA_ISR_MASK;
 80030b2:	6819      	ldr	r1, [r3, #0]
 80030b4:	0f09      	lsrs	r1, r1, #28
 80030b6:	f001 010e 	and.w	r1, r1, #14
  BDMA->IFCR = flags << 28U;
 80030ba:	0708      	lsls	r0, r1, #28
 80030bc:	6058      	str	r0, [r3, #4]
  if (bdma.streams[7].func)
 80030be:	6bd3      	ldr	r3, [r2, #60]	; 0x3c
 80030c0:	b10b      	cbz	r3, 80030c6 <Vector260+0x26>
    bdma.streams[7].func(bdma.streams[7].param, flags);
 80030c2:	6c10      	ldr	r0, [r2, #64]	; 0x40
 80030c4:	4798      	blx	r3
  if ((oip->trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 80030c6:	f8b5 3088 	ldrh.w	r3, [r5, #136]	; 0x88
 80030ca:	f013 0404 	ands.w	r4, r3, #4
 80030ce:	d011      	beq.n	80030f4 <Vector260+0x54>

  OSAL_IRQ_EPILOGUE();
}
 80030d0:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  OSAL_IRQ_EPILOGUE();
 80030d4:	f7fd bd0c 	b.w	8000af0 <__port_irq_epilogue>
 80030d8:	2330      	movs	r3, #48	; 0x30
 80030da:	f383 8811 	msr	BASEPRI, r3
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 80030de:	2103      	movs	r1, #3
 80030e0:	f8d5 308c 	ldr.w	r3, [r5, #140]	; 0x8c
    oip->trace_buffer.ptr->u.isr.name  = isr;
 80030e4:	4a0f      	ldr	r2, [pc, #60]	; (8003124 <Vector260+0x84>)
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 80030e6:	7019      	strb	r1, [r3, #0]
    oip->trace_buffer.ptr->u.isr.name  = isr;
 80030e8:	609a      	str	r2, [r3, #8]
    trace_next(oip);
 80030ea:	f7fd fe41 	bl	8000d70 <trace_next.constprop.0>
 80030ee:	f384 8811 	msr	BASEPRI, r4
}
 80030f2:	e7dc      	b.n	80030ae <Vector260+0xe>
 80030f4:	2330      	movs	r3, #48	; 0x30
 80030f6:	f383 8811 	msr	BASEPRI, r3
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 80030fa:	2104      	movs	r1, #4
 80030fc:	f8d5 308c 	ldr.w	r3, [r5, #140]	; 0x8c
    oip->trace_buffer.ptr->u.isr.name  = isr;
 8003100:	4a08      	ldr	r2, [pc, #32]	; (8003124 <Vector260+0x84>)
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 8003102:	7019      	strb	r1, [r3, #0]
    oip->trace_buffer.ptr->u.isr.name  = isr;
 8003104:	609a      	str	r2, [r3, #8]
    trace_next(oip);
 8003106:	f7fd fe33 	bl	8000d70 <trace_next.constprop.0>
 800310a:	f384 8811 	msr	BASEPRI, r4
}
 800310e:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  OSAL_IRQ_EPILOGUE();
 8003112:	f7fd bced 	b.w	8000af0 <__port_irq_epilogue>
 8003116:	bf00      	nop
 8003118:	24000330 	.word	0x24000330
 800311c:	58025400 	.word	0x58025400
 8003120:	240002e8 	.word	0x240002e8
 8003124:	080059c0 	.word	0x080059c0
	...

08003130 <Vector6C>:
/**
 * @brief   DMA1 stream 0 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH0_HANDLER) {
 8003130:	b538      	push	{r3, r4, r5, lr}
  if ((oip->trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 8003132:	4d1c      	ldr	r5, [pc, #112]	; (80031a4 <Vector6C+0x74>)
 8003134:	f8b5 3088 	ldrh.w	r3, [r5, #136]	; 0x88
 8003138:	f013 0404 	ands.w	r4, r3, #4
 800313c:	d012      	beq.n	8003164 <Vector6C+0x34>
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->LISR >> 0U) & STM32_DMA_ISR_MASK;
 800313e:	4b1a      	ldr	r3, [pc, #104]	; (80031a8 <Vector6C+0x78>)
  DMA1->LIFCR = flags << 0U;
  if (dma.streams[0].func)
 8003140:	481a      	ldr	r0, [pc, #104]	; (80031ac <Vector6C+0x7c>)
  flags = (DMA1->LISR >> 0U) & STM32_DMA_ISR_MASK;
 8003142:	6819      	ldr	r1, [r3, #0]
  if (dma.streams[0].func)
 8003144:	6842      	ldr	r2, [r0, #4]
  flags = (DMA1->LISR >> 0U) & STM32_DMA_ISR_MASK;
 8003146:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA1->LIFCR = flags << 0U;
 800314a:	6099      	str	r1, [r3, #8]
  if (dma.streams[0].func)
 800314c:	b10a      	cbz	r2, 8003152 <Vector6C+0x22>
    dma.streams[0].func(dma.streams[0].param, flags);
 800314e:	6880      	ldr	r0, [r0, #8]
 8003150:	4790      	blx	r2
  if ((oip->trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 8003152:	f8b5 3088 	ldrh.w	r3, [r5, #136]	; 0x88
 8003156:	f013 0404 	ands.w	r4, r3, #4
 800315a:	d011      	beq.n	8003180 <Vector6C+0x50>

  OSAL_IRQ_EPILOGUE();
}
 800315c:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  OSAL_IRQ_EPILOGUE();
 8003160:	f7fd bcc6 	b.w	8000af0 <__port_irq_epilogue>
 8003164:	2330      	movs	r3, #48	; 0x30
 8003166:	f383 8811 	msr	BASEPRI, r3
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 800316a:	2103      	movs	r1, #3
 800316c:	f8d5 308c 	ldr.w	r3, [r5, #140]	; 0x8c
    oip->trace_buffer.ptr->u.isr.name  = isr;
 8003170:	4a0f      	ldr	r2, [pc, #60]	; (80031b0 <Vector6C+0x80>)
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 8003172:	7019      	strb	r1, [r3, #0]
    oip->trace_buffer.ptr->u.isr.name  = isr;
 8003174:	609a      	str	r2, [r3, #8]
    trace_next(oip);
 8003176:	f7fd fdfb 	bl	8000d70 <trace_next.constprop.0>
 800317a:	f384 8811 	msr	BASEPRI, r4
}
 800317e:	e7de      	b.n	800313e <Vector6C+0xe>
 8003180:	2330      	movs	r3, #48	; 0x30
 8003182:	f383 8811 	msr	BASEPRI, r3
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 8003186:	2104      	movs	r1, #4
 8003188:	f8d5 308c 	ldr.w	r3, [r5, #140]	; 0x8c
    oip->trace_buffer.ptr->u.isr.name  = isr;
 800318c:	4a08      	ldr	r2, [pc, #32]	; (80031b0 <Vector6C+0x80>)
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 800318e:	7019      	strb	r1, [r3, #0]
    oip->trace_buffer.ptr->u.isr.name  = isr;
 8003190:	609a      	str	r2, [r3, #8]
    trace_next(oip);
 8003192:	f7fd fded 	bl	8000d70 <trace_next.constprop.0>
 8003196:	f384 8811 	msr	BASEPRI, r4
}
 800319a:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  OSAL_IRQ_EPILOGUE();
 800319e:	f7fd bca7 	b.w	8000af0 <__port_irq_epilogue>
 80031a2:	bf00      	nop
 80031a4:	24000330 	.word	0x24000330
 80031a8:	40020000 	.word	0x40020000
 80031ac:	24000d68 	.word	0x24000d68
 80031b0:	08005a68 	.word	0x08005a68
	...

080031c0 <Vector70>:
/**
 * @brief   DMA1 stream 1 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH1_HANDLER) {
 80031c0:	b538      	push	{r3, r4, r5, lr}
  if ((oip->trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 80031c2:	4d1d      	ldr	r5, [pc, #116]	; (8003238 <Vector70+0x78>)
 80031c4:	f8b5 3088 	ldrh.w	r3, [r5, #136]	; 0x88
 80031c8:	f013 0404 	ands.w	r4, r3, #4
 80031cc:	d014      	beq.n	80031f8 <Vector70+0x38>
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->LISR >> 6U) & STM32_DMA_ISR_MASK;
 80031ce:	4b1b      	ldr	r3, [pc, #108]	; (800323c <Vector70+0x7c>)
  DMA1->LIFCR = flags << 6U;
  if (dma.streams[1].func)
 80031d0:	4a1b      	ldr	r2, [pc, #108]	; (8003240 <Vector70+0x80>)
  flags = (DMA1->LISR >> 6U) & STM32_DMA_ISR_MASK;
 80031d2:	6819      	ldr	r1, [r3, #0]
 80031d4:	0989      	lsrs	r1, r1, #6
 80031d6:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA1->LIFCR = flags << 6U;
 80031da:	0188      	lsls	r0, r1, #6
 80031dc:	6098      	str	r0, [r3, #8]
  if (dma.streams[1].func)
 80031de:	68d3      	ldr	r3, [r2, #12]
 80031e0:	b10b      	cbz	r3, 80031e6 <Vector70+0x26>
    dma.streams[1].func(dma.streams[1].param, flags);
 80031e2:	6910      	ldr	r0, [r2, #16]
 80031e4:	4798      	blx	r3
  if ((oip->trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 80031e6:	f8b5 3088 	ldrh.w	r3, [r5, #136]	; 0x88
 80031ea:	f013 0404 	ands.w	r4, r3, #4
 80031ee:	d011      	beq.n	8003214 <Vector70+0x54>

  OSAL_IRQ_EPILOGUE();
}
 80031f0:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  OSAL_IRQ_EPILOGUE();
 80031f4:	f7fd bc7c 	b.w	8000af0 <__port_irq_epilogue>
 80031f8:	2330      	movs	r3, #48	; 0x30
 80031fa:	f383 8811 	msr	BASEPRI, r3
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 80031fe:	2103      	movs	r1, #3
 8003200:	f8d5 308c 	ldr.w	r3, [r5, #140]	; 0x8c
    oip->trace_buffer.ptr->u.isr.name  = isr;
 8003204:	4a0f      	ldr	r2, [pc, #60]	; (8003244 <Vector70+0x84>)
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 8003206:	7019      	strb	r1, [r3, #0]
    oip->trace_buffer.ptr->u.isr.name  = isr;
 8003208:	609a      	str	r2, [r3, #8]
    trace_next(oip);
 800320a:	f7fd fdb1 	bl	8000d70 <trace_next.constprop.0>
 800320e:	f384 8811 	msr	BASEPRI, r4
}
 8003212:	e7dc      	b.n	80031ce <Vector70+0xe>
 8003214:	2330      	movs	r3, #48	; 0x30
 8003216:	f383 8811 	msr	BASEPRI, r3
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 800321a:	2104      	movs	r1, #4
 800321c:	f8d5 308c 	ldr.w	r3, [r5, #140]	; 0x8c
    oip->trace_buffer.ptr->u.isr.name  = isr;
 8003220:	4a08      	ldr	r2, [pc, #32]	; (8003244 <Vector70+0x84>)
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 8003222:	7019      	strb	r1, [r3, #0]
    oip->trace_buffer.ptr->u.isr.name  = isr;
 8003224:	609a      	str	r2, [r3, #8]
    trace_next(oip);
 8003226:	f7fd fda3 	bl	8000d70 <trace_next.constprop.0>
 800322a:	f384 8811 	msr	BASEPRI, r4
}
 800322e:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  OSAL_IRQ_EPILOGUE();
 8003232:	f7fd bc5d 	b.w	8000af0 <__port_irq_epilogue>
 8003236:	bf00      	nop
 8003238:	24000330 	.word	0x24000330
 800323c:	40020000 	.word	0x40020000
 8003240:	24000d68 	.word	0x24000d68
 8003244:	08005a5c 	.word	0x08005a5c
	...

08003250 <Vector74>:
/**
 * @brief   DMA1 stream 2 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH2_HANDLER) {
 8003250:	b538      	push	{r3, r4, r5, lr}
  if ((oip->trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 8003252:	4d1d      	ldr	r5, [pc, #116]	; (80032c8 <Vector74+0x78>)
 8003254:	f8b5 3088 	ldrh.w	r3, [r5, #136]	; 0x88
 8003258:	f013 0404 	ands.w	r4, r3, #4
 800325c:	d014      	beq.n	8003288 <Vector74+0x38>
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->LISR >> 16U) & STM32_DMA_ISR_MASK;
 800325e:	4b1b      	ldr	r3, [pc, #108]	; (80032cc <Vector74+0x7c>)
  DMA1->LIFCR = flags << 16U;
  if (dma.streams[2].func)
 8003260:	4a1b      	ldr	r2, [pc, #108]	; (80032d0 <Vector74+0x80>)
  flags = (DMA1->LISR >> 16U) & STM32_DMA_ISR_MASK;
 8003262:	6819      	ldr	r1, [r3, #0]
 8003264:	0c09      	lsrs	r1, r1, #16
 8003266:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA1->LIFCR = flags << 16U;
 800326a:	0408      	lsls	r0, r1, #16
 800326c:	6098      	str	r0, [r3, #8]
  if (dma.streams[2].func)
 800326e:	6953      	ldr	r3, [r2, #20]
 8003270:	b10b      	cbz	r3, 8003276 <Vector74+0x26>
    dma.streams[2].func(dma.streams[2].param, flags);
 8003272:	6990      	ldr	r0, [r2, #24]
 8003274:	4798      	blx	r3
  if ((oip->trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 8003276:	f8b5 3088 	ldrh.w	r3, [r5, #136]	; 0x88
 800327a:	f013 0404 	ands.w	r4, r3, #4
 800327e:	d011      	beq.n	80032a4 <Vector74+0x54>

  OSAL_IRQ_EPILOGUE();
}
 8003280:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  OSAL_IRQ_EPILOGUE();
 8003284:	f7fd bc34 	b.w	8000af0 <__port_irq_epilogue>
 8003288:	2330      	movs	r3, #48	; 0x30
 800328a:	f383 8811 	msr	BASEPRI, r3
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 800328e:	2103      	movs	r1, #3
 8003290:	f8d5 308c 	ldr.w	r3, [r5, #140]	; 0x8c
    oip->trace_buffer.ptr->u.isr.name  = isr;
 8003294:	4a0f      	ldr	r2, [pc, #60]	; (80032d4 <Vector74+0x84>)
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 8003296:	7019      	strb	r1, [r3, #0]
    oip->trace_buffer.ptr->u.isr.name  = isr;
 8003298:	609a      	str	r2, [r3, #8]
    trace_next(oip);
 800329a:	f7fd fd69 	bl	8000d70 <trace_next.constprop.0>
 800329e:	f384 8811 	msr	BASEPRI, r4
}
 80032a2:	e7dc      	b.n	800325e <Vector74+0xe>
 80032a4:	2330      	movs	r3, #48	; 0x30
 80032a6:	f383 8811 	msr	BASEPRI, r3
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 80032aa:	2104      	movs	r1, #4
 80032ac:	f8d5 308c 	ldr.w	r3, [r5, #140]	; 0x8c
    oip->trace_buffer.ptr->u.isr.name  = isr;
 80032b0:	4a08      	ldr	r2, [pc, #32]	; (80032d4 <Vector74+0x84>)
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 80032b2:	7019      	strb	r1, [r3, #0]
    oip->trace_buffer.ptr->u.isr.name  = isr;
 80032b4:	609a      	str	r2, [r3, #8]
    trace_next(oip);
 80032b6:	f7fd fd5b 	bl	8000d70 <trace_next.constprop.0>
 80032ba:	f384 8811 	msr	BASEPRI, r4
}
 80032be:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  OSAL_IRQ_EPILOGUE();
 80032c2:	f7fd bc15 	b.w	8000af0 <__port_irq_epilogue>
 80032c6:	bf00      	nop
 80032c8:	24000330 	.word	0x24000330
 80032cc:	40020000 	.word	0x40020000
 80032d0:	24000d68 	.word	0x24000d68
 80032d4:	08005a50 	.word	0x08005a50
	...

080032e0 <Vector78>:
/**
 * @brief   DMA1 stream 3 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH3_HANDLER) {
 80032e0:	b538      	push	{r3, r4, r5, lr}
  if ((oip->trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 80032e2:	4d1d      	ldr	r5, [pc, #116]	; (8003358 <Vector78+0x78>)
 80032e4:	f8b5 3088 	ldrh.w	r3, [r5, #136]	; 0x88
 80032e8:	f013 0404 	ands.w	r4, r3, #4
 80032ec:	d014      	beq.n	8003318 <Vector78+0x38>
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->LISR >> 22U) & STM32_DMA_ISR_MASK;
 80032ee:	4b1b      	ldr	r3, [pc, #108]	; (800335c <Vector78+0x7c>)
  DMA1->LIFCR = flags << 22U;
  if (dma.streams[3].func)
 80032f0:	4a1b      	ldr	r2, [pc, #108]	; (8003360 <Vector78+0x80>)
  flags = (DMA1->LISR >> 22U) & STM32_DMA_ISR_MASK;
 80032f2:	6819      	ldr	r1, [r3, #0]
 80032f4:	0d89      	lsrs	r1, r1, #22
 80032f6:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA1->LIFCR = flags << 22U;
 80032fa:	0588      	lsls	r0, r1, #22
 80032fc:	6098      	str	r0, [r3, #8]
  if (dma.streams[3].func)
 80032fe:	69d3      	ldr	r3, [r2, #28]
 8003300:	b10b      	cbz	r3, 8003306 <Vector78+0x26>
    dma.streams[3].func(dma.streams[3].param, flags);
 8003302:	6a10      	ldr	r0, [r2, #32]
 8003304:	4798      	blx	r3
  if ((oip->trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 8003306:	f8b5 3088 	ldrh.w	r3, [r5, #136]	; 0x88
 800330a:	f013 0404 	ands.w	r4, r3, #4
 800330e:	d011      	beq.n	8003334 <Vector78+0x54>

  OSAL_IRQ_EPILOGUE();
}
 8003310:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  OSAL_IRQ_EPILOGUE();
 8003314:	f7fd bbec 	b.w	8000af0 <__port_irq_epilogue>
 8003318:	2330      	movs	r3, #48	; 0x30
 800331a:	f383 8811 	msr	BASEPRI, r3
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 800331e:	2103      	movs	r1, #3
 8003320:	f8d5 308c 	ldr.w	r3, [r5, #140]	; 0x8c
    oip->trace_buffer.ptr->u.isr.name  = isr;
 8003324:	4a0f      	ldr	r2, [pc, #60]	; (8003364 <Vector78+0x84>)
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 8003326:	7019      	strb	r1, [r3, #0]
    oip->trace_buffer.ptr->u.isr.name  = isr;
 8003328:	609a      	str	r2, [r3, #8]
    trace_next(oip);
 800332a:	f7fd fd21 	bl	8000d70 <trace_next.constprop.0>
 800332e:	f384 8811 	msr	BASEPRI, r4
}
 8003332:	e7dc      	b.n	80032ee <Vector78+0xe>
 8003334:	2330      	movs	r3, #48	; 0x30
 8003336:	f383 8811 	msr	BASEPRI, r3
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 800333a:	2104      	movs	r1, #4
 800333c:	f8d5 308c 	ldr.w	r3, [r5, #140]	; 0x8c
    oip->trace_buffer.ptr->u.isr.name  = isr;
 8003340:	4a08      	ldr	r2, [pc, #32]	; (8003364 <Vector78+0x84>)
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 8003342:	7019      	strb	r1, [r3, #0]
    oip->trace_buffer.ptr->u.isr.name  = isr;
 8003344:	609a      	str	r2, [r3, #8]
    trace_next(oip);
 8003346:	f7fd fd13 	bl	8000d70 <trace_next.constprop.0>
 800334a:	f384 8811 	msr	BASEPRI, r4
}
 800334e:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  OSAL_IRQ_EPILOGUE();
 8003352:	f7fd bbcd 	b.w	8000af0 <__port_irq_epilogue>
 8003356:	bf00      	nop
 8003358:	24000330 	.word	0x24000330
 800335c:	40020000 	.word	0x40020000
 8003360:	24000d68 	.word	0x24000d68
 8003364:	08005a44 	.word	0x08005a44
	...

08003370 <Vector7C>:
/**
 * @brief   DMA1 stream 4 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH4_HANDLER) {
 8003370:	b538      	push	{r3, r4, r5, lr}
  if ((oip->trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 8003372:	4d1c      	ldr	r5, [pc, #112]	; (80033e4 <Vector7C+0x74>)
 8003374:	f8b5 3088 	ldrh.w	r3, [r5, #136]	; 0x88
 8003378:	f013 0404 	ands.w	r4, r3, #4
 800337c:	d012      	beq.n	80033a4 <Vector7C+0x34>
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->HISR >> 0U) & STM32_DMA_ISR_MASK;
 800337e:	4b1a      	ldr	r3, [pc, #104]	; (80033e8 <Vector7C+0x78>)
  DMA1->HIFCR = flags << 0U;
  if (dma.streams[4].func)
 8003380:	481a      	ldr	r0, [pc, #104]	; (80033ec <Vector7C+0x7c>)
  flags = (DMA1->HISR >> 0U) & STM32_DMA_ISR_MASK;
 8003382:	6859      	ldr	r1, [r3, #4]
  if (dma.streams[4].func)
 8003384:	6a42      	ldr	r2, [r0, #36]	; 0x24
  flags = (DMA1->HISR >> 0U) & STM32_DMA_ISR_MASK;
 8003386:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA1->HIFCR = flags << 0U;
 800338a:	60d9      	str	r1, [r3, #12]
  if (dma.streams[4].func)
 800338c:	b10a      	cbz	r2, 8003392 <Vector7C+0x22>
    dma.streams[4].func(dma.streams[4].param, flags);
 800338e:	6a80      	ldr	r0, [r0, #40]	; 0x28
 8003390:	4790      	blx	r2
  if ((oip->trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 8003392:	f8b5 3088 	ldrh.w	r3, [r5, #136]	; 0x88
 8003396:	f013 0404 	ands.w	r4, r3, #4
 800339a:	d011      	beq.n	80033c0 <Vector7C+0x50>

  OSAL_IRQ_EPILOGUE();
}
 800339c:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  OSAL_IRQ_EPILOGUE();
 80033a0:	f7fd bba6 	b.w	8000af0 <__port_irq_epilogue>
 80033a4:	2330      	movs	r3, #48	; 0x30
 80033a6:	f383 8811 	msr	BASEPRI, r3
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 80033aa:	2103      	movs	r1, #3
 80033ac:	f8d5 308c 	ldr.w	r3, [r5, #140]	; 0x8c
    oip->trace_buffer.ptr->u.isr.name  = isr;
 80033b0:	4a0f      	ldr	r2, [pc, #60]	; (80033f0 <Vector7C+0x80>)
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 80033b2:	7019      	strb	r1, [r3, #0]
    oip->trace_buffer.ptr->u.isr.name  = isr;
 80033b4:	609a      	str	r2, [r3, #8]
    trace_next(oip);
 80033b6:	f7fd fcdb 	bl	8000d70 <trace_next.constprop.0>
 80033ba:	f384 8811 	msr	BASEPRI, r4
}
 80033be:	e7de      	b.n	800337e <Vector7C+0xe>
 80033c0:	2330      	movs	r3, #48	; 0x30
 80033c2:	f383 8811 	msr	BASEPRI, r3
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 80033c6:	2104      	movs	r1, #4
 80033c8:	f8d5 308c 	ldr.w	r3, [r5, #140]	; 0x8c
    oip->trace_buffer.ptr->u.isr.name  = isr;
 80033cc:	4a08      	ldr	r2, [pc, #32]	; (80033f0 <Vector7C+0x80>)
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 80033ce:	7019      	strb	r1, [r3, #0]
    oip->trace_buffer.ptr->u.isr.name  = isr;
 80033d0:	609a      	str	r2, [r3, #8]
    trace_next(oip);
 80033d2:	f7fd fccd 	bl	8000d70 <trace_next.constprop.0>
 80033d6:	f384 8811 	msr	BASEPRI, r4
}
 80033da:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  OSAL_IRQ_EPILOGUE();
 80033de:	f7fd bb87 	b.w	8000af0 <__port_irq_epilogue>
 80033e2:	bf00      	nop
 80033e4:	24000330 	.word	0x24000330
 80033e8:	40020000 	.word	0x40020000
 80033ec:	24000d68 	.word	0x24000d68
 80033f0:	08005a38 	.word	0x08005a38
	...

08003400 <Vector80>:
/**
 * @brief   DMA1 stream 5 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH5_HANDLER) {
 8003400:	b538      	push	{r3, r4, r5, lr}
  if ((oip->trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 8003402:	4d1d      	ldr	r5, [pc, #116]	; (8003478 <Vector80+0x78>)
 8003404:	f8b5 3088 	ldrh.w	r3, [r5, #136]	; 0x88
 8003408:	f013 0404 	ands.w	r4, r3, #4
 800340c:	d014      	beq.n	8003438 <Vector80+0x38>
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->HISR >> 6U) & STM32_DMA_ISR_MASK;
 800340e:	4b1b      	ldr	r3, [pc, #108]	; (800347c <Vector80+0x7c>)
  DMA1->HIFCR = flags << 6U;
  if (dma.streams[5].func)
 8003410:	4a1b      	ldr	r2, [pc, #108]	; (8003480 <Vector80+0x80>)
  flags = (DMA1->HISR >> 6U) & STM32_DMA_ISR_MASK;
 8003412:	6859      	ldr	r1, [r3, #4]
 8003414:	0989      	lsrs	r1, r1, #6
 8003416:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA1->HIFCR = flags << 6U;
 800341a:	0188      	lsls	r0, r1, #6
 800341c:	60d8      	str	r0, [r3, #12]
  if (dma.streams[5].func)
 800341e:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
 8003420:	b10b      	cbz	r3, 8003426 <Vector80+0x26>
    dma.streams[5].func(dma.streams[5].param, flags);
 8003422:	6b10      	ldr	r0, [r2, #48]	; 0x30
 8003424:	4798      	blx	r3
  if ((oip->trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 8003426:	f8b5 3088 	ldrh.w	r3, [r5, #136]	; 0x88
 800342a:	f013 0404 	ands.w	r4, r3, #4
 800342e:	d011      	beq.n	8003454 <Vector80+0x54>

  OSAL_IRQ_EPILOGUE();
}
 8003430:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  OSAL_IRQ_EPILOGUE();
 8003434:	f7fd bb5c 	b.w	8000af0 <__port_irq_epilogue>
 8003438:	2330      	movs	r3, #48	; 0x30
 800343a:	f383 8811 	msr	BASEPRI, r3
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 800343e:	2103      	movs	r1, #3
 8003440:	f8d5 308c 	ldr.w	r3, [r5, #140]	; 0x8c
    oip->trace_buffer.ptr->u.isr.name  = isr;
 8003444:	4a0f      	ldr	r2, [pc, #60]	; (8003484 <Vector80+0x84>)
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 8003446:	7019      	strb	r1, [r3, #0]
    oip->trace_buffer.ptr->u.isr.name  = isr;
 8003448:	609a      	str	r2, [r3, #8]
    trace_next(oip);
 800344a:	f7fd fc91 	bl	8000d70 <trace_next.constprop.0>
 800344e:	f384 8811 	msr	BASEPRI, r4
}
 8003452:	e7dc      	b.n	800340e <Vector80+0xe>
 8003454:	2330      	movs	r3, #48	; 0x30
 8003456:	f383 8811 	msr	BASEPRI, r3
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 800345a:	2104      	movs	r1, #4
 800345c:	f8d5 308c 	ldr.w	r3, [r5, #140]	; 0x8c
    oip->trace_buffer.ptr->u.isr.name  = isr;
 8003460:	4a08      	ldr	r2, [pc, #32]	; (8003484 <Vector80+0x84>)
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 8003462:	7019      	strb	r1, [r3, #0]
    oip->trace_buffer.ptr->u.isr.name  = isr;
 8003464:	609a      	str	r2, [r3, #8]
    trace_next(oip);
 8003466:	f7fd fc83 	bl	8000d70 <trace_next.constprop.0>
 800346a:	f384 8811 	msr	BASEPRI, r4
}
 800346e:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  OSAL_IRQ_EPILOGUE();
 8003472:	f7fd bb3d 	b.w	8000af0 <__port_irq_epilogue>
 8003476:	bf00      	nop
 8003478:	24000330 	.word	0x24000330
 800347c:	40020000 	.word	0x40020000
 8003480:	24000d68 	.word	0x24000d68
 8003484:	08005a2c 	.word	0x08005a2c
	...

08003490 <Vector84>:
/**
 * @brief   DMA1 stream 6 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH6_HANDLER) {
 8003490:	b538      	push	{r3, r4, r5, lr}
  if ((oip->trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 8003492:	4d1d      	ldr	r5, [pc, #116]	; (8003508 <Vector84+0x78>)
 8003494:	f8b5 3088 	ldrh.w	r3, [r5, #136]	; 0x88
 8003498:	f013 0404 	ands.w	r4, r3, #4
 800349c:	d014      	beq.n	80034c8 <Vector84+0x38>
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->HISR >> 16U) & STM32_DMA_ISR_MASK;
 800349e:	4b1b      	ldr	r3, [pc, #108]	; (800350c <Vector84+0x7c>)
  DMA1->HIFCR = flags << 16U;
  if (dma.streams[6].func)
 80034a0:	4a1b      	ldr	r2, [pc, #108]	; (8003510 <Vector84+0x80>)
  flags = (DMA1->HISR >> 16U) & STM32_DMA_ISR_MASK;
 80034a2:	6859      	ldr	r1, [r3, #4]
 80034a4:	0c09      	lsrs	r1, r1, #16
 80034a6:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA1->HIFCR = flags << 16U;
 80034aa:	0408      	lsls	r0, r1, #16
 80034ac:	60d8      	str	r0, [r3, #12]
  if (dma.streams[6].func)
 80034ae:	6b53      	ldr	r3, [r2, #52]	; 0x34
 80034b0:	b10b      	cbz	r3, 80034b6 <Vector84+0x26>
    dma.streams[6].func(dma.streams[6].param, flags);
 80034b2:	6b90      	ldr	r0, [r2, #56]	; 0x38
 80034b4:	4798      	blx	r3
  if ((oip->trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 80034b6:	f8b5 3088 	ldrh.w	r3, [r5, #136]	; 0x88
 80034ba:	f013 0404 	ands.w	r4, r3, #4
 80034be:	d011      	beq.n	80034e4 <Vector84+0x54>

  OSAL_IRQ_EPILOGUE();
}
 80034c0:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  OSAL_IRQ_EPILOGUE();
 80034c4:	f7fd bb14 	b.w	8000af0 <__port_irq_epilogue>
 80034c8:	2330      	movs	r3, #48	; 0x30
 80034ca:	f383 8811 	msr	BASEPRI, r3
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 80034ce:	2103      	movs	r1, #3
 80034d0:	f8d5 308c 	ldr.w	r3, [r5, #140]	; 0x8c
    oip->trace_buffer.ptr->u.isr.name  = isr;
 80034d4:	4a0f      	ldr	r2, [pc, #60]	; (8003514 <Vector84+0x84>)
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 80034d6:	7019      	strb	r1, [r3, #0]
    oip->trace_buffer.ptr->u.isr.name  = isr;
 80034d8:	609a      	str	r2, [r3, #8]
    trace_next(oip);
 80034da:	f7fd fc49 	bl	8000d70 <trace_next.constprop.0>
 80034de:	f384 8811 	msr	BASEPRI, r4
}
 80034e2:	e7dc      	b.n	800349e <Vector84+0xe>
 80034e4:	2330      	movs	r3, #48	; 0x30
 80034e6:	f383 8811 	msr	BASEPRI, r3
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 80034ea:	2104      	movs	r1, #4
 80034ec:	f8d5 308c 	ldr.w	r3, [r5, #140]	; 0x8c
    oip->trace_buffer.ptr->u.isr.name  = isr;
 80034f0:	4a08      	ldr	r2, [pc, #32]	; (8003514 <Vector84+0x84>)
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 80034f2:	7019      	strb	r1, [r3, #0]
    oip->trace_buffer.ptr->u.isr.name  = isr;
 80034f4:	609a      	str	r2, [r3, #8]
    trace_next(oip);
 80034f6:	f7fd fc3b 	bl	8000d70 <trace_next.constprop.0>
 80034fa:	f384 8811 	msr	BASEPRI, r4
}
 80034fe:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  OSAL_IRQ_EPILOGUE();
 8003502:	f7fd baf5 	b.w	8000af0 <__port_irq_epilogue>
 8003506:	bf00      	nop
 8003508:	24000330 	.word	0x24000330
 800350c:	40020000 	.word	0x40020000
 8003510:	24000d68 	.word	0x24000d68
 8003514:	08005b40 	.word	0x08005b40
	...

08003520 <VectorFC>:
/**
 * @brief   DMA1 stream 7 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH7_HANDLER) {
 8003520:	b538      	push	{r3, r4, r5, lr}
  if ((oip->trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 8003522:	4d1d      	ldr	r5, [pc, #116]	; (8003598 <VectorFC+0x78>)
 8003524:	f8b5 3088 	ldrh.w	r3, [r5, #136]	; 0x88
 8003528:	f013 0404 	ands.w	r4, r3, #4
 800352c:	d014      	beq.n	8003558 <VectorFC+0x38>
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->HISR >> 22U) & STM32_DMA_ISR_MASK;
 800352e:	4b1b      	ldr	r3, [pc, #108]	; (800359c <VectorFC+0x7c>)
  DMA1->HIFCR = flags << 22U;
  if (dma.streams[7].func)
 8003530:	4a1b      	ldr	r2, [pc, #108]	; (80035a0 <VectorFC+0x80>)
  flags = (DMA1->HISR >> 22U) & STM32_DMA_ISR_MASK;
 8003532:	6859      	ldr	r1, [r3, #4]
 8003534:	0d89      	lsrs	r1, r1, #22
 8003536:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA1->HIFCR = flags << 22U;
 800353a:	0588      	lsls	r0, r1, #22
 800353c:	60d8      	str	r0, [r3, #12]
  if (dma.streams[7].func)
 800353e:	6bd3      	ldr	r3, [r2, #60]	; 0x3c
 8003540:	b10b      	cbz	r3, 8003546 <VectorFC+0x26>
    dma.streams[7].func(dma.streams[7].param, flags);
 8003542:	6c10      	ldr	r0, [r2, #64]	; 0x40
 8003544:	4798      	blx	r3
  if ((oip->trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 8003546:	f8b5 3088 	ldrh.w	r3, [r5, #136]	; 0x88
 800354a:	f013 0404 	ands.w	r4, r3, #4
 800354e:	d011      	beq.n	8003574 <VectorFC+0x54>

  OSAL_IRQ_EPILOGUE();
}
 8003550:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  OSAL_IRQ_EPILOGUE();
 8003554:	f7fd bacc 	b.w	8000af0 <__port_irq_epilogue>
 8003558:	2330      	movs	r3, #48	; 0x30
 800355a:	f383 8811 	msr	BASEPRI, r3
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 800355e:	2103      	movs	r1, #3
 8003560:	f8d5 308c 	ldr.w	r3, [r5, #140]	; 0x8c
    oip->trace_buffer.ptr->u.isr.name  = isr;
 8003564:	4a0f      	ldr	r2, [pc, #60]	; (80035a4 <VectorFC+0x84>)
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 8003566:	7019      	strb	r1, [r3, #0]
    oip->trace_buffer.ptr->u.isr.name  = isr;
 8003568:	609a      	str	r2, [r3, #8]
    trace_next(oip);
 800356a:	f7fd fc01 	bl	8000d70 <trace_next.constprop.0>
 800356e:	f384 8811 	msr	BASEPRI, r4
}
 8003572:	e7dc      	b.n	800352e <VectorFC+0xe>
 8003574:	2330      	movs	r3, #48	; 0x30
 8003576:	f383 8811 	msr	BASEPRI, r3
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 800357a:	2104      	movs	r1, #4
 800357c:	f8d5 308c 	ldr.w	r3, [r5, #140]	; 0x8c
    oip->trace_buffer.ptr->u.isr.name  = isr;
 8003580:	4a08      	ldr	r2, [pc, #32]	; (80035a4 <VectorFC+0x84>)
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 8003582:	7019      	strb	r1, [r3, #0]
    oip->trace_buffer.ptr->u.isr.name  = isr;
 8003584:	609a      	str	r2, [r3, #8]
    trace_next(oip);
 8003586:	f7fd fbf3 	bl	8000d70 <trace_next.constprop.0>
 800358a:	f384 8811 	msr	BASEPRI, r4
}
 800358e:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  OSAL_IRQ_EPILOGUE();
 8003592:	f7fd baad 	b.w	8000af0 <__port_irq_epilogue>
 8003596:	bf00      	nop
 8003598:	24000330 	.word	0x24000330
 800359c:	40020000 	.word	0x40020000
 80035a0:	24000d68 	.word	0x24000d68
 80035a4:	08005b34 	.word	0x08005b34
	...

080035b0 <Vector120>:
/**
 * @brief   DMA2 stream 0 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH0_HANDLER) {
 80035b0:	b538      	push	{r3, r4, r5, lr}
  if ((oip->trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 80035b2:	4d1c      	ldr	r5, [pc, #112]	; (8003624 <Vector120+0x74>)
 80035b4:	f8b5 3088 	ldrh.w	r3, [r5, #136]	; 0x88
 80035b8:	f013 0404 	ands.w	r4, r3, #4
 80035bc:	d012      	beq.n	80035e4 <Vector120+0x34>
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->LISR >> 0U) & STM32_DMA_ISR_MASK;
 80035be:	4b1a      	ldr	r3, [pc, #104]	; (8003628 <Vector120+0x78>)
  DMA2->LIFCR = flags << 0U;
  if (dma.streams[8].func)
 80035c0:	481a      	ldr	r0, [pc, #104]	; (800362c <Vector120+0x7c>)
  flags = (DMA2->LISR >> 0U) & STM32_DMA_ISR_MASK;
 80035c2:	6819      	ldr	r1, [r3, #0]
  if (dma.streams[8].func)
 80035c4:	6c42      	ldr	r2, [r0, #68]	; 0x44
  flags = (DMA2->LISR >> 0U) & STM32_DMA_ISR_MASK;
 80035c6:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA2->LIFCR = flags << 0U;
 80035ca:	6099      	str	r1, [r3, #8]
  if (dma.streams[8].func)
 80035cc:	b10a      	cbz	r2, 80035d2 <Vector120+0x22>
    dma.streams[8].func(dma.streams[8].param, flags);
 80035ce:	6c80      	ldr	r0, [r0, #72]	; 0x48
 80035d0:	4790      	blx	r2
  if ((oip->trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 80035d2:	f8b5 3088 	ldrh.w	r3, [r5, #136]	; 0x88
 80035d6:	f013 0404 	ands.w	r4, r3, #4
 80035da:	d011      	beq.n	8003600 <Vector120+0x50>

  OSAL_IRQ_EPILOGUE();
}
 80035dc:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  OSAL_IRQ_EPILOGUE();
 80035e0:	f7fd ba86 	b.w	8000af0 <__port_irq_epilogue>
 80035e4:	2330      	movs	r3, #48	; 0x30
 80035e6:	f383 8811 	msr	BASEPRI, r3
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 80035ea:	2103      	movs	r1, #3
 80035ec:	f8d5 308c 	ldr.w	r3, [r5, #140]	; 0x8c
    oip->trace_buffer.ptr->u.isr.name  = isr;
 80035f0:	4a0f      	ldr	r2, [pc, #60]	; (8003630 <Vector120+0x80>)
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 80035f2:	7019      	strb	r1, [r3, #0]
    oip->trace_buffer.ptr->u.isr.name  = isr;
 80035f4:	609a      	str	r2, [r3, #8]
    trace_next(oip);
 80035f6:	f7fd fbbb 	bl	8000d70 <trace_next.constprop.0>
 80035fa:	f384 8811 	msr	BASEPRI, r4
}
 80035fe:	e7de      	b.n	80035be <Vector120+0xe>
 8003600:	2330      	movs	r3, #48	; 0x30
 8003602:	f383 8811 	msr	BASEPRI, r3
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 8003606:	2104      	movs	r1, #4
 8003608:	f8d5 308c 	ldr.w	r3, [r5, #140]	; 0x8c
    oip->trace_buffer.ptr->u.isr.name  = isr;
 800360c:	4a08      	ldr	r2, [pc, #32]	; (8003630 <Vector120+0x80>)
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 800360e:	7019      	strb	r1, [r3, #0]
    oip->trace_buffer.ptr->u.isr.name  = isr;
 8003610:	609a      	str	r2, [r3, #8]
    trace_next(oip);
 8003612:	f7fd fbad 	bl	8000d70 <trace_next.constprop.0>
 8003616:	f384 8811 	msr	BASEPRI, r4
}
 800361a:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  OSAL_IRQ_EPILOGUE();
 800361e:	f7fd ba67 	b.w	8000af0 <__port_irq_epilogue>
 8003622:	bf00      	nop
 8003624:	24000330 	.word	0x24000330
 8003628:	40020400 	.word	0x40020400
 800362c:	24000d68 	.word	0x24000d68
 8003630:	08005b28 	.word	0x08005b28
	...

08003640 <Vector124>:
/**
 * @brief   DMA2 stream 1 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH1_HANDLER) {
 8003640:	b538      	push	{r3, r4, r5, lr}
  if ((oip->trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 8003642:	4d1d      	ldr	r5, [pc, #116]	; (80036b8 <Vector124+0x78>)
 8003644:	f8b5 3088 	ldrh.w	r3, [r5, #136]	; 0x88
 8003648:	f013 0404 	ands.w	r4, r3, #4
 800364c:	d014      	beq.n	8003678 <Vector124+0x38>
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->LISR >> 6U) & STM32_DMA_ISR_MASK;
 800364e:	4b1b      	ldr	r3, [pc, #108]	; (80036bc <Vector124+0x7c>)
  DMA2->LIFCR = flags << 6U;
  if (dma.streams[9].func)
 8003650:	4a1b      	ldr	r2, [pc, #108]	; (80036c0 <Vector124+0x80>)
  flags = (DMA2->LISR >> 6U) & STM32_DMA_ISR_MASK;
 8003652:	6819      	ldr	r1, [r3, #0]
 8003654:	0989      	lsrs	r1, r1, #6
 8003656:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA2->LIFCR = flags << 6U;
 800365a:	0188      	lsls	r0, r1, #6
 800365c:	6098      	str	r0, [r3, #8]
  if (dma.streams[9].func)
 800365e:	6cd3      	ldr	r3, [r2, #76]	; 0x4c
 8003660:	b10b      	cbz	r3, 8003666 <Vector124+0x26>
    dma.streams[9].func(dma.streams[9].param, flags);
 8003662:	6d10      	ldr	r0, [r2, #80]	; 0x50
 8003664:	4798      	blx	r3
  if ((oip->trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 8003666:	f8b5 3088 	ldrh.w	r3, [r5, #136]	; 0x88
 800366a:	f013 0404 	ands.w	r4, r3, #4
 800366e:	d011      	beq.n	8003694 <Vector124+0x54>

  OSAL_IRQ_EPILOGUE();
}
 8003670:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  OSAL_IRQ_EPILOGUE();
 8003674:	f7fd ba3c 	b.w	8000af0 <__port_irq_epilogue>
 8003678:	2330      	movs	r3, #48	; 0x30
 800367a:	f383 8811 	msr	BASEPRI, r3
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 800367e:	2103      	movs	r1, #3
 8003680:	f8d5 308c 	ldr.w	r3, [r5, #140]	; 0x8c
    oip->trace_buffer.ptr->u.isr.name  = isr;
 8003684:	4a0f      	ldr	r2, [pc, #60]	; (80036c4 <Vector124+0x84>)
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 8003686:	7019      	strb	r1, [r3, #0]
    oip->trace_buffer.ptr->u.isr.name  = isr;
 8003688:	609a      	str	r2, [r3, #8]
    trace_next(oip);
 800368a:	f7fd fb71 	bl	8000d70 <trace_next.constprop.0>
 800368e:	f384 8811 	msr	BASEPRI, r4
}
 8003692:	e7dc      	b.n	800364e <Vector124+0xe>
 8003694:	2330      	movs	r3, #48	; 0x30
 8003696:	f383 8811 	msr	BASEPRI, r3
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 800369a:	2104      	movs	r1, #4
 800369c:	f8d5 308c 	ldr.w	r3, [r5, #140]	; 0x8c
    oip->trace_buffer.ptr->u.isr.name  = isr;
 80036a0:	4a08      	ldr	r2, [pc, #32]	; (80036c4 <Vector124+0x84>)
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 80036a2:	7019      	strb	r1, [r3, #0]
    oip->trace_buffer.ptr->u.isr.name  = isr;
 80036a4:	609a      	str	r2, [r3, #8]
    trace_next(oip);
 80036a6:	f7fd fb63 	bl	8000d70 <trace_next.constprop.0>
 80036aa:	f384 8811 	msr	BASEPRI, r4
}
 80036ae:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  OSAL_IRQ_EPILOGUE();
 80036b2:	f7fd ba1d 	b.w	8000af0 <__port_irq_epilogue>
 80036b6:	bf00      	nop
 80036b8:	24000330 	.word	0x24000330
 80036bc:	40020400 	.word	0x40020400
 80036c0:	24000d68 	.word	0x24000d68
 80036c4:	08005b10 	.word	0x08005b10
	...

080036d0 <Vector128>:
/**
 * @brief   DMA2 stream 2 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH2_HANDLER) {
 80036d0:	b538      	push	{r3, r4, r5, lr}
  if ((oip->trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 80036d2:	4d1d      	ldr	r5, [pc, #116]	; (8003748 <Vector128+0x78>)
 80036d4:	f8b5 3088 	ldrh.w	r3, [r5, #136]	; 0x88
 80036d8:	f013 0404 	ands.w	r4, r3, #4
 80036dc:	d014      	beq.n	8003708 <Vector128+0x38>
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->LISR >> 16U) & STM32_DMA_ISR_MASK;
 80036de:	4b1b      	ldr	r3, [pc, #108]	; (800374c <Vector128+0x7c>)
  DMA2->LIFCR = flags << 16U;
  if (dma.streams[10].func)
 80036e0:	4a1b      	ldr	r2, [pc, #108]	; (8003750 <Vector128+0x80>)
  flags = (DMA2->LISR >> 16U) & STM32_DMA_ISR_MASK;
 80036e2:	6819      	ldr	r1, [r3, #0]
 80036e4:	0c09      	lsrs	r1, r1, #16
 80036e6:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA2->LIFCR = flags << 16U;
 80036ea:	0408      	lsls	r0, r1, #16
 80036ec:	6098      	str	r0, [r3, #8]
  if (dma.streams[10].func)
 80036ee:	6d53      	ldr	r3, [r2, #84]	; 0x54
 80036f0:	b10b      	cbz	r3, 80036f6 <Vector128+0x26>
    dma.streams[10].func(dma.streams[10].param, flags);
 80036f2:	6d90      	ldr	r0, [r2, #88]	; 0x58
 80036f4:	4798      	blx	r3
  if ((oip->trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 80036f6:	f8b5 3088 	ldrh.w	r3, [r5, #136]	; 0x88
 80036fa:	f013 0404 	ands.w	r4, r3, #4
 80036fe:	d011      	beq.n	8003724 <Vector128+0x54>

  OSAL_IRQ_EPILOGUE();
}
 8003700:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  OSAL_IRQ_EPILOGUE();
 8003704:	f7fd b9f4 	b.w	8000af0 <__port_irq_epilogue>
 8003708:	2330      	movs	r3, #48	; 0x30
 800370a:	f383 8811 	msr	BASEPRI, r3
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 800370e:	2103      	movs	r1, #3
 8003710:	f8d5 308c 	ldr.w	r3, [r5, #140]	; 0x8c
    oip->trace_buffer.ptr->u.isr.name  = isr;
 8003714:	4a0f      	ldr	r2, [pc, #60]	; (8003754 <Vector128+0x84>)
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 8003716:	7019      	strb	r1, [r3, #0]
    oip->trace_buffer.ptr->u.isr.name  = isr;
 8003718:	609a      	str	r2, [r3, #8]
    trace_next(oip);
 800371a:	f7fd fb29 	bl	8000d70 <trace_next.constprop.0>
 800371e:	f384 8811 	msr	BASEPRI, r4
}
 8003722:	e7dc      	b.n	80036de <Vector128+0xe>
 8003724:	2330      	movs	r3, #48	; 0x30
 8003726:	f383 8811 	msr	BASEPRI, r3
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 800372a:	2104      	movs	r1, #4
 800372c:	f8d5 308c 	ldr.w	r3, [r5, #140]	; 0x8c
    oip->trace_buffer.ptr->u.isr.name  = isr;
 8003730:	4a08      	ldr	r2, [pc, #32]	; (8003754 <Vector128+0x84>)
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 8003732:	7019      	strb	r1, [r3, #0]
    oip->trace_buffer.ptr->u.isr.name  = isr;
 8003734:	609a      	str	r2, [r3, #8]
    trace_next(oip);
 8003736:	f7fd fb1b 	bl	8000d70 <trace_next.constprop.0>
 800373a:	f384 8811 	msr	BASEPRI, r4
}
 800373e:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  OSAL_IRQ_EPILOGUE();
 8003742:	f7fd b9d5 	b.w	8000af0 <__port_irq_epilogue>
 8003746:	bf00      	nop
 8003748:	24000330 	.word	0x24000330
 800374c:	40020400 	.word	0x40020400
 8003750:	24000d68 	.word	0x24000d68
 8003754:	08005af8 	.word	0x08005af8
	...

08003760 <Vector12C>:
/**
 * @brief   DMA2 stream 3 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH3_HANDLER) {
 8003760:	b538      	push	{r3, r4, r5, lr}
  if ((oip->trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 8003762:	4d1d      	ldr	r5, [pc, #116]	; (80037d8 <Vector12C+0x78>)
 8003764:	f8b5 3088 	ldrh.w	r3, [r5, #136]	; 0x88
 8003768:	f013 0404 	ands.w	r4, r3, #4
 800376c:	d014      	beq.n	8003798 <Vector12C+0x38>
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->LISR >> 22U) & STM32_DMA_ISR_MASK;
 800376e:	4b1b      	ldr	r3, [pc, #108]	; (80037dc <Vector12C+0x7c>)
  DMA2->LIFCR = flags << 22U;
  if (dma.streams[11].func)
 8003770:	4a1b      	ldr	r2, [pc, #108]	; (80037e0 <Vector12C+0x80>)
  flags = (DMA2->LISR >> 22U) & STM32_DMA_ISR_MASK;
 8003772:	6819      	ldr	r1, [r3, #0]
 8003774:	0d89      	lsrs	r1, r1, #22
 8003776:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA2->LIFCR = flags << 22U;
 800377a:	0588      	lsls	r0, r1, #22
 800377c:	6098      	str	r0, [r3, #8]
  if (dma.streams[11].func)
 800377e:	6dd3      	ldr	r3, [r2, #92]	; 0x5c
 8003780:	b10b      	cbz	r3, 8003786 <Vector12C+0x26>
    dma.streams[11].func(dma.streams[11].param, flags);
 8003782:	6e10      	ldr	r0, [r2, #96]	; 0x60
 8003784:	4798      	blx	r3
  if ((oip->trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 8003786:	f8b5 3088 	ldrh.w	r3, [r5, #136]	; 0x88
 800378a:	f013 0404 	ands.w	r4, r3, #4
 800378e:	d011      	beq.n	80037b4 <Vector12C+0x54>

  OSAL_IRQ_EPILOGUE();
}
 8003790:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  OSAL_IRQ_EPILOGUE();
 8003794:	f7fd b9ac 	b.w	8000af0 <__port_irq_epilogue>
 8003798:	2330      	movs	r3, #48	; 0x30
 800379a:	f383 8811 	msr	BASEPRI, r3
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 800379e:	2103      	movs	r1, #3
 80037a0:	f8d5 308c 	ldr.w	r3, [r5, #140]	; 0x8c
    oip->trace_buffer.ptr->u.isr.name  = isr;
 80037a4:	4a0f      	ldr	r2, [pc, #60]	; (80037e4 <Vector12C+0x84>)
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 80037a6:	7019      	strb	r1, [r3, #0]
    oip->trace_buffer.ptr->u.isr.name  = isr;
 80037a8:	609a      	str	r2, [r3, #8]
    trace_next(oip);
 80037aa:	f7fd fae1 	bl	8000d70 <trace_next.constprop.0>
 80037ae:	f384 8811 	msr	BASEPRI, r4
}
 80037b2:	e7dc      	b.n	800376e <Vector12C+0xe>
 80037b4:	2330      	movs	r3, #48	; 0x30
 80037b6:	f383 8811 	msr	BASEPRI, r3
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 80037ba:	2104      	movs	r1, #4
 80037bc:	f8d5 308c 	ldr.w	r3, [r5, #140]	; 0x8c
    oip->trace_buffer.ptr->u.isr.name  = isr;
 80037c0:	4a08      	ldr	r2, [pc, #32]	; (80037e4 <Vector12C+0x84>)
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 80037c2:	7019      	strb	r1, [r3, #0]
    oip->trace_buffer.ptr->u.isr.name  = isr;
 80037c4:	609a      	str	r2, [r3, #8]
    trace_next(oip);
 80037c6:	f7fd fad3 	bl	8000d70 <trace_next.constprop.0>
 80037ca:	f384 8811 	msr	BASEPRI, r4
}
 80037ce:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  OSAL_IRQ_EPILOGUE();
 80037d2:	f7fd b98d 	b.w	8000af0 <__port_irq_epilogue>
 80037d6:	bf00      	nop
 80037d8:	24000330 	.word	0x24000330
 80037dc:	40020400 	.word	0x40020400
 80037e0:	24000d68 	.word	0x24000d68
 80037e4:	08005ad4 	.word	0x08005ad4
	...

080037f0 <Vector130>:
/**
 * @brief   DMA2 stream 4 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH4_HANDLER) {
 80037f0:	b538      	push	{r3, r4, r5, lr}
  if ((oip->trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 80037f2:	4d1c      	ldr	r5, [pc, #112]	; (8003864 <Vector130+0x74>)
 80037f4:	f8b5 3088 	ldrh.w	r3, [r5, #136]	; 0x88
 80037f8:	f013 0404 	ands.w	r4, r3, #4
 80037fc:	d012      	beq.n	8003824 <Vector130+0x34>
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->HISR >> 0U) & STM32_DMA_ISR_MASK;
 80037fe:	4b1a      	ldr	r3, [pc, #104]	; (8003868 <Vector130+0x78>)
  DMA2->HIFCR = flags << 0U;
  if (dma.streams[12].func)
 8003800:	481a      	ldr	r0, [pc, #104]	; (800386c <Vector130+0x7c>)
  flags = (DMA2->HISR >> 0U) & STM32_DMA_ISR_MASK;
 8003802:	6859      	ldr	r1, [r3, #4]
  if (dma.streams[12].func)
 8003804:	6e42      	ldr	r2, [r0, #100]	; 0x64
  flags = (DMA2->HISR >> 0U) & STM32_DMA_ISR_MASK;
 8003806:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA2->HIFCR = flags << 0U;
 800380a:	60d9      	str	r1, [r3, #12]
  if (dma.streams[12].func)
 800380c:	b10a      	cbz	r2, 8003812 <Vector130+0x22>
    dma.streams[12].func(dma.streams[12].param, flags);
 800380e:	6e80      	ldr	r0, [r0, #104]	; 0x68
 8003810:	4790      	blx	r2
  if ((oip->trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 8003812:	f8b5 3088 	ldrh.w	r3, [r5, #136]	; 0x88
 8003816:	f013 0404 	ands.w	r4, r3, #4
 800381a:	d011      	beq.n	8003840 <Vector130+0x50>

  OSAL_IRQ_EPILOGUE();
}
 800381c:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  OSAL_IRQ_EPILOGUE();
 8003820:	f7fd b966 	b.w	8000af0 <__port_irq_epilogue>
 8003824:	2330      	movs	r3, #48	; 0x30
 8003826:	f383 8811 	msr	BASEPRI, r3
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 800382a:	2103      	movs	r1, #3
 800382c:	f8d5 308c 	ldr.w	r3, [r5, #140]	; 0x8c
    oip->trace_buffer.ptr->u.isr.name  = isr;
 8003830:	4a0f      	ldr	r2, [pc, #60]	; (8003870 <Vector130+0x80>)
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 8003832:	7019      	strb	r1, [r3, #0]
    oip->trace_buffer.ptr->u.isr.name  = isr;
 8003834:	609a      	str	r2, [r3, #8]
    trace_next(oip);
 8003836:	f7fd fa9b 	bl	8000d70 <trace_next.constprop.0>
 800383a:	f384 8811 	msr	BASEPRI, r4
}
 800383e:	e7de      	b.n	80037fe <Vector130+0xe>
 8003840:	2330      	movs	r3, #48	; 0x30
 8003842:	f383 8811 	msr	BASEPRI, r3
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 8003846:	2104      	movs	r1, #4
 8003848:	f8d5 308c 	ldr.w	r3, [r5, #140]	; 0x8c
    oip->trace_buffer.ptr->u.isr.name  = isr;
 800384c:	4a08      	ldr	r2, [pc, #32]	; (8003870 <Vector130+0x80>)
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 800384e:	7019      	strb	r1, [r3, #0]
    oip->trace_buffer.ptr->u.isr.name  = isr;
 8003850:	609a      	str	r2, [r3, #8]
    trace_next(oip);
 8003852:	f7fd fa8d 	bl	8000d70 <trace_next.constprop.0>
 8003856:	f384 8811 	msr	BASEPRI, r4
}
 800385a:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  OSAL_IRQ_EPILOGUE();
 800385e:	f7fd b947 	b.w	8000af0 <__port_irq_epilogue>
 8003862:	bf00      	nop
 8003864:	24000330 	.word	0x24000330
 8003868:	40020400 	.word	0x40020400
 800386c:	24000d68 	.word	0x24000d68
 8003870:	08005ab0 	.word	0x08005ab0
	...

08003880 <Vector150>:
/**
 * @brief   DMA2 stream 5 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH5_HANDLER) {
 8003880:	b538      	push	{r3, r4, r5, lr}
  if ((oip->trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 8003882:	4d1d      	ldr	r5, [pc, #116]	; (80038f8 <Vector150+0x78>)
 8003884:	f8b5 3088 	ldrh.w	r3, [r5, #136]	; 0x88
 8003888:	f013 0404 	ands.w	r4, r3, #4
 800388c:	d014      	beq.n	80038b8 <Vector150+0x38>
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->HISR >> 6U) & STM32_DMA_ISR_MASK;
 800388e:	4b1b      	ldr	r3, [pc, #108]	; (80038fc <Vector150+0x7c>)
  DMA2->HIFCR = flags << 6U;
  if (dma.streams[13].func)
 8003890:	4a1b      	ldr	r2, [pc, #108]	; (8003900 <Vector150+0x80>)
  flags = (DMA2->HISR >> 6U) & STM32_DMA_ISR_MASK;
 8003892:	6859      	ldr	r1, [r3, #4]
 8003894:	0989      	lsrs	r1, r1, #6
 8003896:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA2->HIFCR = flags << 6U;
 800389a:	0188      	lsls	r0, r1, #6
 800389c:	60d8      	str	r0, [r3, #12]
  if (dma.streams[13].func)
 800389e:	6ed3      	ldr	r3, [r2, #108]	; 0x6c
 80038a0:	b10b      	cbz	r3, 80038a6 <Vector150+0x26>
    dma.streams[13].func(dma.streams[13].param, flags);
 80038a2:	6f10      	ldr	r0, [r2, #112]	; 0x70
 80038a4:	4798      	blx	r3
  if ((oip->trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 80038a6:	f8b5 3088 	ldrh.w	r3, [r5, #136]	; 0x88
 80038aa:	f013 0404 	ands.w	r4, r3, #4
 80038ae:	d011      	beq.n	80038d4 <Vector150+0x54>

  OSAL_IRQ_EPILOGUE();
}
 80038b0:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  OSAL_IRQ_EPILOGUE();
 80038b4:	f7fd b91c 	b.w	8000af0 <__port_irq_epilogue>
 80038b8:	2330      	movs	r3, #48	; 0x30
 80038ba:	f383 8811 	msr	BASEPRI, r3
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 80038be:	2103      	movs	r1, #3
 80038c0:	f8d5 308c 	ldr.w	r3, [r5, #140]	; 0x8c
    oip->trace_buffer.ptr->u.isr.name  = isr;
 80038c4:	4a0f      	ldr	r2, [pc, #60]	; (8003904 <Vector150+0x84>)
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 80038c6:	7019      	strb	r1, [r3, #0]
    oip->trace_buffer.ptr->u.isr.name  = isr;
 80038c8:	609a      	str	r2, [r3, #8]
    trace_next(oip);
 80038ca:	f7fd fa51 	bl	8000d70 <trace_next.constprop.0>
 80038ce:	f384 8811 	msr	BASEPRI, r4
}
 80038d2:	e7dc      	b.n	800388e <Vector150+0xe>
 80038d4:	2330      	movs	r3, #48	; 0x30
 80038d6:	f383 8811 	msr	BASEPRI, r3
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 80038da:	2104      	movs	r1, #4
 80038dc:	f8d5 308c 	ldr.w	r3, [r5, #140]	; 0x8c
    oip->trace_buffer.ptr->u.isr.name  = isr;
 80038e0:	4a08      	ldr	r2, [pc, #32]	; (8003904 <Vector150+0x84>)
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 80038e2:	7019      	strb	r1, [r3, #0]
    oip->trace_buffer.ptr->u.isr.name  = isr;
 80038e4:	609a      	str	r2, [r3, #8]
    trace_next(oip);
 80038e6:	f7fd fa43 	bl	8000d70 <trace_next.constprop.0>
 80038ea:	f384 8811 	msr	BASEPRI, r4
}
 80038ee:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  OSAL_IRQ_EPILOGUE();
 80038f2:	f7fd b8fd 	b.w	8000af0 <__port_irq_epilogue>
 80038f6:	bf00      	nop
 80038f8:	24000330 	.word	0x24000330
 80038fc:	40020400 	.word	0x40020400
 8003900:	24000d68 	.word	0x24000d68
 8003904:	08005a8c 	.word	0x08005a8c
	...

08003910 <Vector154>:
/**
 * @brief   DMA2 stream 6 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH6_HANDLER) {
 8003910:	b538      	push	{r3, r4, r5, lr}
  if ((oip->trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 8003912:	4d1d      	ldr	r5, [pc, #116]	; (8003988 <Vector154+0x78>)
 8003914:	f8b5 3088 	ldrh.w	r3, [r5, #136]	; 0x88
 8003918:	f013 0404 	ands.w	r4, r3, #4
 800391c:	d014      	beq.n	8003948 <Vector154+0x38>
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->HISR >> 16U) & STM32_DMA_ISR_MASK;
 800391e:	4b1b      	ldr	r3, [pc, #108]	; (800398c <Vector154+0x7c>)
  DMA2->HIFCR = flags << 16U;
  if (dma.streams[14].func)
 8003920:	4a1b      	ldr	r2, [pc, #108]	; (8003990 <Vector154+0x80>)
  flags = (DMA2->HISR >> 16U) & STM32_DMA_ISR_MASK;
 8003922:	6859      	ldr	r1, [r3, #4]
 8003924:	0c09      	lsrs	r1, r1, #16
 8003926:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA2->HIFCR = flags << 16U;
 800392a:	0408      	lsls	r0, r1, #16
 800392c:	60d8      	str	r0, [r3, #12]
  if (dma.streams[14].func)
 800392e:	6f53      	ldr	r3, [r2, #116]	; 0x74
 8003930:	b10b      	cbz	r3, 8003936 <Vector154+0x26>
    dma.streams[14].func(dma.streams[14].param, flags);
 8003932:	6f90      	ldr	r0, [r2, #120]	; 0x78
 8003934:	4798      	blx	r3
  if ((oip->trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 8003936:	f8b5 3088 	ldrh.w	r3, [r5, #136]	; 0x88
 800393a:	f013 0404 	ands.w	r4, r3, #4
 800393e:	d011      	beq.n	8003964 <Vector154+0x54>

  OSAL_IRQ_EPILOGUE();
}
 8003940:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  OSAL_IRQ_EPILOGUE();
 8003944:	f7fd b8d4 	b.w	8000af0 <__port_irq_epilogue>
 8003948:	2330      	movs	r3, #48	; 0x30
 800394a:	f383 8811 	msr	BASEPRI, r3
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 800394e:	2103      	movs	r1, #3
 8003950:	f8d5 308c 	ldr.w	r3, [r5, #140]	; 0x8c
    oip->trace_buffer.ptr->u.isr.name  = isr;
 8003954:	4a0f      	ldr	r2, [pc, #60]	; (8003994 <Vector154+0x84>)
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 8003956:	7019      	strb	r1, [r3, #0]
    oip->trace_buffer.ptr->u.isr.name  = isr;
 8003958:	609a      	str	r2, [r3, #8]
    trace_next(oip);
 800395a:	f7fd fa09 	bl	8000d70 <trace_next.constprop.0>
 800395e:	f384 8811 	msr	BASEPRI, r4
}
 8003962:	e7dc      	b.n	800391e <Vector154+0xe>
 8003964:	2330      	movs	r3, #48	; 0x30
 8003966:	f383 8811 	msr	BASEPRI, r3
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 800396a:	2104      	movs	r1, #4
 800396c:	f8d5 308c 	ldr.w	r3, [r5, #140]	; 0x8c
    oip->trace_buffer.ptr->u.isr.name  = isr;
 8003970:	4a08      	ldr	r2, [pc, #32]	; (8003994 <Vector154+0x84>)
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 8003972:	7019      	strb	r1, [r3, #0]
    oip->trace_buffer.ptr->u.isr.name  = isr;
 8003974:	609a      	str	r2, [r3, #8]
    trace_next(oip);
 8003976:	f7fd f9fb 	bl	8000d70 <trace_next.constprop.0>
 800397a:	f384 8811 	msr	BASEPRI, r4
}
 800397e:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  OSAL_IRQ_EPILOGUE();
 8003982:	f7fd b8b5 	b.w	8000af0 <__port_irq_epilogue>
 8003986:	bf00      	nop
 8003988:	24000330 	.word	0x24000330
 800398c:	40020400 	.word	0x40020400
 8003990:	24000d68 	.word	0x24000d68
 8003994:	08005a14 	.word	0x08005a14
	...

080039a0 <Vector158>:
/**
 * @brief   DMA2 stream 7 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH7_HANDLER) {
 80039a0:	b538      	push	{r3, r4, r5, lr}
  if ((oip->trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 80039a2:	4d1d      	ldr	r5, [pc, #116]	; (8003a18 <Vector158+0x78>)
 80039a4:	f8b5 3088 	ldrh.w	r3, [r5, #136]	; 0x88
 80039a8:	f013 0404 	ands.w	r4, r3, #4
 80039ac:	d015      	beq.n	80039da <Vector158+0x3a>
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->HISR >> 22U) & STM32_DMA_ISR_MASK;
 80039ae:	4b1b      	ldr	r3, [pc, #108]	; (8003a1c <Vector158+0x7c>)
  DMA2->HIFCR = flags << 22U;
  if (dma.streams[15].func)
 80039b0:	4a1b      	ldr	r2, [pc, #108]	; (8003a20 <Vector158+0x80>)
  flags = (DMA2->HISR >> 22U) & STM32_DMA_ISR_MASK;
 80039b2:	6859      	ldr	r1, [r3, #4]
 80039b4:	0d89      	lsrs	r1, r1, #22
 80039b6:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA2->HIFCR = flags << 22U;
 80039ba:	0588      	lsls	r0, r1, #22
 80039bc:	60d8      	str	r0, [r3, #12]
  if (dma.streams[15].func)
 80039be:	6fd3      	ldr	r3, [r2, #124]	; 0x7c
 80039c0:	b113      	cbz	r3, 80039c8 <Vector158+0x28>
    dma.streams[15].func(dma.streams[15].param, flags);
 80039c2:	f8d2 0080 	ldr.w	r0, [r2, #128]	; 0x80
 80039c6:	4798      	blx	r3
  if ((oip->trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 80039c8:	f8b5 3088 	ldrh.w	r3, [r5, #136]	; 0x88
 80039cc:	f013 0404 	ands.w	r4, r3, #4
 80039d0:	d011      	beq.n	80039f6 <Vector158+0x56>

  OSAL_IRQ_EPILOGUE();
}
 80039d2:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  OSAL_IRQ_EPILOGUE();
 80039d6:	f7fd b88b 	b.w	8000af0 <__port_irq_epilogue>
 80039da:	2330      	movs	r3, #48	; 0x30
 80039dc:	f383 8811 	msr	BASEPRI, r3
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 80039e0:	2103      	movs	r1, #3
 80039e2:	f8d5 308c 	ldr.w	r3, [r5, #140]	; 0x8c
    oip->trace_buffer.ptr->u.isr.name  = isr;
 80039e6:	4a0f      	ldr	r2, [pc, #60]	; (8003a24 <Vector158+0x84>)
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 80039e8:	7019      	strb	r1, [r3, #0]
    oip->trace_buffer.ptr->u.isr.name  = isr;
 80039ea:	609a      	str	r2, [r3, #8]
    trace_next(oip);
 80039ec:	f7fd f9c0 	bl	8000d70 <trace_next.constprop.0>
 80039f0:	f384 8811 	msr	BASEPRI, r4
}
 80039f4:	e7db      	b.n	80039ae <Vector158+0xe>
 80039f6:	2330      	movs	r3, #48	; 0x30
 80039f8:	f383 8811 	msr	BASEPRI, r3
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 80039fc:	2104      	movs	r1, #4
 80039fe:	f8d5 308c 	ldr.w	r3, [r5, #140]	; 0x8c
    oip->trace_buffer.ptr->u.isr.name  = isr;
 8003a02:	4a08      	ldr	r2, [pc, #32]	; (8003a24 <Vector158+0x84>)
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 8003a04:	7019      	strb	r1, [r3, #0]
    oip->trace_buffer.ptr->u.isr.name  = isr;
 8003a06:	609a      	str	r2, [r3, #8]
    trace_next(oip);
 8003a08:	f7fd f9b2 	bl	8000d70 <trace_next.constprop.0>
 8003a0c:	f384 8811 	msr	BASEPRI, r4
}
 8003a10:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  OSAL_IRQ_EPILOGUE();
 8003a14:	f7fd b86c 	b.w	8000af0 <__port_irq_epilogue>
 8003a18:	24000330 	.word	0x24000330
 8003a1c:	40020400 	.word	0x40020400
 8003a20:	24000d68 	.word	0x24000d68
 8003a24:	080059cc 	.word	0x080059cc
	...

08003a30 <Vector1D4>:
OSAL_IRQ_HANDLER(STM32_OTG1_HANDLER) {
 8003a30:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  if ((oip->trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 8003a34:	f8df 928c 	ldr.w	r9, [pc, #652]	; 8003cc4 <Vector1D4+0x294>
 8003a38:	f8b9 3088 	ldrh.w	r3, [r9, #136]	; 0x88
 8003a3c:	f013 0404 	ands.w	r4, r3, #4
 8003a40:	f000 80ee 	beq.w	8003c20 <Vector1D4+0x1f0>
  stm32_otg_t *otgp = usbp->otg;
 8003a44:	4ea0      	ldr	r6, [pc, #640]	; (8003cc8 <Vector1D4+0x298>)
 8003a46:	f8d6 4090 	ldr.w	r4, [r6, #144]	; 0x90
  sts  = otgp->GINTSTS;
 8003a4a:	6967      	ldr	r7, [r4, #20]
  sts &= otgp->GINTMSK;
 8003a4c:	69a3      	ldr	r3, [r4, #24]
 8003a4e:	401f      	ands	r7, r3
  if (sts & GINTSTS_USBRST) {
 8003a50:	f417 5880 	ands.w	r8, r7, #4096	; 0x1000
  otgp->GINTSTS = sts;
 8003a54:	6167      	str	r7, [r4, #20]
  if (sts & GINTSTS_USBRST) {
 8003a56:	f040 8162 	bne.w	8003d1e <Vector1D4+0x2ee>
  if (sts & GINTSTS_WKUPINT) {
 8003a5a:	2f00      	cmp	r7, #0
 8003a5c:	f2c0 80b5 	blt.w	8003bca <Vector1D4+0x19a>
  if (sts & GINTSTS_USBSUSP) {
 8003a60:	053b      	lsls	r3, r7, #20
 8003a62:	f100 80cb 	bmi.w	8003bfc <Vector1D4+0x1cc>
  if (sts & GINTSTS_ENUMDNE) {
 8003a66:	04bd      	lsls	r5, r7, #18
 8003a68:	d50c      	bpl.n	8003a84 <Vector1D4+0x54>
    if ((otgp->DSTS & DSTS_ENUMSPD_MASK) == DSTS_ENUMSPD_HS_480) {
 8003a6a:	f8d4 3808 	ldr.w	r3, [r4, #2056]	; 0x808
 8003a6e:	f013 0f06 	tst.w	r3, #6
      otgp->GUSBCFG = (otgp->GUSBCFG & ~(GUSBCFG_TRDT_MASK)) |
 8003a72:	68e3      	ldr	r3, [r4, #12]
 8003a74:	f423 5370 	bic.w	r3, r3, #15360	; 0x3c00
 8003a78:	bf0c      	ite	eq
 8003a7a:	f443 5310 	orreq.w	r3, r3, #9216	; 0x2400
      otgp->GUSBCFG = (otgp->GUSBCFG & ~(GUSBCFG_TRDT_MASK)) |
 8003a7e:	f443 53a0 	orrne.w	r3, r3, #5120	; 0x1400
 8003a82:	60e3      	str	r3, [r4, #12]
  if (sts & GINTSTS_SOF) {
 8003a84:	0738      	lsls	r0, r7, #28
 8003a86:	d44d      	bmi.n	8003b24 <Vector1D4+0xf4>
  if (sts & GINTSTS_IISOIXFR) {
 8003a88:	02f9      	lsls	r1, r7, #11
 8003a8a:	d453      	bmi.n	8003b34 <Vector1D4+0x104>
  if (sts & GINTSTS_IISOOXFR) {
 8003a8c:	02ba      	lsls	r2, r7, #10
 8003a8e:	f100 8112 	bmi.w	8003cb6 <Vector1D4+0x286>
  if ((sts & GINTSTS_RXFLVL) != 0U) {
 8003a92:	06fb      	lsls	r3, r7, #27
 8003a94:	f100 80e3 	bmi.w	8003c5e <Vector1D4+0x22e>
  if (sts & GINTSTS_OEPINT) {
 8003a98:	033b      	lsls	r3, r7, #12
  src = otgp->DAINT;
 8003a9a:	f8d4 4818 	ldr.w	r4, [r4, #2072]	; 0x818
  if (sts & GINTSTS_OEPINT) {
 8003a9e:	d51a      	bpl.n	8003ad6 <Vector1D4+0xa6>
    if (src & (1 << 16))
 8003aa0:	03e6      	lsls	r6, r4, #15
 8003aa2:	f100 823b 	bmi.w	8003f1c <Vector1D4+0x4ec>
    if (src & (1 << 17))
 8003aa6:	03a5      	lsls	r5, r4, #14
 8003aa8:	f100 8234 	bmi.w	8003f14 <Vector1D4+0x4e4>
    if (src & (1 << 18))
 8003aac:	0360      	lsls	r0, r4, #13
 8003aae:	f100 822d 	bmi.w	8003f0c <Vector1D4+0x4dc>
    if (src & (1 << 19))
 8003ab2:	0321      	lsls	r1, r4, #12
 8003ab4:	f100 820e 	bmi.w	8003ed4 <Vector1D4+0x4a4>
    if (src & (1 << 20))
 8003ab8:	02e2      	lsls	r2, r4, #11
 8003aba:	f100 8211 	bmi.w	8003ee0 <Vector1D4+0x4b0>
    if (src & (1 << 21))
 8003abe:	02a3      	lsls	r3, r4, #10
 8003ac0:	f100 8214 	bmi.w	8003eec <Vector1D4+0x4bc>
    if (src & (1 << 22))
 8003ac4:	0266      	lsls	r6, r4, #9
 8003ac6:	f100 8217 	bmi.w	8003ef8 <Vector1D4+0x4c8>
    if (src & (1 << 23))
 8003aca:	0225      	lsls	r5, r4, #8
 8003acc:	f100 821a 	bmi.w	8003f04 <Vector1D4+0x4d4>
    if (src & (1 << 24))
 8003ad0:	01e0      	lsls	r0, r4, #7
 8003ad2:	f100 819a 	bmi.w	8003e0a <Vector1D4+0x3da>
  if (sts & GINTSTS_IEPINT) {
 8003ad6:	0379      	lsls	r1, r7, #13
 8003ad8:	d51a      	bpl.n	8003b10 <Vector1D4+0xe0>
    if (src & (1 << 0))
 8003ada:	07e2      	lsls	r2, r4, #31
 8003adc:	f100 81cc 	bmi.w	8003e78 <Vector1D4+0x448>
    if (src & (1 << 1))
 8003ae0:	07a3      	lsls	r3, r4, #30
 8003ae2:	f100 81cf 	bmi.w	8003e84 <Vector1D4+0x454>
    if (src & (1 << 2))
 8003ae6:	0767      	lsls	r7, r4, #29
 8003ae8:	f100 81d2 	bmi.w	8003e90 <Vector1D4+0x460>
    if (src & (1 << 3))
 8003aec:	0726      	lsls	r6, r4, #28
 8003aee:	f100 81d5 	bmi.w	8003e9c <Vector1D4+0x46c>
    if (src & (1 << 4))
 8003af2:	06e5      	lsls	r5, r4, #27
 8003af4:	f100 81d8 	bmi.w	8003ea8 <Vector1D4+0x478>
    if (src & (1 << 5))
 8003af8:	06a0      	lsls	r0, r4, #26
 8003afa:	f100 81db 	bmi.w	8003eb4 <Vector1D4+0x484>
    if (src & (1 << 6))
 8003afe:	0661      	lsls	r1, r4, #25
 8003b00:	f100 81de 	bmi.w	8003ec0 <Vector1D4+0x490>
    if (src & (1 << 7))
 8003b04:	0622      	lsls	r2, r4, #24
 8003b06:	f100 81e1 	bmi.w	8003ecc <Vector1D4+0x49c>
    if (src & (1 << 8))
 8003b0a:	05e3      	lsls	r3, r4, #23
 8003b0c:	f100 8184 	bmi.w	8003e18 <Vector1D4+0x3e8>
  if ((oip->trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 8003b10:	f8b9 3088 	ldrh.w	r3, [r9, #136]	; 0x88
 8003b14:	f013 0404 	ands.w	r4, r3, #4
 8003b18:	f000 8090 	beq.w	8003c3c <Vector1D4+0x20c>
}
 8003b1c:	e8bd 4ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  OSAL_IRQ_EPILOGUE();
 8003b20:	f7fc bfe6 	b.w	8000af0 <__port_irq_epilogue>
    _usb_isr_invoke_sof_cb(usbp);
 8003b24:	6873      	ldr	r3, [r6, #4]
 8003b26:	68db      	ldr	r3, [r3, #12]
 8003b28:	2b00      	cmp	r3, #0
 8003b2a:	d0ad      	beq.n	8003a88 <Vector1D4+0x58>
 8003b2c:	4866      	ldr	r0, [pc, #408]	; (8003cc8 <Vector1D4+0x298>)
 8003b2e:	4798      	blx	r3
  if (sts & GINTSTS_IISOIXFR) {
 8003b30:	02f9      	lsls	r1, r7, #11
 8003b32:	d5ab      	bpl.n	8003a8c <Vector1D4+0x5c>
  for (ep = 0; ep <= usbp->otgparams->num_endpoints; ep++) {
 8003b34:	f04f 0c00 	mov.w	ip, #0
  stm32_otg_t *otgp = usbp->otg;
 8003b38:	f8d6 a090 	ldr.w	sl, [r6, #144]	; 0x90
 8003b3c:	f8df b18c 	ldr.w	fp, [pc, #396]	; 8003ccc <Vector1D4+0x29c>
      _usb_isr_invoke_in_cb(usbp, ep);
 8003b40:	2201      	movs	r2, #1
  for (ep = 0; ep <= usbp->otgparams->num_endpoints; ep++) {
 8003b42:	4665      	mov	r5, ip
      _usb_isr_invoke_in_cb(usbp, ep);
 8003b44:	4860      	ldr	r0, [pc, #384]	; (8003cc8 <Vector1D4+0x298>)
 8003b46:	e007      	b.n	8003b58 <Vector1D4+0x128>
  for (ep = 0; ep <= usbp->otgparams->num_endpoints; ep++) {
 8003b48:	3501      	adds	r5, #1
 8003b4a:	f8d6 3094 	ldr.w	r3, [r6, #148]	; 0x94
 8003b4e:	b2ed      	uxtb	r5, r5
 8003b50:	689b      	ldr	r3, [r3, #8]
 8003b52:	429d      	cmp	r5, r3
 8003b54:	46ac      	mov	ip, r5
 8003b56:	d899      	bhi.n	8003a8c <Vector1D4+0x5c>
 8003b58:	eb0a 1145 	add.w	r1, sl, r5, lsl #5
    if (((otgp->ie[ep].DIEPCTL & DIEPCTL_EPTYP_MASK) == DIEPCTL_EPTYP_ISO) &&
 8003b5c:	f8d1 3900 	ldr.w	r3, [r1, #2304]	; 0x900
 8003b60:	f403 2340 	and.w	r3, r3, #786432	; 0xc0000
 8003b64:	f5b3 2f80 	cmp.w	r3, #262144	; 0x40000
 8003b68:	d1ee      	bne.n	8003b48 <Vector1D4+0x118>
        ((otgp->ie[ep].DIEPCTL & DIEPCTL_EPENA) != 0)) {
 8003b6a:	f8d1 3900 	ldr.w	r3, [r1, #2304]	; 0x900
    if (((otgp->ie[ep].DIEPCTL & DIEPCTL_EPTYP_MASK) == DIEPCTL_EPTYP_ISO) &&
 8003b6e:	2b00      	cmp	r3, #0
 8003b70:	daea      	bge.n	8003b48 <Vector1D4+0x118>
      otgp->ie[ep].DIEPCTL |= (DIEPCTL_EPDIS | DIEPCTL_SNAK);
 8003b72:	f8d1 3900 	ldr.w	r3, [r1, #2304]	; 0x900
 8003b76:	f043 4390 	orr.w	r3, r3, #1207959552	; 0x48000000
 8003b7a:	f8c1 3900 	str.w	r3, [r1, #2304]	; 0x900
      while (otgp->ie[ep].DIEPCTL & DIEPCTL_EPENA)
 8003b7e:	f8d1 3900 	ldr.w	r3, [r1, #2304]	; 0x900
 8003b82:	2b00      	cmp	r3, #0
 8003b84:	dbfb      	blt.n	8003b7e <Vector1D4+0x14e>
  otgp->GRSTCTL = GRSTCTL_TXFNUM(fifo) | GRSTCTL_TXFFLSH;
 8003b86:	ea4f 1c8c 	mov.w	ip, ip, lsl #6
 8003b8a:	f8d6 1090 	ldr.w	r1, [r6, #144]	; 0x90
 8003b8e:	f04c 0320 	orr.w	r3, ip, #32
 8003b92:	610b      	str	r3, [r1, #16]
  while ((otgp->GRSTCTL & GRSTCTL_TXFFLSH) != 0)
 8003b94:	690b      	ldr	r3, [r1, #16]
 8003b96:	069b      	lsls	r3, r3, #26
 8003b98:	d4fc      	bmi.n	8003b94 <Vector1D4+0x164>
 8003b9a:	f8db 1004 	ldr.w	r1, [fp, #4]
 8003b9e:	f8db 3004 	ldr.w	r3, [fp, #4]
  return (bool)(((rtcnt_t)cnt - (rtcnt_t)start) <
 8003ba2:	1a5b      	subs	r3, r3, r1
  while (chSysIsCounterWithinX(chSysGetRealtimeCounterX(), start, end)) {
 8003ba4:	2b11      	cmp	r3, #17
 8003ba6:	d9fa      	bls.n	8003b9e <Vector1D4+0x16e>
      _usb_isr_invoke_in_cb(usbp, ep);
 8003ba8:	eb06 0385 	add.w	r3, r6, r5, lsl #2
 8003bac:	8931      	ldrh	r1, [r6, #8]
 8003bae:	fa02 fc05 	lsl.w	ip, r2, r5
 8003bb2:	68db      	ldr	r3, [r3, #12]
 8003bb4:	ea21 010c 	bic.w	r1, r1, ip
 8003bb8:	689b      	ldr	r3, [r3, #8]
 8003bba:	8131      	strh	r1, [r6, #8]
 8003bbc:	2b00      	cmp	r3, #0
 8003bbe:	d0c3      	beq.n	8003b48 <Vector1D4+0x118>
 8003bc0:	4629      	mov	r1, r5
 8003bc2:	4798      	blx	r3
 8003bc4:	2201      	movs	r2, #1
 8003bc6:	4840      	ldr	r0, [pc, #256]	; (8003cc8 <Vector1D4+0x298>)
 8003bc8:	e7be      	b.n	8003b48 <Vector1D4+0x118>
    if (otgp->PCGCCTL & (PCGCCTL_STPPCLK | PCGCCTL_GATEHCLK)) {
 8003bca:	f8d4 3e00 	ldr.w	r3, [r4, #3584]	; 0xe00
 8003bce:	079a      	lsls	r2, r3, #30
 8003bd0:	f040 8114 	bne.w	8003dfc <Vector1D4+0x3cc>
    otgp->DCTL &= ~DCTL_RWUSIG;
 8003bd4:	f8d4 3804 	ldr.w	r3, [r4, #2052]	; 0x804
 8003bd8:	f023 0301 	bic.w	r3, r3, #1
 8003bdc:	f8c4 3804 	str.w	r3, [r4, #2052]	; 0x804
  usbp->state = usbp->saved_state;
 8003be0:	f896 308c 	ldrb.w	r3, [r6, #140]	; 0x8c
 8003be4:	7033      	strb	r3, [r6, #0]
  _usb_isr_invoke_event_cb(usbp, USB_EVENT_WAKEUP);
 8003be6:	6873      	ldr	r3, [r6, #4]
 8003be8:	681b      	ldr	r3, [r3, #0]
 8003bea:	2b00      	cmp	r3, #0
 8003bec:	f43f af38 	beq.w	8003a60 <Vector1D4+0x30>
 8003bf0:	2105      	movs	r1, #5
 8003bf2:	4835      	ldr	r0, [pc, #212]	; (8003cc8 <Vector1D4+0x298>)
 8003bf4:	4798      	blx	r3
  if (sts & GINTSTS_USBSUSP) {
 8003bf6:	053b      	lsls	r3, r7, #20
 8003bf8:	f57f af35 	bpl.w	8003a66 <Vector1D4+0x36>
    otg_disable_ep(usbp);
 8003bfc:	e9d6 0124 	ldrd	r0, r1, [r6, #144]	; 0x90
 8003c00:	f7fd f8d6 	bl	8000db0 <otg_disable_ep.isra.0>
  usbp->saved_state = usbp->state;
 8003c04:	7833      	ldrb	r3, [r6, #0]
 8003c06:	f886 308c 	strb.w	r3, [r6, #140]	; 0x8c
  usbp->state       = USB_SUSPENDED;
 8003c0a:	2305      	movs	r3, #5
 8003c0c:	7033      	strb	r3, [r6, #0]
  _usb_isr_invoke_event_cb(usbp, USB_EVENT_SUSPEND);
 8003c0e:	6873      	ldr	r3, [r6, #4]
 8003c10:	681b      	ldr	r3, [r3, #0]
 8003c12:	b113      	cbz	r3, 8003c1a <Vector1D4+0x1ea>
 8003c14:	2104      	movs	r1, #4
 8003c16:	482c      	ldr	r0, [pc, #176]	; (8003cc8 <Vector1D4+0x298>)
 8003c18:	4798      	blx	r3
  usbp->transmitting  = 0;
 8003c1a:	2300      	movs	r3, #0
 8003c1c:	60b3      	str	r3, [r6, #8]
}
 8003c1e:	e722      	b.n	8003a66 <Vector1D4+0x36>
 8003c20:	2330      	movs	r3, #48	; 0x30
 8003c22:	f383 8811 	msr	BASEPRI, r3
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 8003c26:	2103      	movs	r1, #3
 8003c28:	f8d9 308c 	ldr.w	r3, [r9, #140]	; 0x8c
    oip->trace_buffer.ptr->u.isr.name  = isr;
 8003c2c:	4a28      	ldr	r2, [pc, #160]	; (8003cd0 <Vector1D4+0x2a0>)
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 8003c2e:	7019      	strb	r1, [r3, #0]
    oip->trace_buffer.ptr->u.isr.name  = isr;
 8003c30:	609a      	str	r2, [r3, #8]
    trace_next(oip);
 8003c32:	f7fd f89d 	bl	8000d70 <trace_next.constprop.0>
 8003c36:	f384 8811 	msr	BASEPRI, r4
}
 8003c3a:	e703      	b.n	8003a44 <Vector1D4+0x14>
 8003c3c:	2330      	movs	r3, #48	; 0x30
 8003c3e:	f383 8811 	msr	BASEPRI, r3
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 8003c42:	2104      	movs	r1, #4
 8003c44:	f8d9 308c 	ldr.w	r3, [r9, #140]	; 0x8c
    oip->trace_buffer.ptr->u.isr.name  = isr;
 8003c48:	4a21      	ldr	r2, [pc, #132]	; (8003cd0 <Vector1D4+0x2a0>)
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 8003c4a:	7019      	strb	r1, [r3, #0]
    oip->trace_buffer.ptr->u.isr.name  = isr;
 8003c4c:	609a      	str	r2, [r3, #8]
    trace_next(oip);
 8003c4e:	f7fd f88f 	bl	8000d70 <trace_next.constprop.0>
 8003c52:	f384 8811 	msr	BASEPRI, r4
}
 8003c56:	e8bd 4ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  OSAL_IRQ_EPILOGUE();
 8003c5a:	f7fc bf49 	b.w	8000af0 <__port_irq_epilogue>
  sts = usbp->otg->GRXSTSP;
 8003c5e:	f8d6 1090 	ldr.w	r1, [r6, #144]	; 0x90
 8003c62:	6a0b      	ldr	r3, [r1, #32]
  switch (sts & GRXSTSP_PKTSTS_MASK) {
 8003c64:	f403 10f0 	and.w	r0, r3, #1966080	; 0x1e0000
  cnt = (sts & GRXSTSP_BCNT_MASK) >> GRXSTSP_BCNT_OFF;
 8003c68:	f3c3 120a 	ubfx	r2, r3, #4, #11
  ep  = (sts & GRXSTSP_EPNUM_MASK) >> GRXSTSP_EPNUM_OFF;
 8003c6c:	f003 030f 	and.w	r3, r3, #15
  switch (sts & GRXSTSP_PKTSTS_MASK) {
 8003c70:	f5b0 2f80 	cmp.w	r0, #262144	; 0x40000
 8003c74:	f000 80d4 	beq.w	8003e20 <Vector1D4+0x3f0>
 8003c78:	f5b0 2f40 	cmp.w	r0, #786432	; 0xc0000
 8003c7c:	f47f af0c 	bne.w	8003a98 <Vector1D4+0x68>
    otg_fifo_read_to_buffer(usbp->otg->FIFO[0], usbp->epc[ep]->setup_buf,
 8003c80:	eb06 0383 	add.w	r3, r6, r3, lsl #2
 8003c84:	68db      	ldr	r3, [r3, #12]
 8003c86:	6a18      	ldr	r0, [r3, #32]
  while (i < n) {
 8003c88:	2a00      	cmp	r2, #0
 8003c8a:	f43f af05 	beq.w	8003a98 <Vector1D4+0x68>
      w = *fifop;
 8003c8e:	f501 5580 	add.w	r5, r1, #4096	; 0x1000
  size_t i = 0;
 8003c92:	2300      	movs	r3, #0
 8003c94:	4646      	mov	r6, r8
    if ((i & 3) == 0) {
 8003c96:	f013 0f03 	tst.w	r3, #3
      *buf++ = (uint8_t)w;
 8003c9a:	4601      	mov	r1, r0
    if ((i & 3) == 0) {
 8003c9c:	d100      	bne.n	8003ca0 <Vector1D4+0x270>
      w = *fifop;
 8003c9e:	682e      	ldr	r6, [r5, #0]
    if (i < max) {
 8003ca0:	2b07      	cmp	r3, #7
    i++;
 8003ca2:	f103 0301 	add.w	r3, r3, #1
    if (i < max) {
 8003ca6:	d803      	bhi.n	8003cb0 <Vector1D4+0x280>
      *buf++ = (uint8_t)w;
 8003ca8:	f801 6b01 	strb.w	r6, [r1], #1
      w >>= 8;
 8003cac:	0a36      	lsrs	r6, r6, #8
      *buf++ = (uint8_t)w;
 8003cae:	4608      	mov	r0, r1
  while (i < n) {
 8003cb0:	429a      	cmp	r2, r3
 8003cb2:	d1f0      	bne.n	8003c96 <Vector1D4+0x266>
 8003cb4:	e6f0      	b.n	8003a98 <Vector1D4+0x68>
  stm32_otg_t *otgp = usbp->otg;
 8003cb6:	f8d6 a090 	ldr.w	sl, [r6, #144]	; 0x90
  for (ep = 0; ep <= usbp->otgparams->num_endpoints; ep++) {
 8003cba:	2500      	movs	r5, #0
      _usb_isr_invoke_out_cb(usbp, ep);
 8003cbc:	f04f 0b01 	mov.w	fp, #1
 8003cc0:	4801      	ldr	r0, [pc, #4]	; (8003cc8 <Vector1D4+0x298>)
 8003cc2:	e00f      	b.n	8003ce4 <Vector1D4+0x2b4>
 8003cc4:	24000330 	.word	0x24000330
 8003cc8:	2400024c 	.word	0x2400024c
 8003ccc:	e0001000 	.word	0xe0001000
 8003cd0:	080059d8 	.word	0x080059d8
  for (ep = 0; ep <= usbp->otgparams->num_endpoints; ep++) {
 8003cd4:	3501      	adds	r5, #1
 8003cd6:	f8d6 3094 	ldr.w	r3, [r6, #148]	; 0x94
 8003cda:	b2ed      	uxtb	r5, r5
 8003cdc:	689b      	ldr	r3, [r3, #8]
 8003cde:	429d      	cmp	r5, r3
 8003ce0:	f63f aed7 	bhi.w	8003a92 <Vector1D4+0x62>
 8003ce4:	eb0a 1245 	add.w	r2, sl, r5, lsl #5
    if (((otgp->oe[ep].DOEPCTL & DOEPCTL_EPTYP_MASK) == DOEPCTL_EPTYP_ISO) &&
 8003ce8:	f8d2 3b00 	ldr.w	r3, [r2, #2816]	; 0xb00
 8003cec:	f403 2340 	and.w	r3, r3, #786432	; 0xc0000
 8003cf0:	f5b3 2f80 	cmp.w	r3, #262144	; 0x40000
 8003cf4:	d1ee      	bne.n	8003cd4 <Vector1D4+0x2a4>
        ((otgp->oe[ep].DOEPCTL & DOEPCTL_EPENA) != 0)) {
 8003cf6:	f8d2 3b00 	ldr.w	r3, [r2, #2816]	; 0xb00
      _usb_isr_invoke_out_cb(usbp, ep);
 8003cfa:	fa0b f105 	lsl.w	r1, fp, r5
    if (((otgp->oe[ep].DOEPCTL & DOEPCTL_EPTYP_MASK) == DOEPCTL_EPTYP_ISO) &&
 8003cfe:	2b00      	cmp	r3, #0
 8003d00:	dae8      	bge.n	8003cd4 <Vector1D4+0x2a4>
      _usb_isr_invoke_out_cb(usbp, ep);
 8003d02:	eb06 0385 	add.w	r3, r6, r5, lsl #2
 8003d06:	68db      	ldr	r3, [r3, #12]
 8003d08:	68da      	ldr	r2, [r3, #12]
 8003d0a:	8973      	ldrh	r3, [r6, #10]
 8003d0c:	ea23 0301 	bic.w	r3, r3, r1
 8003d10:	8173      	strh	r3, [r6, #10]
 8003d12:	2a00      	cmp	r2, #0
 8003d14:	d0de      	beq.n	8003cd4 <Vector1D4+0x2a4>
 8003d16:	4629      	mov	r1, r5
 8003d18:	4790      	blx	r2
 8003d1a:	4882      	ldr	r0, [pc, #520]	; (8003f24 <Vector1D4+0x4f4>)
 8003d1c:	e7da      	b.n	8003cd4 <Vector1D4+0x2a4>
  usbp->status        = 0;
 8003d1e:	2500      	movs	r5, #0
  usbp->state         = USB_READY;
 8003d20:	2302      	movs	r3, #2
    usbp->epc[i] = NULL;
 8003d22:	2224      	movs	r2, #36	; 0x24
 8003d24:	f106 000c 	add.w	r0, r6, #12
 8003d28:	4629      	mov	r1, r5
  usbp->status        = 0;
 8003d2a:	f8c6 5088 	str.w	r5, [r6, #136]	; 0x88
  usbp->transmitting  = 0;
 8003d2e:	60b5      	str	r5, [r6, #8]
  usbp->state         = USB_READY;
 8003d30:	7033      	strb	r3, [r6, #0]
    usbp->epc[i] = NULL;
 8003d32:	f001 fdd7 	bl	80058e4 <memset>
  otgp->GRSTCTL = GRSTCTL_TXFNUM(fifo) | GRSTCTL_TXFFLSH;
 8003d36:	2320      	movs	r3, #32
  usbp->ep0state = USB_EP0_STP_WAITING;
 8003d38:	f886 5070 	strb.w	r5, [r6, #112]	; 0x70
 8003d3c:	6123      	str	r3, [r4, #16]
  while ((otgp->GRSTCTL & GRSTCTL_TXFFLSH) != 0)
 8003d3e:	6923      	ldr	r3, [r4, #16]
 8003d40:	f013 0320 	ands.w	r3, r3, #32
 8003d44:	d1fb      	bne.n	8003d3e <Vector1D4+0x30e>
 8003d46:	4978      	ldr	r1, [pc, #480]	; (8003f28 <Vector1D4+0x4f8>)
 8003d48:	6848      	ldr	r0, [r1, #4]
 8003d4a:	684a      	ldr	r2, [r1, #4]
  return (bool)(((rtcnt_t)cnt - (rtcnt_t)start) <
 8003d4c:	1a12      	subs	r2, r2, r0
  while (chSysIsCounterWithinX(chSysGetRealtimeCounterX(), start, end)) {
 8003d4e:	2a11      	cmp	r2, #17
 8003d50:	d9fb      	bls.n	8003d4a <Vector1D4+0x31a>
  otgp->DIEPEMPMSK = 0;
 8003d52:	2200      	movs	r2, #0
  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
 8003d54:	f8d6 7094 	ldr.w	r7, [r6, #148]	; 0x94
    otgp->ie[i].DIEPCTL = DIEPCTL_SNAK;
 8003d58:	f04f 6000 	mov.w	r0, #134217728	; 0x8000000
    otgp->ie[i].DIEPINT = 0xFFFFFFFF;
 8003d5c:	f04f 31ff 	mov.w	r1, #4294967295
  otgp->DIEPEMPMSK = 0;
 8003d60:	f8c4 2834 	str.w	r2, [r4, #2100]	; 0x834
  otgp->DAINTMSK   = DAINTMSK_OEPM(0) | DAINTMSK_IEPM(0);
 8003d64:	f04f 1201 	mov.w	r2, #65537	; 0x10001
  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
 8003d68:	68bd      	ldr	r5, [r7, #8]
  otgp->DAINTMSK   = DAINTMSK_OEPM(0) | DAINTMSK_IEPM(0);
 8003d6a:	f8c4 281c 	str.w	r2, [r4, #2076]	; 0x81c
 8003d6e:	eb04 1243 	add.w	r2, r4, r3, lsl #5
  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
 8003d72:	42ab      	cmp	r3, r5
 8003d74:	f103 0301 	add.w	r3, r3, #1
    otgp->ie[i].DIEPCTL = DIEPCTL_SNAK;
 8003d78:	f8c2 0900 	str.w	r0, [r2, #2304]	; 0x900
    otgp->oe[i].DOEPCTL = DOEPCTL_SNAK;
 8003d7c:	f8c2 0b00 	str.w	r0, [r2, #2816]	; 0xb00
    otgp->ie[i].DIEPINT = 0xFFFFFFFF;
 8003d80:	f8c2 1908 	str.w	r1, [r2, #2312]	; 0x908
    otgp->oe[i].DOEPINT = 0xFFFFFFFF;
 8003d84:	f8c2 1b08 	str.w	r1, [r2, #2824]	; 0xb08
  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
 8003d88:	d1f1      	bne.n	8003d6e <Vector1D4+0x33e>
  usbp->pmnext = usbp->otgparams->rx_fifo_size;
 8003d8a:	6838      	ldr	r0, [r7, #0]
  otgp->GRSTCTL = GRSTCTL_RXFFLSH;
 8003d8c:	2310      	movs	r3, #16
  otgp->GRXFSIZ = usbp->otgparams->rx_fifo_size;
 8003d8e:	6260      	str	r0, [r4, #36]	; 0x24
  otgp->GRSTCTL = GRSTCTL_RXFFLSH;
 8003d90:	6123      	str	r3, [r4, #16]
  while ((otgp->GRSTCTL & GRSTCTL_RXFFLSH) != 0)
 8003d92:	6923      	ldr	r3, [r4, #16]
 8003d94:	06d9      	lsls	r1, r3, #27
 8003d96:	d4fc      	bmi.n	8003d92 <Vector1D4+0x362>
 8003d98:	4a63      	ldr	r2, [pc, #396]	; (8003f28 <Vector1D4+0x4f8>)
 8003d9a:	6851      	ldr	r1, [r2, #4]
 8003d9c:	6853      	ldr	r3, [r2, #4]
  return (bool)(((rtcnt_t)cnt - (rtcnt_t)start) <
 8003d9e:	1a5b      	subs	r3, r3, r1
  while (chSysIsCounterWithinX(chSysGetRealtimeCounterX(), start, end)) {
 8003da0:	2b11      	cmp	r3, #17
 8003da2:	d9fb      	bls.n	8003d9c <Vector1D4+0x36c>
  otgp->DCFG = (otgp->DCFG & ~DCFG_DAD_MASK) | DCFG_DAD(0);
 8003da4:	f8d4 3800 	ldr.w	r3, [r4, #2048]	; 0x800
  otgp->ie[0].DIEPTSIZ = 0;
 8003da8:	2100      	movs	r1, #0
  otgp->DCFG = (otgp->DCFG & ~DCFG_DAD_MASK) | DCFG_DAD(0);
 8003daa:	f423 63fe 	bic.w	r3, r3, #2032	; 0x7f0
 8003dae:	f8c4 3800 	str.w	r3, [r4, #2048]	; 0x800
  otgp->GINTMSK  |= GINTMSK_RXFLVLM | GINTMSK_OEPM  | GINTMSK_IEPM;
 8003db2:	4b5e      	ldr	r3, [pc, #376]	; (8003f2c <Vector1D4+0x4fc>)
 8003db4:	69a2      	ldr	r2, [r4, #24]
 8003db6:	4313      	orrs	r3, r2
  _usb_isr_invoke_event_cb(usbp, USB_EVENT_RESET);
 8003db8:	6872      	ldr	r2, [r6, #4]
 8003dba:	61a3      	str	r3, [r4, #24]
  otgp->DIEPMSK   = DIEPMSK_TOCM    | DIEPMSK_XFRCM;
 8003dbc:	2309      	movs	r3, #9
 8003dbe:	6812      	ldr	r2, [r2, #0]
 8003dc0:	f8c4 3810 	str.w	r3, [r4, #2064]	; 0x810
  otgp->DOEPMSK   = DOEPMSK_STUPM   | DOEPMSK_XFRCM;
 8003dc4:	f8c4 3814 	str.w	r3, [r4, #2068]	; 0x814
  usbp->epc[0] = &ep0config;
 8003dc8:	4b59      	ldr	r3, [pc, #356]	; (8003f30 <Vector1D4+0x500>)
 8003dca:	60f3      	str	r3, [r6, #12]
  otgp->oe[0].DOEPTSIZ = DOEPTSIZ_STUPCNT(3);
 8003dcc:	f04f 43c0 	mov.w	r3, #1610612736	; 0x60000000
 8003dd0:	f8c4 3b10 	str.w	r3, [r4, #2832]	; 0xb10
  otgp->oe[0].DOEPCTL = DOEPCTL_SD0PID | DOEPCTL_USBAEP | DOEPCTL_EPTYP_CTRL |
 8003dd4:	4b57      	ldr	r3, [pc, #348]	; (8003f34 <Vector1D4+0x504>)
 8003dd6:	f8c4 3b00 	str.w	r3, [r4, #2816]	; 0xb00
  otgp->ie[0].DIEPTSIZ = 0;
 8003dda:	f8c4 1910 	str.w	r1, [r4, #2320]	; 0x910
  otgp->ie[0].DIEPCTL = DIEPCTL_SD0PID | DIEPCTL_USBAEP | DIEPCTL_EPTYP_CTRL |
 8003dde:	f8c4 3900 	str.w	r3, [r4, #2304]	; 0x900
  usbp->pmnext += size;
 8003de2:	f100 0310 	add.w	r3, r0, #16
  otgp->DIEPTXF0 = DIEPTXF_INEPTXFD(ep0config.in_maxsize / 4) |
 8003de6:	f440 1080 	orr.w	r0, r0, #1048576	; 0x100000
  usbp->pmnext += size;
 8003dea:	f8c6 3098 	str.w	r3, [r6, #152]	; 0x98
  otgp->DIEPTXF0 = DIEPTXF_INEPTXFD(ep0config.in_maxsize / 4) |
 8003dee:	62a0      	str	r0, [r4, #40]	; 0x28
 8003df0:	2a00      	cmp	r2, #0
 8003df2:	f43f ae8d 	beq.w	8003b10 <Vector1D4+0xe0>
 8003df6:	484b      	ldr	r0, [pc, #300]	; (8003f24 <Vector1D4+0x4f4>)
 8003df8:	4790      	blx	r2
 8003dfa:	e689      	b.n	8003b10 <Vector1D4+0xe0>
      otgp->PCGCCTL &= ~(PCGCCTL_STPPCLK | PCGCCTL_GATEHCLK);
 8003dfc:	f8d4 3e00 	ldr.w	r3, [r4, #3584]	; 0xe00
 8003e00:	f023 0303 	bic.w	r3, r3, #3
 8003e04:	f8c4 3e00 	str.w	r3, [r4, #3584]	; 0xe00
 8003e08:	e6e4      	b.n	8003bd4 <Vector1D4+0x1a4>
      otg_epout_handler(usbp, 8);
 8003e0a:	2008      	movs	r0, #8
 8003e0c:	f7fc ff60 	bl	8000cd0 <otg_epout_handler.constprop.0>
  if (sts & GINTSTS_IEPINT) {
 8003e10:	0379      	lsls	r1, r7, #13
 8003e12:	f57f ae7d 	bpl.w	8003b10 <Vector1D4+0xe0>
 8003e16:	e660      	b.n	8003ada <Vector1D4+0xaa>
      otg_epin_handler(usbp, 8);
 8003e18:	2008      	movs	r0, #8
 8003e1a:	f7fc fed1 	bl	8000bc0 <otg_epin_handler.constprop.0>
 8003e1e:	e677      	b.n	8003b10 <Vector1D4+0xe0>
                            usbp->epc[ep]->out_state->rxbuf,
 8003e20:	1c98      	adds	r0, r3, #2
 8003e22:	eb06 0380 	add.w	r3, r6, r0, lsl #2
 8003e26:	685b      	ldr	r3, [r3, #4]
 8003e28:	699b      	ldr	r3, [r3, #24]
    otg_fifo_read_to_buffer(usbp->otg->FIFO[0],
 8003e2a:	e9d3 5a00 	ldrd	r5, sl, [r3]
 8003e2e:	eba5 0e0a 	sub.w	lr, r5, sl
 8003e32:	689d      	ldr	r5, [r3, #8]
  while (i < n) {
 8003e34:	b1da      	cbz	r2, 8003e6e <Vector1D4+0x43e>
      w = *fifop;
 8003e36:	f501 5c80 	add.w	ip, r1, #4096	; 0x1000
  size_t i = 0;
 8003e3a:	4629      	mov	r1, r5
 8003e3c:	2300      	movs	r3, #0
 8003e3e:	4645      	mov	r5, r8
 8003e40:	4688      	mov	r8, r1
    if ((i & 3) == 0) {
 8003e42:	f013 0f03 	tst.w	r3, #3
      *buf++ = (uint8_t)w;
 8003e46:	4641      	mov	r1, r8
    if ((i & 3) == 0) {
 8003e48:	d101      	bne.n	8003e4e <Vector1D4+0x41e>
      w = *fifop;
 8003e4a:	f8dc 5000 	ldr.w	r5, [ip]
    if (i < max) {
 8003e4e:	459e      	cmp	lr, r3
    i++;
 8003e50:	f103 0301 	add.w	r3, r3, #1
    if (i < max) {
 8003e54:	d903      	bls.n	8003e5e <Vector1D4+0x42e>
      *buf++ = (uint8_t)w;
 8003e56:	f801 5b01 	strb.w	r5, [r1], #1
      w >>= 8;
 8003e5a:	0a2d      	lsrs	r5, r5, #8
      *buf++ = (uint8_t)w;
 8003e5c:	4688      	mov	r8, r1
  while (i < n) {
 8003e5e:	429a      	cmp	r2, r3
 8003e60:	d1ef      	bne.n	8003e42 <Vector1D4+0x412>
    usbp->epc[ep]->out_state->rxbuf += cnt;
 8003e62:	eb06 0680 	add.w	r6, r6, r0, lsl #2
 8003e66:	6873      	ldr	r3, [r6, #4]
 8003e68:	699b      	ldr	r3, [r3, #24]
    usbp->epc[ep]->out_state->rxcnt += cnt;
 8003e6a:	e9d3 a501 	ldrd	sl, r5, [r3, #4]
    usbp->epc[ep]->out_state->rxbuf += cnt;
 8003e6e:	4415      	add	r5, r2
    usbp->epc[ep]->out_state->rxcnt += cnt;
 8003e70:	4452      	add	r2, sl
 8003e72:	e9c3 2501 	strd	r2, r5, [r3, #4]
    break;
 8003e76:	e60f      	b.n	8003a98 <Vector1D4+0x68>
      otg_epin_handler(usbp, 0);
 8003e78:	2000      	movs	r0, #0
 8003e7a:	f7fc fea1 	bl	8000bc0 <otg_epin_handler.constprop.0>
    if (src & (1 << 1))
 8003e7e:	07a3      	lsls	r3, r4, #30
 8003e80:	f57f ae31 	bpl.w	8003ae6 <Vector1D4+0xb6>
      otg_epin_handler(usbp, 1);
 8003e84:	2001      	movs	r0, #1
 8003e86:	f7fc fe9b 	bl	8000bc0 <otg_epin_handler.constprop.0>
    if (src & (1 << 2))
 8003e8a:	0767      	lsls	r7, r4, #29
 8003e8c:	f57f ae2e 	bpl.w	8003aec <Vector1D4+0xbc>
      otg_epin_handler(usbp, 2);
 8003e90:	2002      	movs	r0, #2
 8003e92:	f7fc fe95 	bl	8000bc0 <otg_epin_handler.constprop.0>
    if (src & (1 << 3))
 8003e96:	0726      	lsls	r6, r4, #28
 8003e98:	f57f ae2b 	bpl.w	8003af2 <Vector1D4+0xc2>
      otg_epin_handler(usbp, 3);
 8003e9c:	2003      	movs	r0, #3
 8003e9e:	f7fc fe8f 	bl	8000bc0 <otg_epin_handler.constprop.0>
    if (src & (1 << 4))
 8003ea2:	06e5      	lsls	r5, r4, #27
 8003ea4:	f57f ae28 	bpl.w	8003af8 <Vector1D4+0xc8>
      otg_epin_handler(usbp, 4);
 8003ea8:	2004      	movs	r0, #4
 8003eaa:	f7fc fe89 	bl	8000bc0 <otg_epin_handler.constprop.0>
    if (src & (1 << 5))
 8003eae:	06a0      	lsls	r0, r4, #26
 8003eb0:	f57f ae25 	bpl.w	8003afe <Vector1D4+0xce>
      otg_epin_handler(usbp, 5);
 8003eb4:	2005      	movs	r0, #5
 8003eb6:	f7fc fe83 	bl	8000bc0 <otg_epin_handler.constprop.0>
    if (src & (1 << 6))
 8003eba:	0661      	lsls	r1, r4, #25
 8003ebc:	f57f ae22 	bpl.w	8003b04 <Vector1D4+0xd4>
      otg_epin_handler(usbp, 6);
 8003ec0:	2006      	movs	r0, #6
 8003ec2:	f7fc fe7d 	bl	8000bc0 <otg_epin_handler.constprop.0>
    if (src & (1 << 7))
 8003ec6:	0622      	lsls	r2, r4, #24
 8003ec8:	f57f ae1f 	bpl.w	8003b0a <Vector1D4+0xda>
      otg_epin_handler(usbp, 7);
 8003ecc:	2007      	movs	r0, #7
 8003ece:	f7fc fe77 	bl	8000bc0 <otg_epin_handler.constprop.0>
 8003ed2:	e61a      	b.n	8003b0a <Vector1D4+0xda>
      otg_epout_handler(usbp, 3);
 8003ed4:	2003      	movs	r0, #3
 8003ed6:	f7fc fefb 	bl	8000cd0 <otg_epout_handler.constprop.0>
    if (src & (1 << 20))
 8003eda:	02e2      	lsls	r2, r4, #11
 8003edc:	f57f adef 	bpl.w	8003abe <Vector1D4+0x8e>
      otg_epout_handler(usbp, 4);
 8003ee0:	2004      	movs	r0, #4
 8003ee2:	f7fc fef5 	bl	8000cd0 <otg_epout_handler.constprop.0>
    if (src & (1 << 21))
 8003ee6:	02a3      	lsls	r3, r4, #10
 8003ee8:	f57f adec 	bpl.w	8003ac4 <Vector1D4+0x94>
      otg_epout_handler(usbp, 5);
 8003eec:	2005      	movs	r0, #5
 8003eee:	f7fc feef 	bl	8000cd0 <otg_epout_handler.constprop.0>
    if (src & (1 << 22))
 8003ef2:	0266      	lsls	r6, r4, #9
 8003ef4:	f57f ade9 	bpl.w	8003aca <Vector1D4+0x9a>
      otg_epout_handler(usbp, 6);
 8003ef8:	2006      	movs	r0, #6
 8003efa:	f7fc fee9 	bl	8000cd0 <otg_epout_handler.constprop.0>
    if (src & (1 << 23))
 8003efe:	0225      	lsls	r5, r4, #8
 8003f00:	f57f ade6 	bpl.w	8003ad0 <Vector1D4+0xa0>
      otg_epout_handler(usbp, 7);
 8003f04:	2007      	movs	r0, #7
 8003f06:	f7fc fee3 	bl	8000cd0 <otg_epout_handler.constprop.0>
 8003f0a:	e5e1      	b.n	8003ad0 <Vector1D4+0xa0>
      otg_epout_handler(usbp, 2);
 8003f0c:	2002      	movs	r0, #2
 8003f0e:	f7fc fedf 	bl	8000cd0 <otg_epout_handler.constprop.0>
 8003f12:	e5ce      	b.n	8003ab2 <Vector1D4+0x82>
      otg_epout_handler(usbp, 1);
 8003f14:	2001      	movs	r0, #1
 8003f16:	f7fc fedb 	bl	8000cd0 <otg_epout_handler.constprop.0>
 8003f1a:	e5c7      	b.n	8003aac <Vector1D4+0x7c>
      otg_epout_handler(usbp, 0);
 8003f1c:	2000      	movs	r0, #0
 8003f1e:	f7fc fed7 	bl	8000cd0 <otg_epout_handler.constprop.0>
 8003f22:	e5c0      	b.n	8003aa6 <Vector1D4+0x76>
 8003f24:	2400024c 	.word	0x2400024c
 8003f28:	e0001000 	.word	0xe0001000
 8003f2c:	000c0010 	.word	0x000c0010
 8003f30:	08005da8 	.word	0x08005da8
 8003f34:	10008040 	.word	0x10008040
	...

08003f40 <VectorCC>:
/**
 * @brief   SPI1 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_SPI1_HANDLER) {
 8003f40:	b538      	push	{r3, r4, r5, lr}
  if ((oip->trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 8003f42:	4d1c      	ldr	r5, [pc, #112]	; (8003fb4 <VectorCC+0x74>)
 8003f44:	f8b5 3088 	ldrh.w	r3, [r5, #136]	; 0x88
 8003f48:	f013 0404 	ands.w	r4, r3, #4
 8003f4c:	d010      	beq.n	8003f70 <VectorCC+0x30>
  sr = spip->spi->SR & spip->spi->IER;
 8003f4e:	481a      	ldr	r0, [pc, #104]	; (8003fb8 <VectorCC+0x78>)
 8003f50:	69c2      	ldr	r2, [r0, #28]
 8003f52:	6953      	ldr	r3, [r2, #20]
 8003f54:	6911      	ldr	r1, [r2, #16]
 8003f56:	400b      	ands	r3, r1
  spip->spi->IFCR = sr;
 8003f58:	6193      	str	r3, [r2, #24]
  if ((sr & SPI_SR_OVR) != 0U) {
 8003f5a:	065b      	lsls	r3, r3, #25
 8003f5c:	d427      	bmi.n	8003fae <VectorCC+0x6e>
  if ((oip->trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 8003f5e:	f8b5 3088 	ldrh.w	r3, [r5, #136]	; 0x88
 8003f62:	f013 0404 	ands.w	r4, r3, #4
 8003f66:	d011      	beq.n	8003f8c <VectorCC+0x4c>
  OSAL_IRQ_PROLOGUE();

  spi_lld_serve_interrupt(&SPID1);

  OSAL_IRQ_EPILOGUE();
}
 8003f68:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  OSAL_IRQ_EPILOGUE();
 8003f6c:	f7fc bdc0 	b.w	8000af0 <__port_irq_epilogue>
 8003f70:	2330      	movs	r3, #48	; 0x30
 8003f72:	f383 8811 	msr	BASEPRI, r3
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 8003f76:	2103      	movs	r1, #3
 8003f78:	f8d5 308c 	ldr.w	r3, [r5, #140]	; 0x8c
    oip->trace_buffer.ptr->u.isr.name  = isr;
 8003f7c:	4a0f      	ldr	r2, [pc, #60]	; (8003fbc <VectorCC+0x7c>)
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 8003f7e:	7019      	strb	r1, [r3, #0]
    oip->trace_buffer.ptr->u.isr.name  = isr;
 8003f80:	609a      	str	r2, [r3, #8]
    trace_next(oip);
 8003f82:	f7fc fef5 	bl	8000d70 <trace_next.constprop.0>
 8003f86:	f384 8811 	msr	BASEPRI, r4
}
 8003f8a:	e7e0      	b.n	8003f4e <VectorCC+0xe>
 8003f8c:	2330      	movs	r3, #48	; 0x30
 8003f8e:	f383 8811 	msr	BASEPRI, r3
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 8003f92:	2104      	movs	r1, #4
 8003f94:	f8d5 308c 	ldr.w	r3, [r5, #140]	; 0x8c
    oip->trace_buffer.ptr->u.isr.name  = isr;
 8003f98:	4a08      	ldr	r2, [pc, #32]	; (8003fbc <VectorCC+0x7c>)
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 8003f9a:	7019      	strb	r1, [r3, #0]
    oip->trace_buffer.ptr->u.isr.name  = isr;
 8003f9c:	609a      	str	r2, [r3, #8]
    trace_next(oip);
 8003f9e:	f7fc fee7 	bl	8000d70 <trace_next.constprop.0>
 8003fa2:	f384 8811 	msr	BASEPRI, r4
}
 8003fa6:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  OSAL_IRQ_EPILOGUE();
 8003faa:	f7fc bda1 	b.w	8000af0 <__port_irq_epilogue>
 8003fae:	f7fc ffef 	bl	8000f90 <spi_lld_serve_interrupt.part.0>
 8003fb2:	e7d4      	b.n	8003f5e <VectorCC+0x1e>
 8003fb4:	24000330 	.word	0x24000330
 8003fb8:	24000120 	.word	0x24000120
 8003fbc:	08005ae0 	.word	0x08005ae0

08003fc0 <VectorD0>:
/**
 * @brief   SPI2 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_SPI2_HANDLER) {
 8003fc0:	b538      	push	{r3, r4, r5, lr}
  if ((oip->trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 8003fc2:	4d1c      	ldr	r5, [pc, #112]	; (8004034 <VectorD0+0x74>)
 8003fc4:	f8b5 3088 	ldrh.w	r3, [r5, #136]	; 0x88
 8003fc8:	f013 0404 	ands.w	r4, r3, #4
 8003fcc:	d010      	beq.n	8003ff0 <VectorD0+0x30>
  sr = spip->spi->SR & spip->spi->IER;
 8003fce:	481a      	ldr	r0, [pc, #104]	; (8004038 <VectorD0+0x78>)
 8003fd0:	69c2      	ldr	r2, [r0, #28]
 8003fd2:	6953      	ldr	r3, [r2, #20]
 8003fd4:	6911      	ldr	r1, [r2, #16]
 8003fd6:	400b      	ands	r3, r1
  spip->spi->IFCR = sr;
 8003fd8:	6193      	str	r3, [r2, #24]
  if ((sr & SPI_SR_OVR) != 0U) {
 8003fda:	065b      	lsls	r3, r3, #25
 8003fdc:	d427      	bmi.n	800402e <VectorD0+0x6e>
  if ((oip->trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 8003fde:	f8b5 3088 	ldrh.w	r3, [r5, #136]	; 0x88
 8003fe2:	f013 0404 	ands.w	r4, r3, #4
 8003fe6:	d011      	beq.n	800400c <VectorD0+0x4c>
  OSAL_IRQ_PROLOGUE();

  spi_lld_serve_interrupt(&SPID2);

  OSAL_IRQ_EPILOGUE();
}
 8003fe8:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  OSAL_IRQ_EPILOGUE();
 8003fec:	f7fc bd80 	b.w	8000af0 <__port_irq_epilogue>
 8003ff0:	2330      	movs	r3, #48	; 0x30
 8003ff2:	f383 8811 	msr	BASEPRI, r3
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 8003ff6:	2103      	movs	r1, #3
 8003ff8:	f8d5 308c 	ldr.w	r3, [r5, #140]	; 0x8c
    oip->trace_buffer.ptr->u.isr.name  = isr;
 8003ffc:	4a0f      	ldr	r2, [pc, #60]	; (800403c <VectorD0+0x7c>)
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 8003ffe:	7019      	strb	r1, [r3, #0]
    oip->trace_buffer.ptr->u.isr.name  = isr;
 8004000:	609a      	str	r2, [r3, #8]
    trace_next(oip);
 8004002:	f7fc feb5 	bl	8000d70 <trace_next.constprop.0>
 8004006:	f384 8811 	msr	BASEPRI, r4
}
 800400a:	e7e0      	b.n	8003fce <VectorD0+0xe>
 800400c:	2330      	movs	r3, #48	; 0x30
 800400e:	f383 8811 	msr	BASEPRI, r3
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 8004012:	2104      	movs	r1, #4
 8004014:	f8d5 308c 	ldr.w	r3, [r5, #140]	; 0x8c
    oip->trace_buffer.ptr->u.isr.name  = isr;
 8004018:	4a08      	ldr	r2, [pc, #32]	; (800403c <VectorD0+0x7c>)
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 800401a:	7019      	strb	r1, [r3, #0]
    oip->trace_buffer.ptr->u.isr.name  = isr;
 800401c:	609a      	str	r2, [r3, #8]
    trace_next(oip);
 800401e:	f7fc fea7 	bl	8000d70 <trace_next.constprop.0>
 8004022:	f384 8811 	msr	BASEPRI, r4
}
 8004026:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  OSAL_IRQ_EPILOGUE();
 800402a:	f7fc bd61 	b.w	8000af0 <__port_irq_epilogue>
 800402e:	f7fc ffaf 	bl	8000f90 <spi_lld_serve_interrupt.part.0>
 8004032:	e7d4      	b.n	8003fde <VectorD0+0x1e>
 8004034:	24000330 	.word	0x24000330
 8004038:	2400015c 	.word	0x2400015c
 800403c:	08005abc 	.word	0x08005abc

08004040 <Vector10C>:
/**
 * @brief   SPI3 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_SPI3_HANDLER) {
 8004040:	b538      	push	{r3, r4, r5, lr}
  if ((oip->trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 8004042:	4d1c      	ldr	r5, [pc, #112]	; (80040b4 <Vector10C+0x74>)
 8004044:	f8b5 3088 	ldrh.w	r3, [r5, #136]	; 0x88
 8004048:	f013 0404 	ands.w	r4, r3, #4
 800404c:	d010      	beq.n	8004070 <Vector10C+0x30>
  sr = spip->spi->SR & spip->spi->IER;
 800404e:	481a      	ldr	r0, [pc, #104]	; (80040b8 <Vector10C+0x78>)
 8004050:	69c2      	ldr	r2, [r0, #28]
 8004052:	6953      	ldr	r3, [r2, #20]
 8004054:	6911      	ldr	r1, [r2, #16]
 8004056:	400b      	ands	r3, r1
  spip->spi->IFCR = sr;
 8004058:	6193      	str	r3, [r2, #24]
  if ((sr & SPI_SR_OVR) != 0U) {
 800405a:	065b      	lsls	r3, r3, #25
 800405c:	d427      	bmi.n	80040ae <Vector10C+0x6e>
  if ((oip->trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 800405e:	f8b5 3088 	ldrh.w	r3, [r5, #136]	; 0x88
 8004062:	f013 0404 	ands.w	r4, r3, #4
 8004066:	d011      	beq.n	800408c <Vector10C+0x4c>
  OSAL_IRQ_PROLOGUE();

  spi_lld_serve_interrupt(&SPID3);

  OSAL_IRQ_EPILOGUE();
}
 8004068:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  OSAL_IRQ_EPILOGUE();
 800406c:	f7fc bd40 	b.w	8000af0 <__port_irq_epilogue>
 8004070:	2330      	movs	r3, #48	; 0x30
 8004072:	f383 8811 	msr	BASEPRI, r3
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 8004076:	2103      	movs	r1, #3
 8004078:	f8d5 308c 	ldr.w	r3, [r5, #140]	; 0x8c
    oip->trace_buffer.ptr->u.isr.name  = isr;
 800407c:	4a0f      	ldr	r2, [pc, #60]	; (80040bc <Vector10C+0x7c>)
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 800407e:	7019      	strb	r1, [r3, #0]
    oip->trace_buffer.ptr->u.isr.name  = isr;
 8004080:	609a      	str	r2, [r3, #8]
    trace_next(oip);
 8004082:	f7fc fe75 	bl	8000d70 <trace_next.constprop.0>
 8004086:	f384 8811 	msr	BASEPRI, r4
}
 800408a:	e7e0      	b.n	800404e <Vector10C+0xe>
 800408c:	2330      	movs	r3, #48	; 0x30
 800408e:	f383 8811 	msr	BASEPRI, r3
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 8004092:	2104      	movs	r1, #4
 8004094:	f8d5 308c 	ldr.w	r3, [r5, #140]	; 0x8c
    oip->trace_buffer.ptr->u.isr.name  = isr;
 8004098:	4a08      	ldr	r2, [pc, #32]	; (80040bc <Vector10C+0x7c>)
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 800409a:	7019      	strb	r1, [r3, #0]
    oip->trace_buffer.ptr->u.isr.name  = isr;
 800409c:	609a      	str	r2, [r3, #8]
    trace_next(oip);
 800409e:	f7fc fe67 	bl	8000d70 <trace_next.constprop.0>
 80040a2:	f384 8811 	msr	BASEPRI, r4
}
 80040a6:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  OSAL_IRQ_EPILOGUE();
 80040aa:	f7fc bd21 	b.w	8000af0 <__port_irq_epilogue>
 80040ae:	f7fc ff6f 	bl	8000f90 <spi_lld_serve_interrupt.part.0>
 80040b2:	e7d4      	b.n	800405e <Vector10C+0x1e>
 80040b4:	24000330 	.word	0x24000330
 80040b8:	24000198 	.word	0x24000198
 80040bc:	08005a98 	.word	0x08005a98

080040c0 <Vector194>:
/**
 * @brief   SPI5 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_SPI5_HANDLER) {
 80040c0:	b538      	push	{r3, r4, r5, lr}
  if ((oip->trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 80040c2:	4d1c      	ldr	r5, [pc, #112]	; (8004134 <Vector194+0x74>)
 80040c4:	f8b5 3088 	ldrh.w	r3, [r5, #136]	; 0x88
 80040c8:	f013 0404 	ands.w	r4, r3, #4
 80040cc:	d010      	beq.n	80040f0 <Vector194+0x30>
  sr = spip->spi->SR & spip->spi->IER;
 80040ce:	481a      	ldr	r0, [pc, #104]	; (8004138 <Vector194+0x78>)
 80040d0:	69c2      	ldr	r2, [r0, #28]
 80040d2:	6953      	ldr	r3, [r2, #20]
 80040d4:	6911      	ldr	r1, [r2, #16]
 80040d6:	400b      	ands	r3, r1
  spip->spi->IFCR = sr;
 80040d8:	6193      	str	r3, [r2, #24]
  if ((sr & SPI_SR_OVR) != 0U) {
 80040da:	065b      	lsls	r3, r3, #25
 80040dc:	d427      	bmi.n	800412e <Vector194+0x6e>
  if ((oip->trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 80040de:	f8b5 3088 	ldrh.w	r3, [r5, #136]	; 0x88
 80040e2:	f013 0404 	ands.w	r4, r3, #4
 80040e6:	d011      	beq.n	800410c <Vector194+0x4c>
  OSAL_IRQ_PROLOGUE();

  spi_lld_serve_interrupt(&SPID5);

  OSAL_IRQ_EPILOGUE();
}
 80040e8:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  OSAL_IRQ_EPILOGUE();
 80040ec:	f7fc bd00 	b.w	8000af0 <__port_irq_epilogue>
 80040f0:	2330      	movs	r3, #48	; 0x30
 80040f2:	f383 8811 	msr	BASEPRI, r3
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 80040f6:	2103      	movs	r1, #3
 80040f8:	f8d5 308c 	ldr.w	r3, [r5, #140]	; 0x8c
    oip->trace_buffer.ptr->u.isr.name  = isr;
 80040fc:	4a0f      	ldr	r2, [pc, #60]	; (800413c <Vector194+0x7c>)
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 80040fe:	7019      	strb	r1, [r3, #0]
    oip->trace_buffer.ptr->u.isr.name  = isr;
 8004100:	609a      	str	r2, [r3, #8]
    trace_next(oip);
 8004102:	f7fc fe35 	bl	8000d70 <trace_next.constprop.0>
 8004106:	f384 8811 	msr	BASEPRI, r4
}
 800410a:	e7e0      	b.n	80040ce <Vector194+0xe>
 800410c:	2330      	movs	r3, #48	; 0x30
 800410e:	f383 8811 	msr	BASEPRI, r3
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 8004112:	2104      	movs	r1, #4
 8004114:	f8d5 308c 	ldr.w	r3, [r5, #140]	; 0x8c
    oip->trace_buffer.ptr->u.isr.name  = isr;
 8004118:	4a08      	ldr	r2, [pc, #32]	; (800413c <Vector194+0x7c>)
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 800411a:	7019      	strb	r1, [r3, #0]
    oip->trace_buffer.ptr->u.isr.name  = isr;
 800411c:	609a      	str	r2, [r3, #8]
    trace_next(oip);
 800411e:	f7fc fe27 	bl	8000d70 <trace_next.constprop.0>
 8004122:	f384 8811 	msr	BASEPRI, r4
}
 8004126:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  OSAL_IRQ_EPILOGUE();
 800412a:	f7fc bce1 	b.w	8000af0 <__port_irq_epilogue>
 800412e:	f7fc ff2f 	bl	8000f90 <spi_lld_serve_interrupt.part.0>
 8004132:	e7d4      	b.n	80040de <Vector194+0x1e>
 8004134:	24000330 	.word	0x24000330
 8004138:	240001d4 	.word	0x240001d4
 800413c:	08005a20 	.word	0x08005a20

08004140 <Vector198>:
/**
 * @brief   SPI6 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_SPI6_HANDLER) {
 8004140:	b538      	push	{r3, r4, r5, lr}
  if ((oip->trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 8004142:	4d1c      	ldr	r5, [pc, #112]	; (80041b4 <Vector198+0x74>)
 8004144:	f8b5 3088 	ldrh.w	r3, [r5, #136]	; 0x88
 8004148:	f013 0404 	ands.w	r4, r3, #4
 800414c:	d010      	beq.n	8004170 <Vector198+0x30>
  sr = spip->spi->SR & spip->spi->IER;
 800414e:	481a      	ldr	r0, [pc, #104]	; (80041b8 <Vector198+0x78>)
 8004150:	69c2      	ldr	r2, [r0, #28]
 8004152:	6953      	ldr	r3, [r2, #20]
 8004154:	6911      	ldr	r1, [r2, #16]
 8004156:	400b      	ands	r3, r1
  spip->spi->IFCR = sr;
 8004158:	6193      	str	r3, [r2, #24]
  if ((sr & SPI_SR_OVR) != 0U) {
 800415a:	065b      	lsls	r3, r3, #25
 800415c:	d427      	bmi.n	80041ae <Vector198+0x6e>
  if ((oip->trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 800415e:	f8b5 3088 	ldrh.w	r3, [r5, #136]	; 0x88
 8004162:	f013 0404 	ands.w	r4, r3, #4
 8004166:	d011      	beq.n	800418c <Vector198+0x4c>
  OSAL_IRQ_PROLOGUE();

  spi_lld_serve_interrupt(&SPID6);

  OSAL_IRQ_EPILOGUE();
}
 8004168:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  OSAL_IRQ_EPILOGUE();
 800416c:	f7fc bcc0 	b.w	8000af0 <__port_irq_epilogue>
 8004170:	2330      	movs	r3, #48	; 0x30
 8004172:	f383 8811 	msr	BASEPRI, r3
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 8004176:	2103      	movs	r1, #3
 8004178:	f8d5 308c 	ldr.w	r3, [r5, #140]	; 0x8c
    oip->trace_buffer.ptr->u.isr.name  = isr;
 800417c:	4a0f      	ldr	r2, [pc, #60]	; (80041bc <Vector198+0x7c>)
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 800417e:	7019      	strb	r1, [r3, #0]
    oip->trace_buffer.ptr->u.isr.name  = isr;
 8004180:	609a      	str	r2, [r3, #8]
    trace_next(oip);
 8004182:	f7fc fdf5 	bl	8000d70 <trace_next.constprop.0>
 8004186:	f384 8811 	msr	BASEPRI, r4
}
 800418a:	e7e0      	b.n	800414e <Vector198+0xe>
 800418c:	2330      	movs	r3, #48	; 0x30
 800418e:	f383 8811 	msr	BASEPRI, r3
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 8004192:	2104      	movs	r1, #4
 8004194:	f8d5 308c 	ldr.w	r3, [r5, #140]	; 0x8c
    oip->trace_buffer.ptr->u.isr.name  = isr;
 8004198:	4a08      	ldr	r2, [pc, #32]	; (80041bc <Vector198+0x7c>)
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 800419a:	7019      	strb	r1, [r3, #0]
    oip->trace_buffer.ptr->u.isr.name  = isr;
 800419c:	609a      	str	r2, [r3, #8]
    trace_next(oip);
 800419e:	f7fc fde7 	bl	8000d70 <trace_next.constprop.0>
 80041a2:	f384 8811 	msr	BASEPRI, r4
}
 80041a6:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  OSAL_IRQ_EPILOGUE();
 80041aa:	f7fc bca1 	b.w	8000af0 <__port_irq_epilogue>
 80041ae:	f7fc feef 	bl	8000f90 <spi_lld_serve_interrupt.part.0>
 80041b2:	e7d4      	b.n	800415e <Vector198+0x1e>
 80041b4:	24000330 	.word	0x24000330
 80041b8:	24000210 	.word	0x24000210
 80041bc:	080059e4 	.word	0x080059e4

080041c0 <__early_init>:
  RCC->AHB4RSTR |= mask;
 80041c0:	49b4      	ldr	r1, [pc, #720]	; (8004494 <__early_init+0x2d4>)
 80041c2:	f240 70ff 	movw	r0, #2047	; 0x7ff
  gpiop->OTYPER  = config->otyper;
 80041c6:	2300      	movs	r3, #0
 80041c8:	f8d1 2088 	ldr.w	r2, [r1, #136]	; 0x88
 80041cc:	4302      	orrs	r2, r0
void __early_init(void) {
 80041ce:	b430      	push	{r4, r5}
 80041d0:	f8c1 2088 	str.w	r2, [r1, #136]	; 0x88
  RCC->AHB4RSTR &= ~mask;
 80041d4:	4cb0      	ldr	r4, [pc, #704]	; (8004498 <__early_init+0x2d8>)
 80041d6:	f8d1 2088 	ldr.w	r2, [r1, #136]	; 0x88
  gpiop->OSPEEDR = config->ospeedr;
 80041da:	4db0      	ldr	r5, [pc, #704]	; (800449c <__early_init+0x2dc>)
 80041dc:	4014      	ands	r4, r2
  gpiop->OTYPER  = config->otyper;
 80041de:	4ab0      	ldr	r2, [pc, #704]	; (80044a0 <__early_init+0x2e0>)
 80041e0:	f8c1 4088 	str.w	r4, [r1, #136]	; 0x88
  (void)RCC->AHB4RSTR;
 80041e4:	f8d1 4088 	ldr.w	r4, [r1, #136]	; 0x88
 */
__STATIC_INLINE void rccEnableAHB4(uint32_t mask, bool lp) {

#if STM32_TARGET_CORE == 1
  /* Allocating and enabling the peripherals.*/
  RCC_C1->AHB4ENR |= mask;
 80041e8:	f8d1 40e0 	ldr.w	r4, [r1, #224]	; 0xe0
 80041ec:	4304      	orrs	r4, r0
 80041ee:	f8c1 40e0 	str.w	r4, [r1, #224]	; 0xe0
  if (lp) {
    RCC_C1->AHB4LPENR |= mask;
 80041f2:	f8d1 4108 	ldr.w	r4, [r1, #264]	; 0x108
 80041f6:	4304      	orrs	r4, r0
 80041f8:	48aa      	ldr	r0, [pc, #680]	; (80044a4 <__early_init+0x2e4>)
 80041fa:	f8c1 4108 	str.w	r4, [r1, #264]	; 0x108
  }
  else {
    RCC_C1->AHB4LPENR &= ~mask;
  }
  (void)RCC_C1->AHB4LPENR;
 80041fe:	f8d1 4108 	ldr.w	r4, [r1, #264]	; 0x108
  gpiop->ODR     = config->odr;
 8004202:	f64f 748f 	movw	r4, #65423	; 0xff8f
  gpiop->OTYPER  = config->otyper;
 8004206:	6053      	str	r3, [r2, #4]
  gpiop->OSPEEDR = config->ospeedr;
 8004208:	6095      	str	r5, [r2, #8]
  gpiop->PUPDR   = config->pupdr;
 800420a:	60d3      	str	r3, [r2, #12]
  gpiop->ODR     = config->odr;
 800420c:	6154      	str	r4, [r2, #20]
  gpiop->AFRL    = config->afrl;
 800420e:	4ca6      	ldr	r4, [pc, #664]	; (80044a8 <__early_init+0x2e8>)
 8004210:	6214      	str	r4, [r2, #32]
  gpiop->AFRH    = config->afrh;
 8004212:	4ca6      	ldr	r4, [pc, #664]	; (80044ac <__early_init+0x2ec>)
 8004214:	6254      	str	r4, [r2, #36]	; 0x24
  gpiop->MODER   = config->moder;
 8004216:	4ca6      	ldr	r4, [pc, #664]	; (80044b0 <__early_init+0x2f0>)
 8004218:	6014      	str	r4, [r2, #0]
  gpiop->OTYPER  = config->otyper;
 800421a:	f502 6200 	add.w	r2, r2, #2048	; 0x800
  gpiop->OSPEEDR = config->ospeedr;
 800421e:	4ca5      	ldr	r4, [pc, #660]	; (80044b4 <__early_init+0x2f4>)
  gpiop->OTYPER  = config->otyper;
 8004220:	6043      	str	r3, [r0, #4]
  gpiop->OSPEEDR = config->ospeedr;
 8004222:	6084      	str	r4, [r0, #8]
  gpiop->ODR     = config->odr;
 8004224:	f64b 747e 	movw	r4, #49022	; 0xbf7e
  gpiop->PUPDR   = config->pupdr;
 8004228:	60c3      	str	r3, [r0, #12]
  gpiop->ODR     = config->odr;
 800422a:	6144      	str	r4, [r0, #20]
  gpiop->AFRL    = config->afrl;
 800422c:	4ca2      	ldr	r4, [pc, #648]	; (80044b8 <__early_init+0x2f8>)
 800422e:	6204      	str	r4, [r0, #32]
  gpiop->AFRH    = config->afrh;
 8004230:	4ca2      	ldr	r4, [pc, #648]	; (80044bc <__early_init+0x2fc>)
 8004232:	6244      	str	r4, [r0, #36]	; 0x24
  gpiop->MODER   = config->moder;
 8004234:	4ca2      	ldr	r4, [pc, #648]	; (80044c0 <__early_init+0x300>)
 8004236:	6004      	str	r4, [r0, #0]
  gpiop->ODR     = config->odr;
 8004238:	f64f 70ff 	movw	r0, #65535	; 0xffff
  gpiop->OSPEEDR = config->ospeedr;
 800423c:	4ca1      	ldr	r4, [pc, #644]	; (80044c4 <__early_init+0x304>)
  gpiop->OTYPER  = config->otyper;
 800423e:	6053      	str	r3, [r2, #4]
  gpiop->OSPEEDR = config->ospeedr;
 8004240:	6094      	str	r4, [r2, #8]
  gpiop->AFRL    = config->afrl;
 8004242:	4ca1      	ldr	r4, [pc, #644]	; (80044c8 <__early_init+0x308>)
  gpiop->PUPDR   = config->pupdr;
 8004244:	60d3      	str	r3, [r2, #12]
  gpiop->ODR     = config->odr;
 8004246:	6150      	str	r0, [r2, #20]
  gpiop->AFRL    = config->afrl;
 8004248:	6214      	str	r4, [r2, #32]
  gpiop->AFRH    = config->afrh;
 800424a:	4ca0      	ldr	r4, [pc, #640]	; (80044cc <__early_init+0x30c>)
 800424c:	6254      	str	r4, [r2, #36]	; 0x24
  gpiop->MODER   = config->moder;
 800424e:	4ca0      	ldr	r4, [pc, #640]	; (80044d0 <__early_init+0x310>)
 8004250:	6014      	str	r4, [r2, #0]
  gpiop->OSPEEDR = config->ospeedr;
 8004252:	4ca0      	ldr	r4, [pc, #640]	; (80044d4 <__early_init+0x314>)
  gpiop->OTYPER  = config->otyper;
 8004254:	f8c2 3404 	str.w	r3, [r2, #1028]	; 0x404
  gpiop->OSPEEDR = config->ospeedr;
 8004258:	f8c2 4408 	str.w	r4, [r2, #1032]	; 0x408
  gpiop->AFRL    = config->afrl;
 800425c:	4c9e      	ldr	r4, [pc, #632]	; (80044d8 <__early_init+0x318>)
  gpiop->PUPDR   = config->pupdr;
 800425e:	f8c2 340c 	str.w	r3, [r2, #1036]	; 0x40c
  gpiop->ODR     = config->odr;
 8004262:	f8c2 0414 	str.w	r0, [r2, #1044]	; 0x414
  gpiop->AFRL    = config->afrl;
 8004266:	f8c2 4420 	str.w	r4, [r2, #1056]	; 0x420
  gpiop->AFRH    = config->afrh;
 800426a:	f104 44f8 	add.w	r4, r4, #2080374784	; 0x7c000000
 800426e:	f504 1408 	add.w	r4, r4, #2228224	; 0x220000
 8004272:	f8c2 4424 	str.w	r4, [r2, #1060]	; 0x424
  gpiop->MODER   = config->moder;
 8004276:	4c99      	ldr	r4, [pc, #612]	; (80044dc <__early_init+0x31c>)
 8004278:	f8c2 4400 	str.w	r4, [r2, #1024]	; 0x400
  gpiop->OSPEEDR = config->ospeedr;
 800427c:	f46f 5440 	mvn.w	r4, #12288	; 0x3000
  gpiop->OTYPER  = config->otyper;
 8004280:	f8c2 3804 	str.w	r3, [r2, #2052]	; 0x804
  gpiop->OSPEEDR = config->ospeedr;
 8004284:	f8c2 4808 	str.w	r4, [r2, #2056]	; 0x808
  gpiop->AFRL    = config->afrl;
 8004288:	f1a4 547e 	sub.w	r4, r4, #1065353216	; 0x3f800000
  gpiop->PUPDR   = config->pupdr;
 800428c:	f8c2 380c 	str.w	r3, [r2, #2060]	; 0x80c
  gpiop->AFRL    = config->afrl;
 8004290:	f5a4 14cb 	sub.w	r4, r4, #1662976	; 0x196000
  gpiop->ODR     = config->odr;
 8004294:	f8c2 0814 	str.w	r0, [r2, #2068]	; 0x814
  gpiop->AFRL    = config->afrl;
 8004298:	f6a4 1433 	subw	r4, r4, #2355	; 0x933
 800429c:	f8c2 4820 	str.w	r4, [r2, #2080]	; 0x820
  gpiop->AFRH    = config->afrh;
 80042a0:	f04f 34cc 	mov.w	r4, #3435973836	; 0xcccccccc
 80042a4:	f8c2 4824 	str.w	r4, [r2, #2084]	; 0x824
  gpiop->MODER   = config->moder;
 80042a8:	4c8d      	ldr	r4, [pc, #564]	; (80044e0 <__early_init+0x320>)
 80042aa:	f8c2 4800 	str.w	r4, [r2, #2048]	; 0x800
  gpiop->OTYPER  = config->otyper;
 80042ae:	f502 6240 	add.w	r2, r2, #3072	; 0xc00
  gpiop->OSPEEDR = config->ospeedr;
 80042b2:	4c8c      	ldr	r4, [pc, #560]	; (80044e4 <__early_init+0x324>)
  gpiop->OTYPER  = config->otyper;
 80042b4:	6053      	str	r3, [r2, #4]
  gpiop->OSPEEDR = config->ospeedr;
 80042b6:	6094      	str	r4, [r2, #8]
  gpiop->AFRL    = config->afrl;
 80042b8:	4c8b      	ldr	r4, [pc, #556]	; (80044e8 <__early_init+0x328>)
  gpiop->PUPDR   = config->pupdr;
 80042ba:	60d3      	str	r3, [r2, #12]
  gpiop->ODR     = config->odr;
 80042bc:	6150      	str	r0, [r2, #20]
  gpiop->AFRL    = config->afrl;
 80042be:	6214      	str	r4, [r2, #32]
  gpiop->AFRH    = config->afrh;
 80042c0:	f104 44f8 	add.w	r4, r4, #2080374784	; 0x7c000000
 80042c4:	f6a4 4477 	subw	r4, r4, #3191	; 0xc77
 80042c8:	6254      	str	r4, [r2, #36]	; 0x24
  gpiop->MODER   = config->moder;
 80042ca:	f104 445e 	add.w	r4, r4, #3724541952	; 0xde000000
 80042ce:	f5a4 1490 	sub.w	r4, r4, #1179648	; 0x120000
 80042d2:	f2a4 54ab 	subw	r4, r4, #1451	; 0x5ab
 80042d6:	6014      	str	r4, [r2, #0]
  gpiop->OSPEEDR = config->ospeedr;
 80042d8:	4c84      	ldr	r4, [pc, #528]	; (80044ec <__early_init+0x32c>)
  gpiop->OTYPER  = config->otyper;
 80042da:	f8c2 3404 	str.w	r3, [r2, #1028]	; 0x404
  gpiop->OSPEEDR = config->ospeedr;
 80042de:	f8c2 4408 	str.w	r4, [r2, #1032]	; 0x408
  gpiop->ODR     = config->odr;
 80042e2:	f64f 74bf 	movw	r4, #65471	; 0xffbf
  gpiop->PUPDR   = config->pupdr;
 80042e6:	f8c2 340c 	str.w	r3, [r2, #1036]	; 0x40c
  gpiop->ODR     = config->odr;
 80042ea:	f8c2 4414 	str.w	r4, [r2, #1044]	; 0x414
  gpiop->AFRL    = config->afrl;
 80042ee:	4c80      	ldr	r4, [pc, #512]	; (80044f0 <__early_init+0x330>)
 80042f0:	f8c2 4420 	str.w	r4, [r2, #1056]	; 0x420
  gpiop->AFRH    = config->afrh;
 80042f4:	4c7f      	ldr	r4, [pc, #508]	; (80044f4 <__early_init+0x334>)
 80042f6:	f8c2 4424 	str.w	r4, [r2, #1060]	; 0x424
  gpiop->MODER   = config->moder;
 80042fa:	4c7f      	ldr	r4, [pc, #508]	; (80044f8 <__early_init+0x338>)
 80042fc:	f8c2 4400 	str.w	r4, [r2, #1024]	; 0x400
  gpiop->OSPEEDR = config->ospeedr;
 8004300:	4c7e      	ldr	r4, [pc, #504]	; (80044fc <__early_init+0x33c>)
  gpiop->OTYPER  = config->otyper;
 8004302:	f8c2 3804 	str.w	r3, [r2, #2052]	; 0x804
  gpiop->OSPEEDR = config->ospeedr;
 8004306:	f8c2 4808 	str.w	r4, [r2, #2056]	; 0x808
  gpiop->PUPDR   = config->pupdr;
 800430a:	f44f 34a0 	mov.w	r4, #81920	; 0x14000
 800430e:	f8c2 480c 	str.w	r4, [r2, #2060]	; 0x80c
  gpiop->ODR     = config->odr;
 8004312:	f64f 74e3 	movw	r4, #65507	; 0xffe3
 8004316:	f8c2 4814 	str.w	r4, [r2, #2068]	; 0x814
  gpiop->AFRL    = config->afrl;
 800431a:	f04f 4480 	mov.w	r4, #1073741824	; 0x40000000
 800431e:	f8c2 4820 	str.w	r4, [r2, #2080]	; 0x820
  gpiop->AFRH    = config->afrh;
 8004322:	f242 2404 	movw	r4, #8708	; 0x2204
 8004326:	f8c2 4824 	str.w	r4, [r2, #2084]	; 0x824
  gpiop->MODER   = config->moder;
 800432a:	4c75      	ldr	r4, [pc, #468]	; (8004500 <__early_init+0x340>)
 800432c:	f8c2 4800 	str.w	r4, [r2, #2048]	; 0x800
  gpiop->ODR     = config->odr;
 8004330:	f64f 74cf 	movw	r4, #65487	; 0xffcf
  gpiop->OTYPER  = config->otyper;
 8004334:	f8c2 3c04 	str.w	r3, [r2, #3076]	; 0xc04
 8004338:	f502 6240 	add.w	r2, r2, #3072	; 0xc00
  gpiop->OSPEEDR = config->ospeedr;
 800433c:	6090      	str	r0, [r2, #8]
  gpiop->PUPDR   = config->pupdr;
 800433e:	60d3      	str	r3, [r2, #12]
  gpiop->ODR     = config->odr;
 8004340:	6154      	str	r4, [r2, #20]
  gpiop->AFRL    = config->afrl;
 8004342:	f245 5450 	movw	r4, #21840	; 0x5550
 8004346:	6214      	str	r4, [r2, #32]
  gpiop->MODER   = config->moder;
 8004348:	4c6e      	ldr	r4, [pc, #440]	; (8004504 <__early_init+0x344>)
  gpiop->AFRH    = config->afrh;
 800434a:	6253      	str	r3, [r2, #36]	; 0x24
  gpiop->MODER   = config->moder;
 800434c:	6014      	str	r4, [r2, #0]
  gpiop->PUPDR   = config->pupdr;
 800434e:	f04f 3455 	mov.w	r4, #1431655765	; 0x55555555
  gpiop->OTYPER  = config->otyper;
 8004352:	f8c2 3404 	str.w	r3, [r2, #1028]	; 0x404
  gpiop->OSPEEDR = config->ospeedr;
 8004356:	f8c2 3408 	str.w	r3, [r2, #1032]	; 0x408
  gpiop->PUPDR   = config->pupdr;
 800435a:	f8c2 440c 	str.w	r4, [r2, #1036]	; 0x40c
  gpiop->ODR     = config->odr;
 800435e:	f8c2 0414 	str.w	r0, [r2, #1044]	; 0x414
  gpiop->AFRL    = config->afrl;
 8004362:	f8c2 3420 	str.w	r3, [r2, #1056]	; 0x420
  gpiop->AFRH    = config->afrh;
 8004366:	f8c2 3424 	str.w	r3, [r2, #1060]	; 0x424
  gpiop->MODER   = config->moder;
 800436a:	f8c2 3400 	str.w	r3, [r2, #1024]	; 0x400
  gpiop->OTYPER  = config->otyper;
 800436e:	f8c2 3804 	str.w	r3, [r2, #2052]	; 0x804
  gpiop->OSPEEDR = config->ospeedr;
 8004372:	f8c2 3808 	str.w	r3, [r2, #2056]	; 0x808
  gpiop->PUPDR   = config->pupdr;
 8004376:	f8c2 480c 	str.w	r4, [r2, #2060]	; 0x80c
  gpiop->ODR     = config->odr;
 800437a:	f8c2 0814 	str.w	r0, [r2, #2068]	; 0x814
  (void)pwr;
#endif

  /* Lower C3 byte, it must be programmed at very first, then waiting for
     power supply to stabilize.*/
  PWR->CR3   = STM32_PWR_CR3 & 0x000000FFU;
 800437e:	2002      	movs	r0, #2
  gpiop->AFRL    = config->afrl;
 8004380:	f8c2 3820 	str.w	r3, [r2, #2080]	; 0x820

#if defined(STM32_ENFORCE_H7_REV_XY)
  /* Fix for errata 2.2.15: Reading from AXI SRAM might lead to data
     read corruption.
     AXI->TARG7_FN_MOD.*/
  *((volatile uint32_t *)(0x51000000 + 0x1108 + 0x7000)) = 0x00000001U;
 8004384:	4c60      	ldr	r4, [pc, #384]	; (8004508 <__early_init+0x348>)
  gpiop->AFRH    = config->afrh;
 8004386:	f8c2 3824 	str.w	r3, [r2, #2084]	; 0x824
  gpiop->MODER   = config->moder;
 800438a:	f8c2 3800 	str.w	r3, [r2, #2048]	; 0x800
 800438e:	2301      	movs	r3, #1
  PWR->CR3   = STM32_PWR_CR3 & 0x000000FFU;
 8004390:	f502 5220 	add.w	r2, r2, #10240	; 0x2800
  *((volatile uint32_t *)(0x51000000 + 0x1108 + 0x7000)) = 0x00000001U;
 8004394:	f8c4 3108 	str.w	r3, [r4, #264]	; 0x108
  RCC_C1->APB4ENR |= mask;
 8004398:	f8d1 30f4 	ldr.w	r3, [r1, #244]	; 0xf4
 800439c:	4303      	orrs	r3, r0
 800439e:	f8c1 30f4 	str.w	r3, [r1, #244]	; 0xf4
    RCC_C1->APB4LPENR |= mask;
 80043a2:	f8d1 311c 	ldr.w	r3, [r1, #284]	; 0x11c
 80043a6:	4303      	orrs	r3, r0
 80043a8:	f8c1 311c 	str.w	r3, [r1, #284]	; 0x11c
  (void)RCC_C1->APB4LPENR;
 80043ac:	f8d1 311c 	ldr.w	r3, [r1, #284]	; 0x11c
  PWR->CR3   = STM32_PWR_CR3 & 0x000000FFU;
 80043b0:	60d0      	str	r0, [r2, #12]
  while ((PWR->CSR1 & PWR_CSR1_ACTVOSRDY) == 0)
 80043b2:	6853      	ldr	r3, [r2, #4]
 80043b4:	0499      	lsls	r1, r3, #18
 80043b6:	d5fc      	bpl.n	80043b2 <__early_init+0x1f2>
  PWR->CR1   = STM32_PWR_CR1 | 0xF0000000U;
 80043b8:	4954      	ldr	r1, [pc, #336]	; (800450c <__early_init+0x34c>)
  PWR->CR2   = STM32_PWR_CR2;
 80043ba:	2301      	movs	r3, #1
  PWR->CR3   = STM32_PWR_CR3;   /* Other bits, lower byte is not changed.   */
 80043bc:	4c54      	ldr	r4, [pc, #336]	; (8004510 <__early_init+0x350>)
  PWR->CPUCR = STM32_PWR_CPUCR;
 80043be:	2000      	movs	r0, #0
  PWR->CR1   = STM32_PWR_CR1 | 0xF0000000U;
 80043c0:	6011      	str	r1, [r2, #0]
  PWR->CR2   = STM32_PWR_CR2;
 80043c2:	6093      	str	r3, [r2, #8]
  PWR->D3CR  = STM32_VOS;
 80043c4:	f44f 4340 	mov.w	r3, #49152	; 0xc000
  while ((PWR->D3CR & PWR_D3CR_VOSRDY) == 0)
 80043c8:	4952      	ldr	r1, [pc, #328]	; (8004514 <__early_init+0x354>)
  PWR->CR3   = STM32_PWR_CR3;   /* Other bits, lower byte is not changed.   */
 80043ca:	60d4      	str	r4, [r2, #12]
  PWR->CPUCR = STM32_PWR_CPUCR;
 80043cc:	6110      	str	r0, [r2, #16]
  PWR->D3CR  = STM32_VOS;
 80043ce:	6193      	str	r3, [r2, #24]
  while ((PWR->D3CR & PWR_D3CR_VOSRDY) == 0)
 80043d0:	698b      	ldr	r3, [r1, #24]
 80043d2:	049a      	lsls	r2, r3, #18
 80043d4:	d5fc      	bpl.n	80043d0 <__early_init+0x210>
  PWR->CR1 |= PWR_CR1_DBP;
 80043d6:	680b      	ldr	r3, [r1, #0]
  if ((RCC->BDCR & STM32_RTCSEL_MASK) != STM32_RTCSEL) {
 80043d8:	4a2e      	ldr	r2, [pc, #184]	; (8004494 <__early_init+0x2d4>)
  PWR->CR1 |= PWR_CR1_DBP;
 80043da:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 80043de:	600b      	str	r3, [r1, #0]
  if ((RCC->BDCR & STM32_RTCSEL_MASK) != STM32_RTCSEL) {
 80043e0:	6f13      	ldr	r3, [r2, #112]	; 0x70
 80043e2:	f403 7340 	and.w	r3, r3, #768	; 0x300
 80043e6:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 80043ea:	d004      	beq.n	80043f6 <__early_init+0x236>
    RCC->BDCR = RCC_BDCR_BDRST;
 80043ec:	f44f 3180 	mov.w	r1, #65536	; 0x10000
    RCC->BDCR = 0;
 80043f0:	2300      	movs	r3, #0
    RCC->BDCR = RCC_BDCR_BDRST;
 80043f2:	6711      	str	r1, [r2, #112]	; 0x70
    RCC->BDCR = 0;
 80043f4:	6713      	str	r3, [r2, #112]	; 0x70
  /* Backup domain initialization.*/
  init_bkp_domain();

  /* HSI setup, it enforces the reset situation in order to handle possible
     problems with JTAG probes and re-initializations.*/
  RCC->CR |= RCC_CR_HSION;                  /* Make sure HSI is ON.         */
 80043f6:	4927      	ldr	r1, [pc, #156]	; (8004494 <__early_init+0x2d4>)
 80043f8:	680b      	ldr	r3, [r1, #0]
 80043fa:	f043 0301 	orr.w	r3, r3, #1
 80043fe:	600b      	str	r3, [r1, #0]
  while (!(RCC->CR & RCC_CR_HSIRDY))
 8004400:	680b      	ldr	r3, [r1, #0]
 8004402:	075b      	lsls	r3, r3, #29
 8004404:	d5fc      	bpl.n	8004400 <__early_init+0x240>
    ;                                       /* Wait until HSI is stable.    */

  /* HSI is selected as new source without touching the other fields in
     CFGR. This is only required when using a debugger than can cause
     restarts.*/
  RCC->CFGR    = 0x00000000U;               /* Reset SW to HSI.             */
 8004406:	2300      	movs	r3, #0
  while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_HSI)
 8004408:	4a22      	ldr	r2, [pc, #136]	; (8004494 <__early_init+0x2d4>)
  RCC->CFGR    = 0x00000000U;               /* Reset SW to HSI.             */
 800440a:	610b      	str	r3, [r1, #16]
  while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_HSI)
 800440c:	6913      	ldr	r3, [r2, #16]
 800440e:	f013 0338 	ands.w	r3, r3, #56	; 0x38
 8004412:	d1fb      	bne.n	800440c <__early_init+0x24c>
    ;                                       /* Wait until HSI is selected.  */

  /* Registers cleared to reset values.*/
  RCC->CR      = RCC_CR_HSION;             /* CR Reset value.              */
  RCC->HSICFGR = 0x40000000U;              /* HSICFGR Reset value.         */
 8004414:	f04f 4080 	mov.w	r0, #1073741824	; 0x40000000
  RCC->CR      = RCC_CR_HSION;             /* CR Reset value.              */
 8004418:	2401      	movs	r4, #1
#if !defined(STM32_ENFORCE_H7_REV_XY)
  RCC->CSICFGR = 0x20000000U;              /* CSICFGR Reset value.         */
#endif
  RCC->CSR     = 0x00000000U;              /* CSR reset value.             */
  RCC->PLLCFGR = 0x01FF0000U;              /* PLLCFGR reset value.         */
 800441a:	493f      	ldr	r1, [pc, #252]	; (8004518 <__early_init+0x358>)
  RCC->CR      = RCC_CR_HSION;             /* CR Reset value.              */
 800441c:	6014      	str	r4, [r2, #0]
  RCC->HSICFGR = 0x40000000U;              /* HSICFGR Reset value.         */
 800441e:	6050      	str	r0, [r2, #4]
  cfgr |= STM32_HRTIMSEL;
#endif
#if STM32_TIMPRE_ENABLE == TRUE
  cfgr |= RCC_CFGR_TIMPRE;
#endif
  RCC->CFGR = cfgr;
 8004420:	483e      	ldr	r0, [pc, #248]	; (800451c <__early_init+0x35c>)
  RCC->CSR     = 0x00000000U;              /* CSR reset value.             */
 8004422:	6753      	str	r3, [r2, #116]	; 0x74
  RCC->PLLCFGR = 0x01FF0000U;              /* PLLCFGR reset value.         */
 8004424:	62d1      	str	r1, [r2, #44]	; 0x2c
  RCC->CFGR = cfgr;
 8004426:	6110      	str	r0, [r2, #16]
    ;                           /* Waits until HSE is stable.               */
#endif /* STM32_HSE_ENABLED == TRUE */

  /* HSI48 activation.*/
#if STM32_HSI48_ENABLED == TRUE
  RCC->CR |= RCC_CR_HSI48ON;
 8004428:	6813      	ldr	r3, [r2, #0]
  while ((RCC->CR & RCC_CR_HSI48RDY) == 0)
 800442a:	491a      	ldr	r1, [pc, #104]	; (8004494 <__early_init+0x2d4>)
  RCC->CR |= RCC_CR_HSI48ON;
 800442c:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
 8004430:	6013      	str	r3, [r2, #0]
  while ((RCC->CR & RCC_CR_HSI48RDY) == 0)
 8004432:	680b      	ldr	r3, [r1, #0]
 8004434:	049d      	lsls	r5, r3, #18
 8004436:	d5fc      	bpl.n	8004432 <__early_init+0x272>

#endif /* STM32_HSI48_ENABLED == TRUE */

  /* CSI activation.*/
#if STM32_CSI_ENABLED == TRUE
  RCC->CR |= RCC_CR_CSION;
 8004438:	680b      	ldr	r3, [r1, #0]
  while ((RCC->CR & RCC_CR_CSIRDY) == 0)
 800443a:	4a16      	ldr	r2, [pc, #88]	; (8004494 <__early_init+0x2d4>)
  RCC->CR |= RCC_CR_CSION;
 800443c:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8004440:	600b      	str	r3, [r1, #0]
  while ((RCC->CR & RCC_CR_CSIRDY) == 0)
 8004442:	6813      	ldr	r3, [r2, #0]
 8004444:	05dc      	lsls	r4, r3, #23
 8004446:	d5fc      	bpl.n	8004442 <__early_init+0x282>
    ;                           /* Waits until CSI is stable.               */
#endif /* STM32_CSI_ENABLED == TRUE */

  /* LSI activation.*/
#if STM32_LSI_ENABLED == TRUE
  RCC->CSR |= RCC_CSR_LSION;
 8004448:	6f53      	ldr	r3, [r2, #116]	; 0x74
  while ((RCC->CSR & RCC_CSR_LSIRDY) == 0)
 800444a:	4912      	ldr	r1, [pc, #72]	; (8004494 <__early_init+0x2d4>)
  RCC->CSR |= RCC_CSR_LSION;
 800444c:	f043 0301 	orr.w	r3, r3, #1
 8004450:	6753      	str	r3, [r2, #116]	; 0x74
  while ((RCC->CSR & RCC_CSR_LSIRDY) == 0)
 8004452:	6f4b      	ldr	r3, [r1, #116]	; 0x74
 8004454:	0798      	lsls	r0, r3, #30
 8004456:	d5fc      	bpl.n	8004452 <__early_init+0x292>
#endif
#endif /* STM32_PLL2_ENABLED == TRUE */

#if STM32_PLL3_ENABLED == TRUE
    RCC->PLL3FRACR = STM32_PLL3_FRACN;
    RCC->PLL3DIVR  = STM32_PLL3_DIVR | STM32_PLL3_DIVQ |
 8004458:	4a31      	ldr	r2, [pc, #196]	; (8004520 <__early_init+0x360>)
    RCC->PLL3FRACR = STM32_PLL3_FRACN;
 800445a:	2000      	movs	r0, #0
    cfgmask |= RCC_PLLCFGR_DIVR3EN;
#endif
#endif /* STM32_PLL3_ENABLED == TRUE */

    /* Activating enabled PLLs and waiting for all of them to become ready.*/
    RCC->PLLCFGR = cfgmask & STM32_PLLCFGR_MASK;
 800445c:	4b31      	ldr	r3, [pc, #196]	; (8004524 <__early_init+0x364>)
    RCC->PLLCKSELR = RCC_PLLCKSELR_DIVM3_VALUE(STM32_PLL3_DIVM_VALUE) |
 800445e:	4c32      	ldr	r4, [pc, #200]	; (8004528 <__early_init+0x368>)
 8004460:	628c      	str	r4, [r1, #40]	; 0x28
    RCC->PLL3FRACR = STM32_PLL3_FRACN;
 8004462:	6448      	str	r0, [r1, #68]	; 0x44
    RCC->PLL3DIVR  = STM32_PLL3_DIVR | STM32_PLL3_DIVQ |
 8004464:	640a      	str	r2, [r1, #64]	; 0x40
    RCC->PLLCFGR = cfgmask & STM32_PLLCFGR_MASK;
 8004466:	62cb      	str	r3, [r1, #44]	; 0x2c
    RCC->CR     |= onmask;
 8004468:	680b      	ldr	r3, [r1, #0]
    while ((RCC->CR & rdymask) != rdymask)
 800446a:	4a0a      	ldr	r2, [pc, #40]	; (8004494 <__early_init+0x2d4>)
    RCC->CR     |= onmask;
 800446c:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 8004470:	600b      	str	r3, [r1, #0]
    while ((RCC->CR & rdymask) != rdymask)
 8004472:	6813      	ldr	r3, [r2, #0]
 8004474:	0099      	lsls	r1, r3, #2
 8004476:	d5fc      	bpl.n	8004472 <__early_init+0x2b2>
#if defined(HAL_LLD_TYPE3_H)
  RCC->CDCFGR1 = STM32_CDCPRE  | STM32_CDPPRE | STM32_CDHPRE;
  RCC->CDCFGR2 = STM32_CDPPRE2 | STM32_CDPPRE1;
  RCC->SRDCFGR = STM32_SRDPPRE;
#else
  RCC->D1CFGR = STM32_D1CPRE  | STM32_D1PPRE3 | STM32_D1HPRE;
 8004478:	2048      	movs	r0, #72	; 0x48
  RCC->D3CFGR = STM32_D3PPRE4;
#endif

  /* Peripherals clocks.*/
#if defined(HAL_LLD_TYPE1_H)
  RCC->D1CCIPR  = STM32_CKPERSEL   | STM32_SDMMCSEL    | STM32_QSPISEL       |
 800447a:	2300      	movs	r3, #0
  RCC->D2CFGR = STM32_D2PPRE2 | STM32_D2PPRE1;
 800447c:	f44f 6188 	mov.w	r1, #1088	; 0x440
  RCC->D3CFGR = STM32_D3PPRE4;
 8004480:	2440      	movs	r4, #64	; 0x40
  RCC->D1CFGR = STM32_D1CPRE  | STM32_D1PPRE3 | STM32_D1HPRE;
 8004482:	6190      	str	r0, [r2, #24]
                  STM32_FMCSEL;
  RCC->D2CCIP1R = STM32_SWPSEL     | STM32_FDCANSEL    | STM32_DFSDM1SEL     |
                  STM32_SPDIFSEL   | STM32_SPDIFSEL    | STM32_SPI45SEL      |
                  STM32_SPI123SEL  | STM32_SAI23SEL    | STM32_SAI1SEL;
  RCC->D2CCIP2R = STM32_LPTIM1SEL  | STM32_CECSEL      | STM32_USBSEL        |
 8004484:	f44f 1040 	mov.w	r0, #3145728	; 0x300000
  RCC->D2CFGR = STM32_D2PPRE2 | STM32_D2PPRE1;
 8004488:	61d1      	str	r1, [r2, #28]
  RCC->D3CFGR = STM32_D3PPRE4;
 800448a:	6214      	str	r4, [r2, #32]
                  STM32_LPTIM3SEL  | STM32_LPTIM2SEL   | STM32_I2C4SEL       |
                  STM32_LPUART1SEL;
#endif

  /* Flash setup.*/
  FLASH->ACR = FLASH_ACR_WRHIGHFREQ_1 | FLASH_ACR_WRHIGHFREQ_0 |
 800448c:	4927      	ldr	r1, [pc, #156]	; (800452c <__early_init+0x36c>)
  RCC->D1CCIPR  = STM32_CKPERSEL   | STM32_SDMMCSEL    | STM32_QSPISEL       |
 800448e:	64d3      	str	r3, [r2, #76]	; 0x4c
 8004490:	e04e      	b.n	8004530 <__early_init+0x370>
 8004492:	bf00      	nop
 8004494:	58024400 	.word	0x58024400
 8004498:	fffff800 	.word	0xfffff800
 800449c:	abf300fc 	.word	0xabf300fc
 80044a0:	58020000 	.word	0x58020000
 80044a4:	58020400 	.word	0x58020400
 80044a8:	b0000bb0 	.word	0xb0000bb0
 80044ac:	000aaa0a 	.word	0x000aaa0a
 80044b0:	aaaed56b 	.word	0xaaaed56b
 80044b4:	fca0cfca 	.word	0xfca0cfca
 80044b8:	00666022 	.word	0x00666022
 80044bc:	ccb01100 	.word	0xccb01100
 80044c0:	abaf7aba 	.word	0xabaf7aba
 80044c4:	03ffccff 	.word	0x03ffccff
 80044c8:	30bbccbc 	.word	0x30bbccbc
 80044cc:	000ccccc 	.word	0x000ccccc
 80044d0:	02aabbaa 	.word	0x02aabbaa
 80044d4:	fa3ff03f 	.word	0xfa3ff03f
 80044d8:	50000ccc 	.word	0x50000ccc
 80044dc:	aaea9fea 	.word	0xaaea9fea
 80044e0:	aaaabaaa 	.word	0xaaaabaaa
 80044e4:	ffcfcfff 	.word	0xffcfcfff
 80044e8:	50cccccc 	.word	0x50cccccc
 80044ec:	ffff0f3f 	.word	0xffff0f3f
 80044f0:	00cc0ccc 	.word	0x00cc0ccc
 80044f4:	c555505c 	.word	0xc555505c
 80044f8:	aa9a1aea 	.word	0xaa9a1aea
 80044fc:	00a14005 	.word	0x00a14005
 8004500:	ffaebd5a 	.word	0xffaebd5a
 8004504:	ffff55a9 	.word	0xffff55a9
 8004508:	51008000 	.word	0x51008000
 800450c:	f000c000 	.word	0xf000c000
 8004510:	01000002 	.word	0x01000002
 8004514:	58024800 	.word	0x58024800
 8004518:	01ff0000 	.word	0x01ff0000
 800451c:	08108800 	.word	0x08108800
 8004520:	07070e31 	.word	0x07070e31
 8004524:	01c00ddd 	.word	0x01c00ddd
 8004528:	00404040 	.word	0x00404040
 800452c:	52002000 	.word	0x52002000
  RCC->D2CCIP1R = STM32_SWPSEL     | STM32_FDCANSEL    | STM32_DFSDM1SEL     |
 8004530:	6513      	str	r3, [r2, #80]	; 0x50
  RCC->D2CCIP2R = STM32_LPTIM1SEL  | STM32_CECSEL      | STM32_USBSEL        |
 8004532:	6550      	str	r0, [r2, #84]	; 0x54
  FLASH->ACR = FLASH_ACR_WRHIGHFREQ_1 | FLASH_ACR_WRHIGHFREQ_0 |
 8004534:	2030      	movs	r0, #48	; 0x30
  RCC->D3CCIPR  = STM32_SPI6SEL    | STM32_SAI4BSEL    | STM32_SAI4ASEL      |
 8004536:	6593      	str	r3, [r2, #88]	; 0x58
  FLASH->ACR = FLASH_ACR_WRHIGHFREQ_1 | FLASH_ACR_WRHIGHFREQ_0 |
 8004538:	6008      	str	r0, [r1, #0]
               STM32_FLASHBITS;
  while ((FLASH->ACR & FLASH_ACR_LATENCY) !=
 800453a:	680b      	ldr	r3, [r1, #0]
 800453c:	071b      	lsls	r3, r3, #28
 800453e:	d1fc      	bne.n	800453a <__early_init+0x37a>
  RCC_C1->AHB2ENR |= mask;
 8004540:	4b16      	ldr	r3, [pc, #88]	; (800459c <__early_init+0x3dc>)
 8004542:	f8d3 20dc 	ldr.w	r2, [r3, #220]	; 0xdc
 8004546:	f042 5200 	orr.w	r2, r2, #536870912	; 0x20000000
 800454a:	f8c3 20dc 	str.w	r2, [r3, #220]	; 0xdc
    RCC_C1->AHB2LPENR |= mask;
 800454e:	f8d3 2104 	ldr.w	r2, [r3, #260]	; 0x104
 8004552:	f042 5200 	orr.w	r2, r2, #536870912	; 0x20000000
 8004556:	f8c3 2104 	str.w	r2, [r3, #260]	; 0x104
  (void)RCC_C1->AHB2LPENR;
 800455a:	f8d3 2104 	ldr.w	r2, [r3, #260]	; 0x104
  RCC_C1->AHB2ENR |= mask;
 800455e:	f8d3 20dc 	ldr.w	r2, [r3, #220]	; 0xdc
 8004562:	f042 4280 	orr.w	r2, r2, #1073741824	; 0x40000000
 8004566:	f8c3 20dc 	str.w	r2, [r3, #220]	; 0xdc
    RCC_C1->AHB2LPENR |= mask;
 800456a:	f8d3 2104 	ldr.w	r2, [r3, #260]	; 0x104
 800456e:	f042 4280 	orr.w	r2, r2, #1073741824	; 0x40000000
 8004572:	f8c3 2104 	str.w	r2, [r3, #260]	; 0x104
  (void)RCC_C1->AHB2LPENR;
 8004576:	f8d3 2104 	ldr.w	r2, [r3, #260]	; 0x104
  RCC_C1->AHB2ENR |= mask;
 800457a:	f8d3 20dc 	ldr.w	r2, [r3, #220]	; 0xdc
 800457e:	f042 4200 	orr.w	r2, r2, #2147483648	; 0x80000000
 8004582:	f8c3 20dc 	str.w	r2, [r3, #220]	; 0xdc
    RCC_C1->AHB2LPENR |= mask;
 8004586:	f8d3 2104 	ldr.w	r2, [r3, #260]	; 0x104
 800458a:	f042 4200 	orr.w	r2, r2, #2147483648	; 0x80000000
}
 800458e:	bc30      	pop	{r4, r5}
 8004590:	f8c3 2104 	str.w	r2, [r3, #260]	; 0x104
  (void)RCC_C1->AHB2LPENR;
 8004594:	f8d3 3104 	ldr.w	r3, [r3, #260]	; 0x104
 8004598:	4770      	bx	lr
 800459a:	bf00      	nop
 800459c:	58024400 	.word	0x58024400

080045a0 <chSchDoPreemption>:
static void __sch_reschedule_ahead(void) {
 80045a0:	b570      	push	{r4, r5, r6, lr}
  thread_t *otp = __instance_get_currthread(oip);
 80045a2:	4c15      	ldr	r4, [pc, #84]	; (80045f8 <chSchDoPreemption+0x58>)
  ntp->state = CH_STATE_CURRENT;
 80045a4:	2201      	movs	r2, #1
  ch_priority_queue_t *p = pqp->next;
 80045a6:	6825      	ldr	r5, [r4, #0]
  thread_t *otp = __instance_get_currthread(oip);
 80045a8:	68e0      	ldr	r0, [r4, #12]
  pqp->next       = p->next;
 80045aa:	682b      	ldr	r3, [r5, #0]
  pqp->next->prev = pqp;
 80045ac:	605c      	str	r4, [r3, #4]
  ntp->state = CH_STATE_CURRENT;
 80045ae:	f885 2024 	strb.w	r2, [r5, #36]	; 0x24
  pqp->next       = p->next;
 80045b2:	6023      	str	r3, [r4, #0]
  __instance_set_currthread(oip, ntp);
 80045b4:	60e5      	str	r5, [r4, #12]
  otp = __sch_ready_ahead(otp);
 80045b6:	f7fc fc2b 	bl	8000e10 <__sch_ready_ahead>
  if ((oip->trace_buffer.suspended & CH_DBG_TRACE_MASK_SWITCH) == 0U) {
 80045ba:	f8b4 3088 	ldrh.w	r3, [r4, #136]	; 0x88
 80045be:	4606      	mov	r6, r0
 80045c0:	079b      	lsls	r3, r3, #30
 80045c2:	d505      	bpl.n	80045d0 <chSchDoPreemption+0x30>
  chSysSwitch(ntp, otp);
 80045c4:	4631      	mov	r1, r6
 80045c6:	4628      	mov	r0, r5
}
 80045c8:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  chSysSwitch(ntp, otp);
 80045cc:	f7fb bef8 	b.w	80003c0 <__port_switch>
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_SWITCH;
 80045d0:	f890 3024 	ldrb.w	r3, [r0, #36]	; 0x24
 80045d4:	6a81      	ldr	r1, [r0, #40]	; 0x28
 80045d6:	00db      	lsls	r3, r3, #3
 80045d8:	f8d4 208c 	ldr.w	r2, [r4, #140]	; 0x8c
 80045dc:	f043 0302 	orr.w	r3, r3, #2
    oip->trace_buffer.ptr->u.sw.wtobjp = otp->u.wtobjp;
 80045e0:	e9c2 5102 	strd	r5, r1, [r2, #8]
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_SWITCH;
 80045e4:	7013      	strb	r3, [r2, #0]
    trace_next(oip);
 80045e6:	f7fc fbc3 	bl	8000d70 <trace_next.constprop.0>
 80045ea:	4631      	mov	r1, r6
 80045ec:	4628      	mov	r0, r5
}
 80045ee:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  chSysSwitch(ntp, otp);
 80045f2:	f7fb bee5 	b.w	80003c0 <__port_switch>
 80045f6:	bf00      	nop
 80045f8:	24000330 	.word	0x24000330
 80045fc:	00000000 	.word	0x00000000

08004600 <chMBPostTimeoutS.constprop.0>:
    if (mbp->reset) {
 8004600:	4b15      	ldr	r3, [pc, #84]	; (8004658 <chMBPostTimeoutS.constprop.0+0x58>)
 8004602:	7d1a      	ldrb	r2, [r3, #20]
 8004604:	bb1a      	cbnz	r2, 800464e <chMBPostTimeoutS.constprop.0+0x4e>
  return mbp->cnt;
 8004606:	691a      	ldr	r2, [r3, #16]
msg_t chMBPostTimeoutS(mailbox_t *mbp, msg_t msg, sysinterval_t timeout) {
 8004608:	b570      	push	{r4, r5, r6, lr}
  return (size_t)(mbp->top - mbp->buffer);
 800460a:	e9d3 1400 	ldrd	r1, r4, [r3]
 800460e:	eba4 0c01 	sub.w	ip, r4, r1
    if (chMBGetFreeCountI(mbp) > (size_t)0) {
 8004612:	ebb2 0fac 	cmp.w	r2, ip, asr #2
 8004616:	d102      	bne.n	800461e <chMBPostTimeoutS.constprop.0+0x1e>
  return rdymsg;
 8004618:	f04f 30ff 	mov.w	r0, #4294967295
}
 800461c:	bd70      	pop	{r4, r5, r6, pc}
      *mbp->wrptr++ = msg;
 800461e:	689e      	ldr	r6, [r3, #8]
      mbp->cnt++;
 8004620:	3201      	adds	r2, #1
      *mbp->wrptr++ = msg;
 8004622:	1d35      	adds	r5, r6, #4
      if (mbp->wrptr >= mbp->top) {
 8004624:	42ac      	cmp	r4, r5
      *mbp->wrptr++ = msg;
 8004626:	609d      	str	r5, [r3, #8]
 8004628:	6030      	str	r0, [r6, #0]
        mbp->wrptr = mbp->buffer;
 800462a:	bf88      	it	hi
 800462c:	6899      	ldrhi	r1, [r3, #8]
      chThdDequeueNextI(&mbp->qr, MSG_OK);
 800462e:	480b      	ldr	r0, [pc, #44]	; (800465c <chMBPostTimeoutS.constprop.0+0x5c>)
 8004630:	6099      	str	r1, [r3, #8]
      mbp->cnt++;
 8004632:	611a      	str	r2, [r3, #16]
      chThdDequeueNextI(&mbp->qr, MSG_OK);
 8004634:	f7fc fe6c 	bl	8001310 <chThdDequeueNextI.constprop.0>
  if (likely(firstprio(&oip->rlist.pqueue) > tp->hdr.pqueue.prio)) {
 8004638:	4b09      	ldr	r3, [pc, #36]	; (8004660 <chMBPostTimeoutS.constprop.0+0x60>)
 800463a:	681a      	ldr	r2, [r3, #0]
 800463c:	68db      	ldr	r3, [r3, #12]
 800463e:	6892      	ldr	r2, [r2, #8]
 8004640:	689b      	ldr	r3, [r3, #8]
 8004642:	429a      	cmp	r2, r3
 8004644:	d906      	bls.n	8004654 <chMBPostTimeoutS.constprop.0+0x54>
    __sch_reschedule_ahead();
 8004646:	f7ff ffab 	bl	80045a0 <chSchDoPreemption>
      return MSG_OK;
 800464a:	2000      	movs	r0, #0
}
 800464c:	bd70      	pop	{r4, r5, r6, pc}
      return MSG_RESET;
 800464e:	f06f 0001 	mvn.w	r0, #1
}
 8004652:	4770      	bx	lr
      return MSG_OK;
 8004654:	2000      	movs	r0, #0
}
 8004656:	bd70      	pop	{r4, r5, r6, pc}
 8004658:	24000e54 	.word	0x24000e54
 800465c:	24000e74 	.word	0x24000e74
 8004660:	24000330 	.word	0x24000330
	...

08004670 <chMBFetchTimeoutS>:
 * @retval MSG_RESET    if the mailbox has been reset.
 * @retval MSG_TIMEOUT  if the operation has timed out.
 *
 * @sclass
 */
msg_t chMBFetchTimeoutS(mailbox_t *mbp, msg_t *msgp, sysinterval_t timeout) {
 8004670:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  return __sch_get_currthread();
 8004674:	4e20      	ldr	r6, [pc, #128]	; (80046f8 <chMBFetchTimeoutS+0x88>)
 8004676:	4604      	mov	r4, r0
 8004678:	4688      	mov	r8, r1
 800467a:	4691      	mov	r9, r2

      return MSG_OK;
    }

    /* No message in the queue, waiting for a message to become available.*/
    rdymsg = chThdEnqueueTimeoutS(&mbp->qr, timeout);
 800467c:	f100 0720 	add.w	r7, r0, #32
 8004680:	e007      	b.n	8004692 <chMBFetchTimeoutS+0x22>
  p->prev       = qp->prev;
 8004682:	6a65      	ldr	r5, [r4, #36]	; 0x24
 8004684:	e9c3 7500 	strd	r7, r5, [r3]
  p->prev->next = p;
 8004688:	602b      	str	r3, [r5, #0]
  qp->prev      = p;
 800468a:	6263      	str	r3, [r4, #36]	; 0x24
  return chSchGoSleepTimeoutS(CH_STATE_QUEUED, timeout);
 800468c:	f7fd f928 	bl	80018e0 <chSchGoSleepTimeoutS>
  } while (rdymsg == MSG_OK);
 8004690:	b958      	cbnz	r0, 80046aa <chMBFetchTimeoutS+0x3a>
    if (mbp->reset) {
 8004692:	7d23      	ldrb	r3, [r4, #20]
 8004694:	4649      	mov	r1, r9
 8004696:	2004      	movs	r0, #4
 8004698:	b94b      	cbnz	r3, 80046ae <chMBFetchTimeoutS+0x3e>
  return mbp->cnt;
 800469a:	6923      	ldr	r3, [r4, #16]
    if (chMBGetUsedCountI(mbp) > (size_t)0) {
 800469c:	b95b      	cbnz	r3, 80046b6 <chMBFetchTimeoutS+0x46>
 800469e:	68f3      	ldr	r3, [r6, #12]
  if (unlikely(TIME_IMMEDIATE == timeout)) {
 80046a0:	f1b9 0f00 	cmp.w	r9, #0
 80046a4:	d1ed      	bne.n	8004682 <chMBFetchTimeoutS+0x12>
    return MSG_TIMEOUT;
 80046a6:	f04f 30ff 	mov.w	r0, #4294967295

  return rdymsg;
}
 80046aa:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      return MSG_RESET;
 80046ae:	f06f 0001 	mvn.w	r0, #1
}
 80046b2:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      *msgp = *mbp->rdptr++;
 80046b6:	68e1      	ldr	r1, [r4, #12]
 80046b8:	180a      	adds	r2, r1, r0
 80046ba:	6809      	ldr	r1, [r1, #0]
 80046bc:	60e2      	str	r2, [r4, #12]
 80046be:	f8c8 1000 	str.w	r1, [r8]
      if (mbp->rdptr >= mbp->top) {
 80046c2:	6861      	ldr	r1, [r4, #4]
 80046c4:	428a      	cmp	r2, r1
 80046c6:	d211      	bcs.n	80046ec <chMBFetchTimeoutS+0x7c>
      mbp->cnt--;
 80046c8:	3b01      	subs	r3, #1
      chThdDequeueNextI(&mbp->qw, MSG_OK);
 80046ca:	f104 0018 	add.w	r0, r4, #24
      mbp->cnt--;
 80046ce:	6123      	str	r3, [r4, #16]
      chThdDequeueNextI(&mbp->qw, MSG_OK);
 80046d0:	f7fc fe1e 	bl	8001310 <chThdDequeueNextI.constprop.0>
  if (likely(firstprio(&oip->rlist.pqueue) > tp->hdr.pqueue.prio)) {
 80046d4:	4b08      	ldr	r3, [pc, #32]	; (80046f8 <chMBFetchTimeoutS+0x88>)
 80046d6:	681a      	ldr	r2, [r3, #0]
 80046d8:	68db      	ldr	r3, [r3, #12]
 80046da:	6892      	ldr	r2, [r2, #8]
 80046dc:	689b      	ldr	r3, [r3, #8]
 80046de:	429a      	cmp	r2, r3
 80046e0:	d907      	bls.n	80046f2 <chMBFetchTimeoutS+0x82>
    __sch_reschedule_ahead();
 80046e2:	f7ff ff5d 	bl	80045a0 <chSchDoPreemption>
      return MSG_OK;
 80046e6:	2000      	movs	r0, #0
}
 80046e8:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
        mbp->rdptr = mbp->buffer;
 80046ec:	6822      	ldr	r2, [r4, #0]
 80046ee:	60e2      	str	r2, [r4, #12]
 80046f0:	e7ea      	b.n	80046c8 <chMBFetchTimeoutS+0x58>
      return MSG_OK;
 80046f2:	2000      	movs	r0, #0
 80046f4:	e7d9      	b.n	80046aa <chMBFetchTimeoutS+0x3a>
 80046f6:	bf00      	nop
 80046f8:	24000330 	.word	0x24000330
 80046fc:	00000000 	.word	0x00000000

08004700 <post_mb_or_drop>:
 * @param m Paquet USB-MIDI encod dans un `msg_t` (octet 0 dans bits 31..24).
 * @param force_drop_oldest Si vrai, retire le plus ancien lment de la mailbox
 *                          pour insrer le nouveau (politique drop-oldest).
 *                          Sinon, le paquet courant est perdu si la file est pleine.
 */
static void post_mb_or_drop(msg_t m, bool force_drop_oldest) {
 8004700:	b5f0      	push	{r4, r5, r6, r7, lr}
 8004702:	2530      	movs	r5, #48	; 0x30
 8004704:	b083      	sub	sp, #12
 8004706:	4607      	mov	r7, r0
 8004708:	460c      	mov	r4, r1
 800470a:	f385 8811 	msr	BASEPRI, r5
  rdymsg = chMBPostTimeoutS(mbp, msg, timeout);
 800470e:	f7ff ff77 	bl	8004600 <chMBPostTimeoutS.constprop.0>
 8004712:	2600      	movs	r6, #0
 8004714:	f386 8811 	msr	BASEPRI, r6
  if (chMBPostTimeout(&midi_usb_mb, m, TIME_IMMEDIATE) != MSG_OK) {
 8004718:	2800      	cmp	r0, #0
 800471a:	d038      	beq.n	800478e <post_mb_or_drop+0x8e>
    if (force_drop_oldest || MIDI_MB_DROP_OLDEST) {
 800471c:	b92c      	cbnz	r4, 800472a <post_mb_or_drop+0x2a>
      if (chMBPostTimeout(&midi_usb_mb, m, TIME_IMMEDIATE) != MSG_OK)
        midi_tx_stats.tx_mb_drops++;
      else
        midi_usb_queue_increment();
    } else {
      midi_tx_stats.tx_mb_drops++;
 800471e:	4a1f      	ldr	r2, [pc, #124]	; (800479c <post_mb_or_drop+0x9c>)
 8004720:	6953      	ldr	r3, [r2, #20]
 8004722:	3301      	adds	r3, #1
 8004724:	6153      	str	r3, [r2, #20]
    }
  } else {
    midi_usb_queue_increment();
  }
}
 8004726:	b003      	add	sp, #12
 8004728:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800472a:	f385 8811 	msr	BASEPRI, r5
  rdymsg = chMBFetchTimeoutS(mbp, msgp, timeout);
 800472e:	481c      	ldr	r0, [pc, #112]	; (80047a0 <post_mb_or_drop+0xa0>)
 8004730:	4632      	mov	r2, r6
 8004732:	a901      	add	r1, sp, #4
 8004734:	f7ff ff9c 	bl	8004670 <chMBFetchTimeoutS>
 8004738:	f386 8811 	msr	BASEPRI, r6
      if (chMBFetchTimeout(&midi_usb_mb, &throwaway, TIME_IMMEDIATE) == MSG_OK) {
 800473c:	b948      	cbnz	r0, 8004752 <post_mb_or_drop+0x52>
 800473e:	f385 8811 	msr	BASEPRI, r5
  if (midi_usb_queue_fill > 0U) {
 8004742:	4a18      	ldr	r2, [pc, #96]	; (80047a4 <post_mb_or_drop+0xa4>)
 8004744:	8813      	ldrh	r3, [r2, #0]
 8004746:	b10b      	cbz	r3, 800474c <post_mb_or_drop+0x4c>
    midi_usb_queue_fill--;
 8004748:	3b01      	subs	r3, #1
 800474a:	8013      	strh	r3, [r2, #0]
 800474c:	2300      	movs	r3, #0
 800474e:	f383 8811 	msr	BASEPRI, r3
 8004752:	2430      	movs	r4, #48	; 0x30
 8004754:	f384 8811 	msr	BASEPRI, r4
  rdymsg = chMBPostTimeoutS(mbp, msg, timeout);
 8004758:	4638      	mov	r0, r7
 800475a:	f7ff ff51 	bl	8004600 <chMBPostTimeoutS.constprop.0>
 800475e:	2300      	movs	r3, #0
 8004760:	f383 8811 	msr	BASEPRI, r3
      if (chMBPostTimeout(&midi_usb_mb, m, TIME_IMMEDIATE) != MSG_OK)
 8004764:	2800      	cmp	r0, #0
 8004766:	d1da      	bne.n	800471e <post_mb_or_drop+0x1e>
 8004768:	f384 8811 	msr	BASEPRI, r4
  if (midi_usb_queue_fill < MIDI_USB_QUEUE_LEN) {
 800476c:	4a0d      	ldr	r2, [pc, #52]	; (80047a4 <post_mb_or_drop+0xa4>)
 800476e:	8813      	ldrh	r3, [r2, #0]
 8004770:	2bff      	cmp	r3, #255	; 0xff
 8004772:	d807      	bhi.n	8004784 <post_mb_or_drop+0x84>
    if (midi_usb_queue_fill > midi_usb_queue_high_water) {
 8004774:	490c      	ldr	r1, [pc, #48]	; (80047a8 <post_mb_or_drop+0xa8>)
    midi_usb_queue_fill++;
 8004776:	3301      	adds	r3, #1
    if (midi_usb_queue_fill > midi_usb_queue_high_water) {
 8004778:	8808      	ldrh	r0, [r1, #0]
    midi_usb_queue_fill++;
 800477a:	b29b      	uxth	r3, r3
    if (midi_usb_queue_fill > midi_usb_queue_high_water) {
 800477c:	4298      	cmp	r0, r3
    midi_usb_queue_fill++;
 800477e:	8013      	strh	r3, [r2, #0]
      midi_usb_queue_high_water = midi_usb_queue_fill;
 8004780:	bf38      	it	cc
 8004782:	800b      	strhcc	r3, [r1, #0]
 8004784:	2300      	movs	r3, #0
 8004786:	f383 8811 	msr	BASEPRI, r3
}
 800478a:	b003      	add	sp, #12
 800478c:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800478e:	f385 8811 	msr	BASEPRI, r5
  if (midi_usb_queue_fill < MIDI_USB_QUEUE_LEN) {
 8004792:	4a04      	ldr	r2, [pc, #16]	; (80047a4 <post_mb_or_drop+0xa4>)
 8004794:	8813      	ldrh	r3, [r2, #0]
 8004796:	2bff      	cmp	r3, #255	; 0xff
 8004798:	d8f4      	bhi.n	8004784 <post_mb_or_drop+0x84>
 800479a:	e7eb      	b.n	8004774 <post_mb_or_drop+0x74>
 800479c:	24000e38 	.word	0x24000e38
 80047a0:	24000e54 	.word	0x24000e54
 80047a4:	2400127c 	.word	0x2400127c
 80047a8:	2400127e 	.word	0x2400127e
 80047ac:	00000000 	.word	0x00000000

080047b0 <send_usb.constprop.0>:
 * - Pour les **Notes** : tentative immdiate (sans attente active), sinon agrgation.
 *
 * @param msg Pointeur vers le message MIDI (status + data).
 * @param len Taille du message en octets (1  3 selon le type).
 */
static void send_usb(const uint8_t *msg, size_t len) {
 80047b0:	b530      	push	{r4, r5, lr}
  uint8_t packet[4]={0,0,0,0};
 80047b2:	2300      	movs	r3, #0
static void send_usb(const uint8_t *msg, size_t len) {
 80047b4:	b083      	sub	sp, #12
  const uint8_t st = msg[0];
 80047b6:	7802      	ldrb	r2, [r0, #0]
  uint8_t packet[4]={0,0,0,0};
 80047b8:	9301      	str	r3, [sp, #4]
 80047ba:	f002 03f0 	and.w	r3, r2, #240	; 0xf0
  const uint8_t cable = (uint8_t)(MIDI_USB_CABLE<<4);

  bool is_note=false;

  /* Channel Voice */
  if ((st & 0xF0)==0x80 && len>=3){ packet[0]=cable|0x08; packet[1]=msg[0]; packet[2]=msg[1]; packet[3]=msg[2]; is_note=true; }
 80047be:	2b80      	cmp	r3, #128	; 0x80
 80047c0:	d033      	beq.n	800482a <send_usb.constprop.0+0x7a>
  else if ((st & 0xF0)==0x90 && len>=3){ packet[0]=cable|0x09; packet[1]=msg[0]; packet[2]=msg[1]; packet[3]=msg[2]; is_note=true; }
 80047c2:	2b90      	cmp	r3, #144	; 0x90
 80047c4:	d015      	beq.n	80047f2 <send_usb.constprop.0+0x42>
  else if ((st & 0xF0)==0xA0 && len>=3){ packet[0]=cable|0x0A; packet[1]=msg[0]; packet[2]=msg[1]; packet[3]=msg[2]; }
 80047c6:	2ba0      	cmp	r3, #160	; 0xa0
 80047c8:	d060      	beq.n	800488c <send_usb.constprop.0+0xdc>
  else if ((st & 0xF0)==0xB0 && len>=3){ packet[0]=cable|0x0B; packet[1]=msg[0]; packet[2]=msg[1]; packet[3]=msg[2]; }
 80047ca:	2bb0      	cmp	r3, #176	; 0xb0
 80047cc:	d02f      	beq.n	800482e <send_usb.constprop.0+0x7e>
  else if ((st & 0xF0)==0xE0 && len>=3){ packet[0]=cable|0x0E; packet[1]=msg[0]; packet[2]=msg[1]; packet[3]=msg[2]; }
 80047ce:	2be0      	cmp	r3, #224	; 0xe0
 80047d0:	d05e      	beq.n	8004890 <send_usb.constprop.0+0xe0>
  else if ((st & 0xF0)==0xC0 && len>=2){ packet[0]=cable|0x0C; packet[1]=msg[0]; packet[2]=msg[1]; packet[3]=0; }
 80047d2:	2bc0      	cmp	r3, #192	; 0xc0
 80047d4:	d06d      	beq.n	80048b2 <send_usb.constprop.0+0x102>
  else if ((st & 0xF0)==0xD0 && len>=2){ packet[0]=cable|0x0D; packet[1]=msg[0]; packet[2]=msg[1]; packet[3]=0; }
 80047d6:	2bd0      	cmp	r3, #208	; 0xd0
 80047d8:	d076      	beq.n	80048c8 <send_usb.constprop.0+0x118>

  /* System Common */
  else if (st==0xF1 && len>=2){ packet[0]=cable|0x02; packet[1]=0xF1; packet[2]=msg[1]; }
 80047da:	2af1      	cmp	r2, #241	; 0xf1
 80047dc:	d15a      	bne.n	8004894 <send_usb.constprop.0+0xe4>
 80047de:	f24f 1202 	movw	r2, #61698	; 0xf102
  else if (st==0xF2 && len>=3){ packet[0]=cable|0x03; packet[1]=0xF2; packet[2]=msg[1]; packet[3]=msg[2]; }
  else if (st==0xF3 && len>=2){ packet[0]=cable|0x02; packet[1]=0xF3; packet[2]=msg[1]; }
 80047e2:	7843      	ldrb	r3, [r0, #1]
 80047e4:	f8ad 2004 	strh.w	r2, [sp, #4]
 80047e8:	f88d 3006 	strb.w	r3, [sp, #6]
 80047ec:	9801      	ldr	r0, [sp, #4]
 80047ee:	ba00      	rev	r0, r0
 80047f0:	e016      	b.n	8004820 <send_usb.constprop.0+0x70>
  else if ((st & 0xF0)==0x90 && len>=3){ packet[0]=cable|0x09; packet[1]=msg[0]; packet[2]=msg[1]; packet[3]=msg[2]; is_note=true; }
 80047f2:	2409      	movs	r4, #9
 80047f4:	7841      	ldrb	r1, [r0, #1]
 80047f6:	7883      	ldrb	r3, [r0, #2]
 80047f8:	f88d 2005 	strb.w	r2, [sp, #5]
 80047fc:	2230      	movs	r2, #48	; 0x30
 80047fe:	f88d 4004 	strb.w	r4, [sp, #4]
 8004802:	f88d 1006 	strb.w	r1, [sp, #6]
  if ((st & 0xF0)==0x80 && len>=3){ packet[0]=cable|0x08; packet[1]=msg[0]; packet[2]=msg[1]; packet[3]=msg[2]; is_note=true; }
 8004806:	f88d 3007 	strb.w	r3, [sp, #7]
 800480a:	f382 8811 	msr	BASEPRI, r2
  ready = usb_midi_tx_ready;
 800480e:	4b69      	ldr	r3, [pc, #420]	; (80049b4 <send_usb.constprop.0+0x204>)
 8004810:	2400      	movs	r4, #0
 8004812:	781b      	ldrb	r3, [r3, #0]
 8004814:	b2db      	uxtb	r3, r3
 8004816:	f384 8811 	msr	BASEPRI, r4
  }

  else { packet[0]=cable|0x0F; packet[1]=len>0?msg[0]:0; packet[2]=len>1?msg[1]:0; packet[3]=len>2?msg[2]:0; }

  if (is_note){
    if (midi_usb_ready() && chBSemWaitTimeout(&tx_sem, TIME_IMMEDIATE)==MSG_OK){
 800481a:	b9b3      	cbnz	r3, 800484a <send_usb.constprop.0+0x9a>
 800481c:	9801      	ldr	r0, [sp, #4]
 800481e:	ba00      	rev	r0, r0
      midi_tx_stats.tx_sent_immediate++; return;
    }
  }

  msg_t m=((msg_t)packet[0]<<24)|((msg_t)packet[1]<<16)|((msg_t)packet[2]<<8)|packet[3];
  post_mb_or_drop(m,false);
 8004820:	2100      	movs	r1, #0
 8004822:	f7ff ff6d 	bl	8004700 <post_mb_or_drop>
}
 8004826:	b003      	add	sp, #12
 8004828:	bd30      	pop	{r4, r5, pc}
  if ((st & 0xF0)==0x80 && len>=3){ packet[0]=cable|0x08; packet[1]=msg[0]; packet[2]=msg[1]; packet[3]=msg[2]; is_note=true; }
 800482a:	2408      	movs	r4, #8
 800482c:	e7e2      	b.n	80047f4 <send_usb.constprop.0+0x44>
  else if ((st & 0xF0)==0xB0 && len>=3){ packet[0]=cable|0x0B; packet[1]=msg[0]; packet[2]=msg[1]; packet[3]=msg[2]; }
 800482e:	240b      	movs	r4, #11
  else { packet[0]=cable|0x0F; packet[1]=len>0?msg[0]:0; packet[2]=len>1?msg[1]:0; packet[3]=len>2?msg[2]:0; }
 8004830:	7841      	ldrb	r1, [r0, #1]
 8004832:	7883      	ldrb	r3, [r0, #2]
 8004834:	f88d 2005 	strb.w	r2, [sp, #5]
 8004838:	f88d 4004 	strb.w	r4, [sp, #4]
 800483c:	f88d 1006 	strb.w	r1, [sp, #6]
 8004840:	f88d 3007 	strb.w	r3, [sp, #7]
 8004844:	9801      	ldr	r0, [sp, #4]
 8004846:	ba00      	rev	r0, r0
 8004848:	e7ea      	b.n	8004820 <send_usb.constprop.0+0x70>
 800484a:	f382 8811 	msr	BASEPRI, r2
  if (--sp->cnt < (cnt_t)0) {
 800484e:	4b5a      	ldr	r3, [pc, #360]	; (80049b8 <send_usb.constprop.0+0x208>)
 8004850:	6898      	ldr	r0, [r3, #8]
 8004852:	1e41      	subs	r1, r0, #1
 8004854:	42a1      	cmp	r1, r4
 8004856:	6099      	str	r1, [r3, #8]
 8004858:	db3d      	blt.n	80048d6 <send_usb.constprop.0+0x126>
 800485a:	f384 8811 	msr	BASEPRI, r4
 800485e:	f382 8811 	msr	BASEPRI, r2
  usbp->transmitting |= (uint16_t)((unsigned)1U << (unsigned)ep);
 8004862:	4856      	ldr	r0, [pc, #344]	; (80049bc <send_usb.constprop.0+0x20c>)
  isp->txsize = n;
 8004864:	2204      	movs	r2, #4
  isp->txbuf  = buf;
 8004866:	ad01      	add	r5, sp, #4
  usb_lld_start_in(usbp, ep);
 8004868:	2102      	movs	r1, #2
  usbp->transmitting |= (uint16_t)((unsigned)1U << (unsigned)ep);
 800486a:	8903      	ldrh	r3, [r0, #8]
 800486c:	4313      	orrs	r3, r2
 800486e:	8103      	strh	r3, [r0, #8]
  isp = usbp->epc[ep]->in_state;
 8004870:	6943      	ldr	r3, [r0, #20]
 8004872:	695b      	ldr	r3, [r3, #20]
  isp->txcnt  = 0;
 8004874:	e883 0034 	stmia.w	r3, {r2, r4, r5}
  usb_lld_start_in(usbp, ep);
 8004878:	f7fb ff8a 	bl	8000790 <usb_lld_start_in>
 800487c:	f384 8811 	msr	BASEPRI, r4
      midi_tx_stats.tx_sent_immediate++; return;
 8004880:	4a4f      	ldr	r2, [pc, #316]	; (80049c0 <send_usb.constprop.0+0x210>)
 8004882:	6813      	ldr	r3, [r2, #0]
 8004884:	3301      	adds	r3, #1
 8004886:	6013      	str	r3, [r2, #0]
}
 8004888:	b003      	add	sp, #12
 800488a:	bd30      	pop	{r4, r5, pc}
  else if ((st & 0xF0)==0xA0 && len>=3){ packet[0]=cable|0x0A; packet[1]=msg[0]; packet[2]=msg[1]; packet[3]=msg[2]; }
 800488c:	240a      	movs	r4, #10
 800488e:	e7cf      	b.n	8004830 <send_usb.constprop.0+0x80>
  else if ((st & 0xF0)==0xE0 && len>=3){ packet[0]=cable|0x0E; packet[1]=msg[0]; packet[2]=msg[1]; packet[3]=msg[2]; }
 8004890:	240e      	movs	r4, #14
 8004892:	e7cd      	b.n	8004830 <send_usb.constprop.0+0x80>
  else if (st==0xF2 && len>=3){ packet[0]=cable|0x03; packet[1]=0xF2; packet[2]=msg[1]; packet[3]=msg[2]; }
 8004894:	2af2      	cmp	r2, #242	; 0xf2
 8004896:	d119      	bne.n	80048cc <send_usb.constprop.0+0x11c>
 8004898:	7842      	ldrb	r2, [r0, #1]
 800489a:	f24f 2103 	movw	r1, #61955	; 0xf203
 800489e:	7883      	ldrb	r3, [r0, #2]
 80048a0:	f8ad 1004 	strh.w	r1, [sp, #4]
 80048a4:	f88d 2006 	strb.w	r2, [sp, #6]
 80048a8:	f88d 3007 	strb.w	r3, [sp, #7]
 80048ac:	9801      	ldr	r0, [sp, #4]
 80048ae:	ba00      	rev	r0, r0
 80048b0:	e7b6      	b.n	8004820 <send_usb.constprop.0+0x70>
  else if ((st & 0xF0)==0xC0 && len>=2){ packet[0]=cable|0x0C; packet[1]=msg[0]; packet[2]=msg[1]; packet[3]=0; }
 80048b2:	210c      	movs	r1, #12
  else if ((st & 0xF0)==0xD0 && len>=2){ packet[0]=cable|0x0D; packet[1]=msg[0]; packet[2]=msg[1]; packet[3]=0; }
 80048b4:	7843      	ldrb	r3, [r0, #1]
 80048b6:	f88d 2005 	strb.w	r2, [sp, #5]
 80048ba:	f88d 1004 	strb.w	r1, [sp, #4]
 80048be:	f88d 3006 	strb.w	r3, [sp, #6]
 80048c2:	9801      	ldr	r0, [sp, #4]
 80048c4:	ba00      	rev	r0, r0
 80048c6:	e7ab      	b.n	8004820 <send_usb.constprop.0+0x70>
 80048c8:	210d      	movs	r1, #13
 80048ca:	e7f3      	b.n	80048b4 <send_usb.constprop.0+0x104>
  else if (st==0xF3 && len>=2){ packet[0]=cable|0x02; packet[1]=0xF3; packet[2]=msg[1]; }
 80048cc:	2af3      	cmp	r2, #243	; 0xf3
 80048ce:	d108      	bne.n	80048e2 <send_usb.constprop.0+0x132>
 80048d0:	f24f 3202 	movw	r2, #62210	; 0xf302
 80048d4:	e785      	b.n	80047e2 <send_usb.constprop.0+0x32>
      sp->cnt++;
 80048d6:	6098      	str	r0, [r3, #8]
 80048d8:	f384 8811 	msr	BASEPRI, r4
 80048dc:	9801      	ldr	r0, [sp, #4]
 80048de:	ba00      	rev	r0, r0
 80048e0:	e79e      	b.n	8004820 <send_usb.constprop.0+0x70>
  else if (st==0xF6){          packet[0]=cable|0x0F; packet[1]=0xF6; }
 80048e2:	2af6      	cmp	r2, #246	; 0xf6
 80048e4:	d017      	beq.n	8004916 <send_usb.constprop.0+0x166>
  else if (st>=0xF8){
 80048e6:	2af7      	cmp	r2, #247	; 0xf7
 80048e8:	d91b      	bls.n	8004922 <send_usb.constprop.0+0x172>
    packet[0]=cable|0x0F; packet[1]=st;
 80048ea:	230f      	movs	r3, #15
    if (st==0xF8){
 80048ec:	2af8      	cmp	r2, #248	; 0xf8
    packet[0]=cable|0x0F; packet[1]=st;
 80048ee:	f88d 2005 	strb.w	r2, [sp, #5]
 80048f2:	f88d 3004 	strb.w	r3, [sp, #4]
    if (st==0xF8){
 80048f6:	d041      	beq.n	800497c <send_usb.constprop.0+0x1cc>
    if (st==0xFA || st==0xFB || st==0xFC || st==0xFE || st==0xFF){
 80048f8:	1d93      	adds	r3, r2, #6
 80048fa:	b2db      	uxtb	r3, r3
 80048fc:	2b02      	cmp	r3, #2
 80048fe:	d912      	bls.n	8004926 <send_usb.constprop.0+0x176>
 8004900:	2afd      	cmp	r2, #253	; 0xfd
 8004902:	bf94      	ite	ls
 8004904:	2100      	movls	r1, #0
 8004906:	2101      	movhi	r1, #1
 8004908:	b969      	cbnz	r1, 8004926 <send_usb.constprop.0+0x176>
    msg_t m3=((msg_t)packet[0]<<24)|((msg_t)packet[1]<<16)|((msg_t)packet[2]<<8)|packet[3];
 800490a:	0412      	lsls	r2, r2, #16
    post_mb_or_drop(m3,false);
 800490c:	f042 6070 	orr.w	r0, r2, #251658240	; 0xf000000
 8004910:	f7ff fef6 	bl	8004700 <post_mb_or_drop>
    return;
 8004914:	e787      	b.n	8004826 <send_usb.constprop.0+0x76>
  else if (st==0xF6){          packet[0]=cable|0x0F; packet[1]=0xF6; }
 8004916:	f24f 630f 	movw	r3, #62991	; 0xf60f
 800491a:	482a      	ldr	r0, [pc, #168]	; (80049c4 <send_usb.constprop.0+0x214>)
 800491c:	f8ad 3004 	strh.w	r3, [sp, #4]
 8004920:	e77e      	b.n	8004820 <send_usb.constprop.0+0x70>
  else { packet[0]=cable|0x0F; packet[1]=len>0?msg[0]:0; packet[2]=len>1?msg[1]:0; packet[3]=len>2?msg[2]:0; }
 8004922:	240f      	movs	r4, #15
 8004924:	e784      	b.n	8004830 <send_usb.constprop.0+0x80>
 8004926:	2130      	movs	r1, #48	; 0x30
 8004928:	f381 8811 	msr	BASEPRI, r1
  ready = usb_midi_tx_ready;
 800492c:	4a21      	ldr	r2, [pc, #132]	; (80049b4 <send_usb.constprop.0+0x204>)
 800492e:	2300      	movs	r3, #0
 8004930:	7812      	ldrb	r2, [r2, #0]
 8004932:	b2d2      	uxtb	r2, r2
 8004934:	f383 8811 	msr	BASEPRI, r3
      if (midi_usb_ready() && chBSemWaitTimeout(&tx_sem, TIME_IMMEDIATE)==MSG_OK){
 8004938:	b1b2      	cbz	r2, 8004968 <send_usb.constprop.0+0x1b8>
 800493a:	f381 8811 	msr	BASEPRI, r1
  if (--sp->cnt < (cnt_t)0) {
 800493e:	4a1e      	ldr	r2, [pc, #120]	; (80049b8 <send_usb.constprop.0+0x208>)
 8004940:	6891      	ldr	r1, [r2, #8]
 8004942:	1e48      	subs	r0, r1, #1
 8004944:	4298      	cmp	r0, r3
 8004946:	6090      	str	r0, [r2, #8]
 8004948:	db0b      	blt.n	8004962 <send_usb.constprop.0+0x1b2>
 800494a:	f383 8811 	msr	BASEPRI, r3
        midi_usb_start_tx(packet, 4);
 800494e:	2104      	movs	r1, #4
 8004950:	eb0d 0001 	add.w	r0, sp, r1
 8004954:	f7fc f8f4 	bl	8000b40 <midi_usb_start_tx>
        midi_tx_stats.tx_sent_immediate++;
 8004958:	4a19      	ldr	r2, [pc, #100]	; (80049c0 <send_usb.constprop.0+0x210>)
 800495a:	6813      	ldr	r3, [r2, #0]
 800495c:	3301      	adds	r3, #1
 800495e:	6013      	str	r3, [r2, #0]
 8004960:	e761      	b.n	8004826 <send_usb.constprop.0+0x76>
      sp->cnt++;
 8004962:	6091      	str	r1, [r2, #8]
 8004964:	f383 8811 	msr	BASEPRI, r3
        midi_tx_stats.rt_other_enq_fallback++;
 8004968:	4a15      	ldr	r2, [pc, #84]	; (80049c0 <send_usb.constprop.0+0x210>)
        post_mb_or_drop(m,true);
 800496a:	2101      	movs	r1, #1
 800496c:	9801      	ldr	r0, [sp, #4]
        midi_tx_stats.rt_other_enq_fallback++;
 800496e:	6913      	ldr	r3, [r2, #16]
        post_mb_or_drop(m,true);
 8004970:	ba00      	rev	r0, r0
        midi_tx_stats.rt_other_enq_fallback++;
 8004972:	440b      	add	r3, r1
 8004974:	6113      	str	r3, [r2, #16]
        post_mb_or_drop(m,true);
 8004976:	f7ff fec3 	bl	8004700 <post_mb_or_drop>
 800497a:	e754      	b.n	8004826 <send_usb.constprop.0+0x76>
 800497c:	2130      	movs	r1, #48	; 0x30
 800497e:	f381 8811 	msr	BASEPRI, r1
  ready = usb_midi_tx_ready;
 8004982:	4a0c      	ldr	r2, [pc, #48]	; (80049b4 <send_usb.constprop.0+0x204>)
 8004984:	2300      	movs	r3, #0
 8004986:	7812      	ldrb	r2, [r2, #0]
 8004988:	b2d2      	uxtb	r2, r2
 800498a:	f383 8811 	msr	BASEPRI, r3
      if (midi_usb_ready() && chBSemWaitTimeout(&tx_sem, TIME_IMMEDIATE)==MSG_OK){
 800498e:	b152      	cbz	r2, 80049a6 <send_usb.constprop.0+0x1f6>
 8004990:	f381 8811 	msr	BASEPRI, r1
  if (--sp->cnt < (cnt_t)0) {
 8004994:	4a08      	ldr	r2, [pc, #32]	; (80049b8 <send_usb.constprop.0+0x208>)
 8004996:	6891      	ldr	r1, [r2, #8]
 8004998:	1e48      	subs	r0, r1, #1
 800499a:	4298      	cmp	r0, r3
 800499c:	6090      	str	r0, [r2, #8]
 800499e:	dad4      	bge.n	800494a <send_usb.constprop.0+0x19a>
      sp->cnt++;
 80049a0:	6091      	str	r1, [r2, #8]
 80049a2:	f383 8811 	msr	BASEPRI, r3
 80049a6:	9801      	ldr	r0, [sp, #4]
        post_mb_or_drop(m,false);
 80049a8:	2100      	movs	r1, #0
 80049aa:	ba00      	rev	r0, r0
 80049ac:	f7ff fea8 	bl	8004700 <post_mb_or_drop>
 80049b0:	e739      	b.n	8004826 <send_usb.constprop.0+0x76>
 80049b2:	bf00      	nop
 80049b4:	2400153c 	.word	0x2400153c
 80049b8:	2400152c 	.word	0x2400152c
 80049bc:	2400024c 	.word	0x2400024c
 80049c0:	24000e38 	.word	0x24000e38
 80049c4:	0ff60000 	.word	0x0ff60000
	...

080049d0 <thdMidiUsbTx>:
  size_t n = 0;
 80049d0:	f04f 0900 	mov.w	r9, #0
 * @api
 */
static inline void chRegSetThreadName(const char *name) {

#if CH_CFG_USE_REGISTRY == TRUE
  __sch_get_currthread()->name = name;
 80049d4:	4ba6      	ldr	r3, [pc, #664]	; (8004c70 <thdMidiUsbTx+0x2a0>)
 80049d6:	4aa7      	ldr	r2, [pc, #668]	; (8004c74 <thdMidiUsbTx+0x2a4>)
 80049d8:	68db      	ldr	r3, [r3, #12]
  rdymsg = chMBFetchTimeoutS(mbp, msgp, timeout);
 80049da:	464d      	mov	r5, r9
 80049dc:	4ea6      	ldr	r6, [pc, #664]	; (8004c78 <thdMidiUsbTx+0x2a8>)
 80049de:	f8df 829c 	ldr.w	r8, [pc, #668]	; 8004c7c <thdMidiUsbTx+0x2ac>
static void send_uart(const uint8_t *msg, size_t len) { sdWrite(MIDI_UART, msg, len); }
 80049e2:	f8df a29c 	ldr.w	sl, [pc, #668]	; 8004c80 <thdMidiUsbTx+0x2b0>
static THD_FUNCTION(thdMidiUsbTx, arg) {
 80049e6:	e92d 4880 	stmdb	sp!, {r7, fp, lr}
 80049ea:	4fa6      	ldr	r7, [pc, #664]	; (8004c84 <thdMidiUsbTx+0x2b4>)
 80049ec:	b093      	sub	sp, #76	; 0x4c
 80049ee:	61da      	str	r2, [r3, #28]
      out->data[2] = pkt[3];
 80049f0:	2410      	movs	r4, #16
 80049f2:	e00d      	b.n	8004a10 <thdMidiUsbTx+0x40>
  switch (cin) {
 80049f4:	f243 0304 	movw	r3, #12292	; 0x3004
 80049f8:	4219      	tst	r1, r3
 80049fa:	f040 80a2 	bne.w	8004b42 <thdMidiUsbTx+0x172>
 80049fe:	280f      	cmp	r0, #15
 8004a00:	f000 80a7 	beq.w	8004b52 <thdMidiUsbTx+0x182>
      midi_rx_stats.usb_rx_ignored++;
 8004a04:	68f3      	ldr	r3, [r6, #12]
  while ((processed < max_burst) &&
 8004a06:	3c01      	subs	r4, #1
      midi_rx_stats.usb_rx_ignored++;
 8004a08:	f103 0301 	add.w	r3, r3, #1
 8004a0c:	60f3      	str	r3, [r6, #12]
  while ((processed < max_burst) &&
 8004a0e:	d037      	beq.n	8004a80 <thdMidiUsbTx+0xb0>
 8004a10:	f04f 0b30 	mov.w	fp, #48	; 0x30
 8004a14:	f38b 8811 	msr	BASEPRI, fp
 8004a18:	2200      	movs	r2, #0
 8004a1a:	4669      	mov	r1, sp
 8004a1c:	4640      	mov	r0, r8
 8004a1e:	f7ff fe27 	bl	8004670 <chMBFetchTimeoutS>
 8004a22:	f385 8811 	msr	BASEPRI, r5
 8004a26:	bb58      	cbnz	r0, 8004a80 <thdMidiUsbTx+0xb0>
 8004a28:	f38b 8811 	msr	BASEPRI, fp
  if (midi_usb_rx_queue_fill > 0U) {
 8004a2c:	883b      	ldrh	r3, [r7, #0]
 8004a2e:	b10b      	cbz	r3, 8004a34 <thdMidiUsbTx+0x64>
    midi_usb_rx_queue_fill--;
 8004a30:	3b01      	subs	r3, #1
 8004a32:	803b      	strh	r3, [r7, #0]
 8004a34:	f385 8811 	msr	BASEPRI, r5
    pkt[0] = (uint8_t)((raw >> 24) & 0xFF);
 8004a38:	9b00      	ldr	r3, [sp, #0]
    pkt[1] = (uint8_t)((raw >> 16) & 0xFF);
 8004a3a:	2201      	movs	r2, #1
  switch (cin) {
 8004a3c:	f644 7c08 	movw	ip, #20232	; 0x4f08
  const uint8_t cin = (uint8_t)(pkt[0] & 0x0F);
 8004a40:	f3c3 6003 	ubfx	r0, r3, #24, #4
    pkt[1] = (uint8_t)((raw >> 16) & 0xFF);
 8004a44:	f3c3 4e07 	ubfx	lr, r3, #16, #8
    pkt[2] = (uint8_t)((raw >> 8)  & 0xFF);
 8004a48:	f3c3 2b07 	ubfx	fp, r3, #8, #8
  switch (cin) {
 8004a4c:	fa02 f100 	lsl.w	r1, r2, r0
 8004a50:	ea11 0f0c 	tst.w	r1, ip
 8004a54:	d0ce      	beq.n	80049f4 <thdMidiUsbTx+0x24>
      out->len = 3U;
 8004a56:	2203      	movs	r2, #3
      out->data[0] = pkt[1];
 8004a58:	f88d e004 	strb.w	lr, [sp, #4]
      out->data[1] = pkt[2];
 8004a5c:	f88d b005 	strb.w	fp, [sp, #5]
    pkt[3] = (uint8_t)( raw        & 0xFF);
 8004a60:	f88d 3006 	strb.w	r3, [sp, #6]
      out->len = 3U;
 8004a64:	f88d 2007 	strb.w	r2, [sp, #7]
static void send_uart(const uint8_t *msg, size_t len) { sdWrite(MIDI_UART, msg, len); }
 8004a68:	f04f 33ff 	mov.w	r3, #4294967295
 8004a6c:	a901      	add	r1, sp, #4
 8004a6e:	4650      	mov	r0, sl
 8004a70:	f7fc ffe6 	bl	8001a40 <oqWriteTimeout>
      midi_rx_stats.usb_rx_decoded++;
 8004a74:	68b3      	ldr	r3, [r6, #8]
  while ((processed < max_burst) &&
 8004a76:	3c01      	subs	r4, #1
      midi_rx_stats.usb_rx_decoded++;
 8004a78:	f103 0301 	add.w	r3, r3, #1
 8004a7c:	60b3      	str	r3, [r6, #8]
  while ((processed < max_burst) &&
 8004a7e:	d1c7      	bne.n	8004a10 <thdMidiUsbTx+0x40>
 8004a80:	2430      	movs	r4, #48	; 0x30
 8004a82:	f384 8811 	msr	BASEPRI, r4
 8004a86:	220a      	movs	r2, #10
 8004a88:	a901      	add	r1, sp, #4
 8004a8a:	487f      	ldr	r0, [pc, #508]	; (8004c88 <thdMidiUsbTx+0x2b8>)
 8004a8c:	f7ff fdf0 	bl	8004670 <chMBFetchTimeoutS>
 8004a90:	f385 8811 	msr	BASEPRI, r5
    if (res == MSG_OK) {
 8004a94:	2800      	cmp	r0, #0
 8004a96:	d16d      	bne.n	8004b74 <thdMidiUsbTx+0x1a4>
 8004a98:	f384 8811 	msr	BASEPRI, r4
  if (midi_usb_queue_fill > 0U) {
 8004a9c:	4a7b      	ldr	r2, [pc, #492]	; (8004c8c <thdMidiUsbTx+0x2bc>)
 8004a9e:	8813      	ldrh	r3, [r2, #0]
 8004aa0:	b10b      	cbz	r3, 8004aa6 <thdMidiUsbTx+0xd6>
    midi_usb_queue_fill--;
 8004aa2:	3b01      	subs	r3, #1
 8004aa4:	8013      	strh	r3, [r2, #0]
 8004aa6:	f385 8811 	msr	BASEPRI, r5
      buf[n++] = (uint8_t)((msg >> 24) & 0xFF);
 8004aaa:	9b01      	ldr	r3, [sp, #4]
 8004aac:	f109 0148 	add.w	r1, r9, #72	; 0x48
      buf[n++] = (uint8_t)( msg        & 0xFF);
 8004ab0:	f109 024b 	add.w	r2, r9, #75	; 0x4b
 8004ab4:	f109 0904 	add.w	r9, r9, #4
      buf[n++] = (uint8_t)((msg >> 24) & 0xFF);
 8004ab8:	4469      	add	r1, sp
 8004aba:	1618      	asrs	r0, r3, #24
      buf[n++] = (uint8_t)( msg        & 0xFF);
 8004abc:	446a      	add	r2, sp
      if (n == sizeof(buf)) {
 8004abe:	f1b9 0f40 	cmp.w	r9, #64	; 0x40
      buf[n++] = (uint8_t)((msg >> 24) & 0xFF);
 8004ac2:	f801 0c40 	strb.w	r0, [r1, #-64]
      buf[n++] = (uint8_t)((msg >> 16) & 0xFF);
 8004ac6:	ea4f 4023 	mov.w	r0, r3, asr #16
 8004aca:	f801 0c3f 	strb.w	r0, [r1, #-63]
      buf[n++] = (uint8_t)((msg >> 8)  & 0xFF);
 8004ace:	ea4f 2023 	mov.w	r0, r3, asr #8
 8004ad2:	f801 0c3e 	strb.w	r0, [r1, #-62]
      buf[n++] = (uint8_t)( msg        & 0xFF);
 8004ad6:	f802 3c40 	strb.w	r3, [r2, #-64]
      if (n == sizeof(buf)) {
 8004ada:	d189      	bne.n	80049f0 <thdMidiUsbTx+0x20>
 8004adc:	2230      	movs	r2, #48	; 0x30
 8004ade:	f382 8811 	msr	BASEPRI, r2
  ready = usb_midi_tx_ready;
 8004ae2:	4b6b      	ldr	r3, [pc, #428]	; (8004c90 <thdMidiUsbTx+0x2c0>)
 8004ae4:	f893 9000 	ldrb.w	r9, [r3]
 8004ae8:	fa5f f389 	uxtb.w	r3, r9
 8004aec:	f385 8811 	msr	BASEPRI, r5
        if (ready) {
 8004af0:	2b00      	cmp	r3, #0
 8004af2:	d06a      	beq.n	8004bca <thdMidiUsbTx+0x1fa>
 8004af4:	f382 8811 	msr	BASEPRI, r2
  if (--sp->cnt < (cnt_t)0) {
 8004af8:	4a66      	ldr	r2, [pc, #408]	; (8004c94 <thdMidiUsbTx+0x2c4>)
 8004afa:	6893      	ldr	r3, [r2, #8]
 8004afc:	3b01      	subs	r3, #1
 8004afe:	2b00      	cmp	r3, #0
 8004b00:	6093      	str	r3, [r2, #8]
 8004b02:	f2c0 8082 	blt.w	8004c0a <thdMidiUsbTx+0x23a>
 8004b06:	f385 8811 	msr	BASEPRI, r5
 8004b0a:	2330      	movs	r3, #48	; 0x30
 8004b0c:	f383 8811 	msr	BASEPRI, r3
  usbp->transmitting |= (uint16_t)((unsigned)1U << (unsigned)ep);
 8004b10:	4a61      	ldr	r2, [pc, #388]	; (8004c98 <thdMidiUsbTx+0x2c8>)
 8004b12:	8913      	ldrh	r3, [r2, #8]
 8004b14:	f043 0304 	orr.w	r3, r3, #4
 8004b18:	8113      	strh	r3, [r2, #8]
  isp = usbp->epc[ep]->in_state;
 8004b1a:	6953      	ldr	r3, [r2, #20]
  isp->txbuf  = buf;
 8004b1c:	aa02      	add	r2, sp, #8
  isp = usbp->epc[ep]->in_state;
 8004b1e:	695b      	ldr	r3, [r3, #20]
  isp->txcnt  = 0;
 8004b20:	e9c3 5201 	strd	r5, r2, [r3, #4]
  isp->txsize = n;
 8004b24:	2240      	movs	r2, #64	; 0x40
 8004b26:	601a      	str	r2, [r3, #0]
  usb_lld_start_in(usbp, ep);
 8004b28:	2102      	movs	r1, #2
 8004b2a:	485b      	ldr	r0, [pc, #364]	; (8004c98 <thdMidiUsbTx+0x2c8>)
 8004b2c:	f7fb fe30 	bl	8000790 <usb_lld_start_in>
 8004b30:	f385 8811 	msr	BASEPRI, r5
          midi_tx_stats.tx_sent_batched++;
 8004b34:	4a59      	ldr	r2, [pc, #356]	; (8004c9c <thdMidiUsbTx+0x2cc>)
      n = 0;
 8004b36:	f04f 0900 	mov.w	r9, #0
          midi_tx_stats.tx_sent_batched++;
 8004b3a:	6853      	ldr	r3, [r2, #4]
 8004b3c:	3301      	adds	r3, #1
 8004b3e:	6053      	str	r3, [r2, #4]
 8004b40:	e756      	b.n	80049f0 <thdMidiUsbTx+0x20>
      out->len = 2U;
 8004b42:	2202      	movs	r2, #2
      out->data[0] = pkt[1];
 8004b44:	f88d e004 	strb.w	lr, [sp, #4]
      out->data[1] = pkt[2];
 8004b48:	f88d b005 	strb.w	fp, [sp, #5]
      out->len = 2U;
 8004b4c:	f88d 2007 	strb.w	r2, [sp, #7]
      return true;
 8004b50:	e78a      	b.n	8004a68 <thdMidiUsbTx+0x98>
      switch (pkt[1]) {
 8004b52:	f10e 0308 	add.w	r3, lr, #8
 8004b56:	b2db      	uxtb	r3, r3
 8004b58:	2b07      	cmp	r3, #7
 8004b5a:	f63f af53 	bhi.w	8004a04 <thdMidiUsbTx+0x34>
 8004b5e:	21dd      	movs	r1, #221	; 0xdd
 8004b60:	fa21 f303 	lsr.w	r3, r1, r3
 8004b64:	07db      	lsls	r3, r3, #31
 8004b66:	f57f af4d 	bpl.w	8004a04 <thdMidiUsbTx+0x34>
          out->data[0] = pkt[1];
 8004b6a:	f88d e004 	strb.w	lr, [sp, #4]
          out->len = 1U;
 8004b6e:	f88d 2007 	strb.w	r2, [sp, #7]
          return true;
 8004b72:	e779      	b.n	8004a68 <thdMidiUsbTx+0x98>
    } else if (n > 0U) {
 8004b74:	f1b9 0f00 	cmp.w	r9, #0
 8004b78:	f43f af3a 	beq.w	80049f0 <thdMidiUsbTx+0x20>
 8004b7c:	f384 8811 	msr	BASEPRI, r4
 8004b80:	4a47      	ldr	r2, [pc, #284]	; (8004ca0 <thdMidiUsbTx+0x2d0>)
 8004b82:	6893      	ldr	r3, [r2, #8]
 8004b84:	3b01      	subs	r3, #1
 8004b86:	2b00      	cmp	r3, #0
 8004b88:	6093      	str	r3, [r2, #8]
 8004b8a:	da0c      	bge.n	8004ba6 <thdMidiUsbTx+0x1d6>
 8004b8c:	4b38      	ldr	r3, [pc, #224]	; (8004c70 <thdMidiUsbTx+0x2a0>)
    currtp->u.wtsemp = sp;
 8004b8e:	4611      	mov	r1, r2
    return chSchGoSleepTimeoutS(CH_STATE_WTSEM, timeout);
 8004b90:	2005      	movs	r0, #5
 8004b92:	68db      	ldr	r3, [r3, #12]
  p->next       = qp;
 8004b94:	601a      	str	r2, [r3, #0]
    currtp->u.wtsemp = sp;
 8004b96:	629a      	str	r2, [r3, #40]	; 0x28
  p->prev       = qp->prev;
 8004b98:	6852      	ldr	r2, [r2, #4]
 8004b9a:	605a      	str	r2, [r3, #4]
  p->prev->next = p;
 8004b9c:	6013      	str	r3, [r2, #0]
  qp->prev      = p;
 8004b9e:	604b      	str	r3, [r1, #4]
    return chSchGoSleepTimeoutS(CH_STATE_WTSEM, timeout);
 8004ba0:	210a      	movs	r1, #10
 8004ba2:	f7fc fe9d 	bl	80018e0 <chSchGoSleepTimeoutS>
 8004ba6:	f385 8811 	msr	BASEPRI, r5
 8004baa:	2230      	movs	r2, #48	; 0x30
 8004bac:	f382 8811 	msr	BASEPRI, r2
  ready = usb_midi_tx_ready;
 8004bb0:	4b37      	ldr	r3, [pc, #220]	; (8004c90 <thdMidiUsbTx+0x2c0>)
 8004bb2:	781b      	ldrb	r3, [r3, #0]
 8004bb4:	b2db      	uxtb	r3, r3
 8004bb6:	f385 8811 	msr	BASEPRI, r5
      if (ready) {
 8004bba:	b963      	cbnz	r3, 8004bd6 <thdMidiUsbTx+0x206>
        midi_tx_stats.usb_not_ready_drops += n / 4;
 8004bbc:	4937      	ldr	r1, [pc, #220]	; (8004c9c <thdMidiUsbTx+0x2cc>)
 8004bbe:	698a      	ldr	r2, [r1, #24]
 8004bc0:	eb02 0299 	add.w	r2, r2, r9, lsr #2
      n = 0;
 8004bc4:	4699      	mov	r9, r3
        midi_tx_stats.usb_not_ready_drops += n / 4;
 8004bc6:	618a      	str	r2, [r1, #24]
  while (true) {
 8004bc8:	e712      	b.n	80049f0 <thdMidiUsbTx+0x20>
          midi_tx_stats.usb_not_ready_drops += n / 4;
 8004bca:	4a34      	ldr	r2, [pc, #208]	; (8004c9c <thdMidiUsbTx+0x2cc>)
        n = 0;
 8004bcc:	4699      	mov	r9, r3
          midi_tx_stats.usb_not_ready_drops += n / 4;
 8004bce:	6993      	ldr	r3, [r2, #24]
 8004bd0:	3310      	adds	r3, #16
 8004bd2:	6193      	str	r3, [r2, #24]
 8004bd4:	e70c      	b.n	80049f0 <thdMidiUsbTx+0x20>
 8004bd6:	f382 8811 	msr	BASEPRI, r2
  if (--sp->cnt < (cnt_t)0) {
 8004bda:	4a2e      	ldr	r2, [pc, #184]	; (8004c94 <thdMidiUsbTx+0x2c4>)
 8004bdc:	6893      	ldr	r3, [r2, #8]
 8004bde:	3b01      	subs	r3, #1
 8004be0:	2b00      	cmp	r3, #0
 8004be2:	6093      	str	r3, [r2, #8]
 8004be4:	db2a      	blt.n	8004c3c <thdMidiUsbTx+0x26c>
 8004be6:	f385 8811 	msr	BASEPRI, r5
 8004bea:	2330      	movs	r3, #48	; 0x30
 8004bec:	f383 8811 	msr	BASEPRI, r3
  usbp->transmitting |= (uint16_t)((unsigned)1U << (unsigned)ep);
 8004bf0:	4a29      	ldr	r2, [pc, #164]	; (8004c98 <thdMidiUsbTx+0x2c8>)
 8004bf2:	8913      	ldrh	r3, [r2, #8]
 8004bf4:	f043 0304 	orr.w	r3, r3, #4
 8004bf8:	8113      	strh	r3, [r2, #8]
  isp = usbp->epc[ep]->in_state;
 8004bfa:	6953      	ldr	r3, [r2, #20]
  isp->txbuf  = buf;
 8004bfc:	aa02      	add	r2, sp, #8
  isp = usbp->epc[ep]->in_state;
 8004bfe:	695b      	ldr	r3, [r3, #20]
  isp->txsize = n;
 8004c00:	f8c3 9000 	str.w	r9, [r3]
  isp->txcnt  = 0;
 8004c04:	e9c3 5201 	strd	r5, r2, [r3, #4]
 8004c08:	e78e      	b.n	8004b28 <thdMidiUsbTx+0x158>
  p->next       = qp;
 8004c0a:	4922      	ldr	r1, [pc, #136]	; (8004c94 <thdMidiUsbTx+0x2c4>)
    return chSchGoSleepTimeoutS(CH_STATE_WTSEM, timeout);
 8004c0c:	2005      	movs	r0, #5
 8004c0e:	4b18      	ldr	r3, [pc, #96]	; (8004c70 <thdMidiUsbTx+0x2a0>)
  p->prev       = qp->prev;
 8004c10:	684a      	ldr	r2, [r1, #4]
 8004c12:	68db      	ldr	r3, [r3, #12]
  p->next       = qp;
 8004c14:	6019      	str	r1, [r3, #0]
    currtp->u.wtsemp = sp;
 8004c16:	6299      	str	r1, [r3, #40]	; 0x28
  p->prev       = qp->prev;
 8004c18:	605a      	str	r2, [r3, #4]
  p->prev->next = p;
 8004c1a:	6013      	str	r3, [r2, #0]
  qp->prev      = p;
 8004c1c:	604b      	str	r3, [r1, #4]
    return chSchGoSleepTimeoutS(CH_STATE_WTSEM, timeout);
 8004c1e:	2114      	movs	r1, #20
 8004c20:	f7fc fe5e 	bl	80018e0 <chSchGoSleepTimeoutS>
 8004c24:	f385 8811 	msr	BASEPRI, r5
          if (chBSemWaitTimeout(&tx_sem, tw) == MSG_OK) {
 8004c28:	2800      	cmp	r0, #0
 8004c2a:	f43f af6e 	beq.w	8004b0a <thdMidiUsbTx+0x13a>
            midi_tx_stats.usb_not_ready_drops += n / 4;
 8004c2e:	4a1b      	ldr	r2, [pc, #108]	; (8004c9c <thdMidiUsbTx+0x2cc>)
        n = 0;
 8004c30:	f04f 0900 	mov.w	r9, #0
            midi_tx_stats.usb_not_ready_drops += n / 4;
 8004c34:	6993      	ldr	r3, [r2, #24]
 8004c36:	3310      	adds	r3, #16
 8004c38:	6193      	str	r3, [r2, #24]
 8004c3a:	e6d9      	b.n	80049f0 <thdMidiUsbTx+0x20>
  p->next       = qp;
 8004c3c:	4915      	ldr	r1, [pc, #84]	; (8004c94 <thdMidiUsbTx+0x2c4>)
 8004c3e:	2005      	movs	r0, #5
 8004c40:	4b0b      	ldr	r3, [pc, #44]	; (8004c70 <thdMidiUsbTx+0x2a0>)
  p->prev       = qp->prev;
 8004c42:	684a      	ldr	r2, [r1, #4]
 8004c44:	68db      	ldr	r3, [r3, #12]
  p->next       = qp;
 8004c46:	6019      	str	r1, [r3, #0]
    currtp->u.wtsemp = sp;
 8004c48:	6299      	str	r1, [r3, #40]	; 0x28
  p->prev       = qp->prev;
 8004c4a:	605a      	str	r2, [r3, #4]
  p->prev->next = p;
 8004c4c:	6013      	str	r3, [r2, #0]
  qp->prev      = p;
 8004c4e:	604b      	str	r3, [r1, #4]
    return chSchGoSleepTimeoutS(CH_STATE_WTSEM, timeout);
 8004c50:	2114      	movs	r1, #20
 8004c52:	f7fc fe45 	bl	80018e0 <chSchGoSleepTimeoutS>
 8004c56:	f385 8811 	msr	BASEPRI, r5
        if (chBSemWaitTimeout(&tx_sem, tw) == MSG_OK) {
 8004c5a:	2800      	cmp	r0, #0
 8004c5c:	d0c5      	beq.n	8004bea <thdMidiUsbTx+0x21a>
          midi_tx_stats.usb_not_ready_drops += n / 4;
 8004c5e:	4a0f      	ldr	r2, [pc, #60]	; (8004c9c <thdMidiUsbTx+0x2cc>)
 8004c60:	6993      	ldr	r3, [r2, #24]
 8004c62:	eb03 0399 	add.w	r3, r3, r9, lsr #2
      n = 0;
 8004c66:	f04f 0900 	mov.w	r9, #0
          midi_tx_stats.usb_not_ready_drops += n / 4;
 8004c6a:	6193      	str	r3, [r2, #24]
 8004c6c:	e6c0      	b.n	80049f0 <thdMidiUsbTx+0x20>
 8004c6e:	bf00      	nop
 8004c70:	24000330 	.word	0x24000330
 8004c74:	08005988 	.word	0x08005988
 8004c78:	24000e28 	.word	0x24000e28
 8004c7c:	24001284 	.word	0x24001284
 8004c80:	240000a0 	.word	0x240000a0
 8004c84:	240014ac 	.word	0x240014ac
 8004c88:	24000e54 	.word	0x24000e54
 8004c8c:	2400127c 	.word	0x2400127c
 8004c90:	2400153c 	.word	0x2400153c
 8004c94:	2400152c 	.word	0x2400152c
 8004c98:	2400024c 	.word	0x2400024c
 8004c9c:	24000e38 	.word	0x24000e38
 8004ca0:	24001520 	.word	0x24001520
	...

08004cb0 <chThdExit>:
void chThdExit(msg_t msg) {
 8004cb0:	b538      	push	{r3, r4, r5, lr}
 8004cb2:	2330      	movs	r3, #48	; 0x30
 8004cb4:	f383 8811 	msr	BASEPRI, r3
 8004cb8:	4b12      	ldr	r3, [pc, #72]	; (8004d04 <chThdExit+0x54>)
 8004cba:	68dc      	ldr	r4, [r3, #12]
  while (unlikely(ch_list_notempty(&currtp->waiting))) {
 8004cbc:	f104 052c 	add.w	r5, r4, #44	; 0x2c
  return (bool)(lp->next != lp);
 8004cc0:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
  currtp->u.exitcode = msg;
 8004cc2:	62a0      	str	r0, [r4, #40]	; 0x28
  while (unlikely(ch_list_notempty(&currtp->waiting))) {
 8004cc4:	429d      	cmp	r5, r3
 8004cc6:	d107      	bne.n	8004cd8 <chThdExit+0x28>
  if (unlikely(currtp->refs == (trefs_t)0)) {
 8004cc8:	f894 3026 	ldrb.w	r3, [r4, #38]	; 0x26
 8004ccc:	b183      	cbz	r3, 8004cf0 <chThdExit+0x40>
  chSchGoSleepS(CH_STATE_FINAL);
 8004cce:	200f      	movs	r0, #15
}
 8004cd0:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  chSchGoSleepS(CH_STATE_FINAL);
 8004cd4:	f7fc bdd4 	b.w	8001880 <chSchGoSleepS>
  lp->next = p->next;
 8004cd8:	681a      	ldr	r2, [r3, #0]
  return __sch_ready_behind(tp);
 8004cda:	4618      	mov	r0, r3
 8004cdc:	62e2      	str	r2, [r4, #44]	; 0x2c
 8004cde:	f7fc f8bf 	bl	8000e60 <__sch_ready_behind.isra.0>
  return (bool)(lp->next != lp);
 8004ce2:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
  while (unlikely(ch_list_notempty(&currtp->waiting))) {
 8004ce4:	42ab      	cmp	r3, r5
 8004ce6:	d1f7      	bne.n	8004cd8 <chThdExit+0x28>
  if (unlikely(currtp->refs == (trefs_t)0)) {
 8004ce8:	f894 3026 	ldrb.w	r3, [r4, #38]	; 0x26
 8004cec:	2b00      	cmp	r3, #0
 8004cee:	d1ee      	bne.n	8004cce <chThdExit+0x1e>
    if (unlikely(((currtp->flags & CH_FLAG_MODE_MASK) == CH_FLAG_MODE_STATIC))) {
 8004cf0:	f894 3025 	ldrb.w	r3, [r4, #37]	; 0x25
 8004cf4:	079b      	lsls	r3, r3, #30
 8004cf6:	d1ea      	bne.n	8004cce <chThdExit+0x1e>
  p->prev->next = p->next;
 8004cf8:	e9d4 3204 	ldrd	r3, r2, [r4, #16]
 8004cfc:	6013      	str	r3, [r2, #0]
  p->next->prev = p->prev;
 8004cfe:	605a      	str	r2, [r3, #4]
  return p;
 8004d00:	e7e5      	b.n	8004cce <chThdExit+0x1e>
 8004d02:	bf00      	nop
 8004d04:	24000330 	.word	0x24000330
	...

08004d10 <SVC_Handler>:
  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 8004d10:	f3ef 8309 	mrs	r3, PSP
    psp += sizeof (struct port_extctx);
 8004d14:	3320      	adds	r3, #32
  __ASM volatile ("MSR psp, %0" : : "r" (topOfProcStack) : );
 8004d16:	f383 8809 	msr	PSP, r3
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8004d1a:	2300      	movs	r3, #0
 8004d1c:	f383 8811 	msr	BASEPRI, r3
}
 8004d20:	4770      	bx	lr
 8004d22:	bf00      	nop
	...

08004d30 <main>:
  RCC->AHB1RSTR |= mask;
 8004d30:	4b3f      	ldr	r3, [pc, #252]	; (8004e30 <main+0x100>)
  RCC->AHB1RSTR &= ~mask;
 8004d32:	2200      	movs	r2, #0
  RCC->AHB1RSTR |= mask;
 8004d34:	f04f 30ff 	mov.w	r0, #4294967295
  RCC->AHB3RSTR |= mask;
 8004d38:	4c3e      	ldr	r4, [pc, #248]	; (8004e34 <main+0x104>)
  RCC->AHB1RSTR |= mask;
 8004d3a:	f8d3 1080 	ldr.w	r1, [r3, #128]	; 0x80
  RCC->AHB3RSTR &= ~mask;
 8004d3e:	4d3e      	ldr	r5, [pc, #248]	; (8004e38 <main+0x108>)
#define MIDI_CH     0U
#define NOTE_C4     60U
#define NOTE_VEL    100U
#define NOTE_OFFVEL 0U

int main(void) {
 8004d40:	e92d 4880 	stmdb	sp!, {r7, fp, lr}
  RCC->AHB1RSTR |= mask;
 8004d44:	f8c3 0080 	str.w	r0, [r3, #128]	; 0x80
 8004d48:	b089      	sub	sp, #36	; 0x24
  RCC->AHB1RSTR &= ~mask;
 8004d4a:	f8d3 1080 	ldr.w	r1, [r3, #128]	; 0x80
 8004d4e:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
  (void)RCC->AHB1RSTR;
 8004d52:	f8d3 1080 	ldr.w	r1, [r3, #128]	; 0x80
  RCC->AHB2RSTR |= mask;
 8004d56:	f8d3 1084 	ldr.w	r1, [r3, #132]	; 0x84
 8004d5a:	f8c3 0084 	str.w	r0, [r3, #132]	; 0x84
  RCC->AHB2RSTR &= ~mask;
 8004d5e:	f8d3 1084 	ldr.w	r1, [r3, #132]	; 0x84
 8004d62:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
  (void)RCC->AHB2RSTR;
 8004d66:	f8d3 1084 	ldr.w	r1, [r3, #132]	; 0x84
  RCC->AHB3RSTR |= mask;
 8004d6a:	6fd9      	ldr	r1, [r3, #124]	; 0x7c
 8004d6c:	4321      	orrs	r1, r4
 8004d6e:	67d9      	str	r1, [r3, #124]	; 0x7c
  RCC->AHB3RSTR &= ~mask;
 8004d70:	6fdc      	ldr	r4, [r3, #124]	; 0x7c
  RCC->AHB4RSTR |= mask;
 8004d72:	4932      	ldr	r1, [pc, #200]	; (8004e3c <main+0x10c>)
  RCC->AHB3RSTR &= ~mask;
 8004d74:	402c      	ands	r4, r5
 8004d76:	67dc      	str	r4, [r3, #124]	; 0x7c
  (void)RCC->AHB3RSTR;
 8004d78:	6fdc      	ldr	r4, [r3, #124]	; 0x7c
  RCC->AHB4RSTR |= mask;
 8004d7a:	f8d3 4088 	ldr.w	r4, [r3, #136]	; 0x88
 8004d7e:	4321      	orrs	r1, r4
 * @init
 */
void bdmaInit(void) {
  unsigned i;

  bdma.allocated_mask = 0U;
 8004d80:	4c2f      	ldr	r4, [pc, #188]	; (8004e40 <main+0x110>)
 8004d82:	f8c3 1088 	str.w	r1, [r3, #136]	; 0x88
  RCC->AHB4RSTR &= ~mask;
 8004d86:	f8d3 1088 	ldr.w	r1, [r3, #136]	; 0x88
 8004d8a:	f3c1 010a 	ubfx	r1, r1, #0, #11
 8004d8e:	f8c3 1088 	str.w	r1, [r3, #136]	; 0x88
  (void)RCC->AHB4RSTR;
 8004d92:	4621      	mov	r1, r4
 8004d94:	f8d3 5088 	ldr.w	r5, [r3, #136]	; 0x88
  RCC->APB1LRSTR |= mask;
 8004d98:	f8d3 5090 	ldr.w	r5, [r3, #144]	; 0x90
 8004d9c:	f8c3 0090 	str.w	r0, [r3, #144]	; 0x90
  RCC->APB1LRSTR &= ~mask;
 8004da0:	f8d3 5090 	ldr.w	r5, [r3, #144]	; 0x90
 8004da4:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
  (void)RCC->APB1LRSTR;
 8004da8:	f8d3 5090 	ldr.w	r5, [r3, #144]	; 0x90
  RCC->APB1HRSTR |= mask;
 8004dac:	f8d3 5094 	ldr.w	r5, [r3, #148]	; 0x94
 8004db0:	f8c3 0094 	str.w	r0, [r3, #148]	; 0x94
  RCC->APB1HRSTR &= ~mask;
 8004db4:	f8d3 5094 	ldr.w	r5, [r3, #148]	; 0x94
 8004db8:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94
  (void)RCC->APB1HRSTR;
 8004dbc:	f8d3 5094 	ldr.w	r5, [r3, #148]	; 0x94
  RCC->APB2RSTR |= mask;
 8004dc0:	f8d3 5098 	ldr.w	r5, [r3, #152]	; 0x98
 8004dc4:	f8c3 0098 	str.w	r0, [r3, #152]	; 0x98
  RCC->APB2RSTR &= ~mask;
 8004dc8:	f8d3 5098 	ldr.w	r5, [r3, #152]	; 0x98
 8004dcc:	f8c3 2098 	str.w	r2, [r3, #152]	; 0x98
  (void)RCC->APB2RSTR;
 8004dd0:	f8d3 5098 	ldr.w	r5, [r3, #152]	; 0x98
  RCC->APB3RSTR |= mask;
 8004dd4:	f8d3 508c 	ldr.w	r5, [r3, #140]	; 0x8c
 8004dd8:	f8c3 008c 	str.w	r0, [r3, #140]	; 0x8c
  RCC->APB3RSTR &= ~mask;
 8004ddc:	f8d3 508c 	ldr.w	r5, [r3, #140]	; 0x8c
 8004de0:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
  (void)RCC->APB3RSTR;
 8004de4:	f8d3 508c 	ldr.w	r5, [r3, #140]	; 0x8c
  RCC->APB4RSTR |= mask;
 8004de8:	f8d3 509c 	ldr.w	r5, [r3, #156]	; 0x9c
 8004dec:	f8c3 009c 	str.w	r0, [r3, #156]	; 0x9c
  RCC->APB4RSTR &= ~mask;
 8004df0:	f8d3 009c 	ldr.w	r0, [r3, #156]	; 0x9c
 8004df4:	f8c3 209c 	str.w	r2, [r3, #156]	; 0x9c
  (void)RCC->APB4RSTR;
 8004df8:	f8d3 309c 	ldr.w	r3, [r3, #156]	; 0x9c
 8004dfc:	4b11      	ldr	r3, [pc, #68]	; (8004e44 <main+0x114>)
 8004dfe:	6022      	str	r2, [r4, #0]
 8004e00:	4811      	ldr	r0, [pc, #68]	; (8004e48 <main+0x118>)
 8004e02:	f103 04a0 	add.w	r4, r3, #160	; 0xa0
 8004e06:	e001      	b.n	8004e0c <main+0xdc>
  for (i = 0; i < STM32_BDMA_STREAMS; i++) {
    _stm32_bdma_streams[i].channel->CCR = 0U;
 8004e08:	f853 0c14 	ldr.w	r0, [r3, #-20]
  for (i = 0; i < STM32_BDMA_STREAMS; i++) {
 8004e0c:	3314      	adds	r3, #20
    _stm32_bdma_streams[i].channel->CCR = 0U;
 8004e0e:	6002      	str	r2, [r0, #0]
    bdma.streams[i].func  = NULL;
 8004e10:	604a      	str	r2, [r1, #4]
  for (i = 0; i < STM32_BDMA_STREAMS; i++) {
 8004e12:	42a3      	cmp	r3, r4
    bdma.streams[i].param = NULL;
 8004e14:	f841 2f08 	str.w	r2, [r1, #8]!
  for (i = 0; i < STM32_BDMA_STREAMS; i++) {
 8004e18:	d1f6      	bne.n	8004e08 <main+0xd8>
  }
  BDMA->IFCR = 0xFFFFFFFFU;
 8004e1a:	490c      	ldr	r1, [pc, #48]	; (8004e4c <main+0x11c>)
 8004e1c:	f04f 30ff 	mov.w	r0, #4294967295
 * @init
 */
void dmaInit(void) {
  unsigned i;

  dma.allocated_mask = 0U;
 8004e20:	2300      	movs	r3, #0
 8004e22:	4c0b      	ldr	r4, [pc, #44]	; (8004e50 <main+0x120>)
 8004e24:	6048      	str	r0, [r1, #4]
 8004e26:	4d0b      	ldr	r5, [pc, #44]	; (8004e54 <main+0x124>)
  for (i = 0U; i < STM32_DMA_STREAMS; i++) {
    _stm32_dma_streams[i].stream->CR = STM32_DMA_CR_RESET_VALUE;
 8004e28:	4619      	mov	r1, r3
  dma.allocated_mask = 0U;
 8004e2a:	480b      	ldr	r0, [pc, #44]	; (8004e58 <main+0x128>)
 8004e2c:	6022      	str	r2, [r4, #0]
  for (i = 0U; i < STM32_DMA_STREAMS; i++) {
 8004e2e:	e017      	b.n	8004e60 <main+0x130>
 8004e30:	58024400 	.word	0x58024400
 8004e34:	7fffefff 	.word	0x7fffefff
 8004e38:	80001000 	.word	0x80001000
 8004e3c:	fffff800 	.word	0xfffff800
 8004e40:	240002e8 	.word	0x240002e8
 8004e44:	08005b64 	.word	0x08005b64
 8004e48:	58025408 	.word	0x58025408
 8004e4c:	58025400 	.word	0x58025400
 8004e50:	24000d68 	.word	0x24000d68
 8004e54:	08005bec 	.word	0x08005bec
 8004e58:	40020010 	.word	0x40020010
    _stm32_dma_streams[i].stream->CR = STM32_DMA_CR_RESET_VALUE;
 8004e5c:	f855 0033 	ldr.w	r0, [r5, r3, lsl #3]
    dma.streams[i].func = NULL;
 8004e60:	eb04 0283 	add.w	r2, r4, r3, lsl #2
  for (i = 0U; i < STM32_DMA_STREAMS; i++) {
 8004e64:	3302      	adds	r3, #2
    _stm32_dma_streams[i].stream->CR = STM32_DMA_CR_RESET_VALUE;
 8004e66:	6001      	str	r1, [r0, #0]
  for (i = 0U; i < STM32_DMA_STREAMS; i++) {
 8004e68:	2b20      	cmp	r3, #32
    dma.streams[i].func = NULL;
 8004e6a:	6051      	str	r1, [r2, #4]
  for (i = 0U; i < STM32_DMA_STREAMS; i++) {
 8004e6c:	d1f6      	bne.n	8004e5c <main+0x12c>
  }
  DMA1->LIFCR = 0xFFFFFFFFU;
 8004e6e:	f04f 32ff 	mov.w	r2, #4294967295
 8004e72:	4cd5      	ldr	r4, [pc, #852]	; (80051c8 <main+0x498>)
  DMA1->HIFCR = 0xFFFFFFFFU;
  DMA2->LIFCR = 0xFFFFFFFFU;
 8004e74:	48d5      	ldr	r0, [pc, #852]	; (80051cc <main+0x49c>)
#if defined(__CORE_CM0_H_GENERIC) || defined(__CORE_CM0PLUS_H_GENERIC) ||   \
    defined(__CORE_CM23_H_GENERIC)
  NVIC->__IPR[_IP_IDX(n)] = (NVIC->__IPR[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                            (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->__IPR[n] = NVIC_PRIORITY_MASK(prio);
 8004e76:	2670      	movs	r6, #112	; 0x70
  DMA1->LIFCR = 0xFFFFFFFFU;
 8004e78:	60a2      	str	r2, [r4, #8]
 8004e7a:	25c0      	movs	r5, #192	; 0xc0
  DMA1->HIFCR = 0xFFFFFFFFU;
 8004e7c:	60e2      	str	r2, [r4, #12]
#endif
  NVIC->__ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8004e7e:	f04f 6480 	mov.w	r4, #67108864	; 0x4000000
  DMA2->LIFCR = 0xFFFFFFFFU;
 8004e82:	6082      	str	r2, [r0, #8]
  NVIC->__IPR[n] = NVIC_PRIORITY_MASK(prio);
 8004e84:	4bd2      	ldr	r3, [pc, #840]	; (80051d0 <main+0x4a0>)
  DMA2->HIFCR = 0xFFFFFFFFU;
 8004e86:	60c2      	str	r2, [r0, #12]
 8004e88:	2090      	movs	r0, #144	; 0x90
  NVIC->__ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8004e8a:	f44f 3200 	mov.w	r2, #131072	; 0x20000
  NVIC->__IPR[n] = NVIC_PRIORITY_MASK(prio);
 8004e8e:	f883 037a 	strb.w	r0, [r3, #890]	; 0x37a
  NVIC->__ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8004e92:	f8c3 418c 	str.w	r4, [r3, #396]	; 0x18c
  NVIC->__ISER[n >> 5U] = 1U << (n & 0x1FU);
 8004e96:	60dc      	str	r4, [r3, #12]
  NVIC->__ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8004e98:	f04f 5480 	mov.w	r4, #268435456	; 0x10000000
  NVIC->__IPR[n] = NVIC_PRIORITY_MASK(prio);
 8004e9c:	f883 0331 	strb.w	r0, [r3, #817]	; 0x331
  NVIC->__ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8004ea0:	2080      	movs	r0, #128	; 0x80
 8004ea2:	f8c3 2184 	str.w	r2, [r3, #388]	; 0x184
  NVIC->__ISER[n >> 5U] = 1U << (n & 0x1FU);
 8004ea6:	605a      	str	r2, [r3, #4]
  NVIC->__IPR[n] = NVIC_PRIORITY_MASK(prio);
 8004ea8:	f883 631c 	strb.w	r6, [r3, #796]	; 0x31c
    mpuConfigureRegion(STM32_NOCACHE_MPU_REGION,
 8004eac:	4ac9      	ldr	r2, [pc, #804]	; (80051d4 <main+0x4a4>)
  NVIC->__ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8004eae:	f8c3 4180 	str.w	r4, [r3, #384]	; 0x180
  NVIC->__ISER[n >> 5U] = 1U << (n & 0x1FU);
 8004eb2:	601c      	str	r4, [r3, #0]
 8004eb4:	2406      	movs	r4, #6
  NVIC->__IPR[n] = NVIC_PRIORITY_MASK(prio);
 8004eb6:	f883 5327 	strb.w	r5, [r3, #807]	; 0x327
  NVIC->__ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8004eba:	f8c3 0184 	str.w	r0, [r3, #388]	; 0x184
  NVIC->__ISER[n >> 5U] = 1U << (n & 0x1FU);
 8004ebe:	6058      	str	r0, [r3, #4]
 8004ec0:	f04f 5310 	mov.w	r3, #603979776	; 0x24000000
 8004ec4:	f8c2 4098 	str.w	r4, [r2, #152]	; 0x98
 8004ec8:	48c3      	ldr	r0, [pc, #780]	; (80051d8 <main+0x4a8>)
 8004eca:	f8c2 309c 	str.w	r3, [r2, #156]	; 0x9c
    mpuEnable(MPU_CTRL_PRIVDEFENA);
 8004ece:	2305      	movs	r3, #5
    mpuConfigureRegion(STM32_NOCACHE_MPU_REGION,
 8004ed0:	f8c2 00a0 	str.w	r0, [r2, #160]	; 0xa0
    mpuEnable(MPU_CTRL_PRIVDEFENA);
 8004ed4:	f8c2 3094 	str.w	r3, [r2, #148]	; 0x94
 8004ed8:	6a53      	ldr	r3, [r2, #36]	; 0x24
 8004eda:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8004ede:	6253      	str	r3, [r2, #36]	; 0x24
  #if defined (__DCACHE_PRESENT) && (__DCACHE_PRESENT == 1U)
    uint32_t ccsidr;
    uint32_t sets;
    uint32_t ways;

    SCB->CSSELR = 0U; /*(0U << 1U) | 0U;*/  /* Level 1 data cache */
 8004ee0:	f8c2 1084 	str.w	r1, [r2, #132]	; 0x84
  __ASM volatile ("dsb 0xF":::"memory");
 8004ee4:	f3bf 8f4f 	dsb	sy
    __DSB();

    ccsidr = SCB->CCSIDR;
 8004ee8:	f8d2 5080 	ldr.w	r5, [r2, #128]	; 0x80
                                            /* clean & invalidate D-Cache */
    sets = (uint32_t)(CCSIDR_SETS(ccsidr));
    do {
      ways = (uint32_t)(CCSIDR_WAYS(ccsidr));
      do {
        SCB->DCCISW = (((sets << SCB_DCCISW_SET_Pos) & SCB_DCCISW_SET_Msk) |
 8004eec:	f643 76e0 	movw	r6, #16352	; 0x3fe0
    sets = (uint32_t)(CCSIDR_SETS(ccsidr));
 8004ef0:	f3c5 304e 	ubfx	r0, r5, #13, #15
      ways = (uint32_t)(CCSIDR_WAYS(ccsidr));
 8004ef4:	f3c5 05c9 	ubfx	r5, r5, #3, #10
 8004ef8:	0140      	lsls	r0, r0, #5
        SCB->DCCISW = (((sets << SCB_DCCISW_SET_Pos) & SCB_DCCISW_SET_Msk) |
 8004efa:	ea00 0106 	and.w	r1, r0, r6
      ways = (uint32_t)(CCSIDR_WAYS(ccsidr));
 8004efe:	462c      	mov	r4, r5
        SCB->DCCISW = (((sets << SCB_DCCISW_SET_Pos) & SCB_DCCISW_SET_Msk) |
 8004f00:	ea41 7384 	orr.w	r3, r1, r4, lsl #30
                       ((ways << SCB_DCCISW_WAY_Pos) & SCB_DCCISW_WAY_Msk)  );
        #if defined ( __CC_ARM )
          __schedule_barrier();
        #endif
      } while (ways-- != 0U);
 8004f04:	3c01      	subs	r4, #1
 8004f06:	1c67      	adds	r7, r4, #1
        SCB->DCCISW = (((sets << SCB_DCCISW_SET_Pos) & SCB_DCCISW_SET_Msk) |
 8004f08:	f8c2 3274 	str.w	r3, [r2, #628]	; 0x274
      } while (ways-- != 0U);
 8004f0c:	d1f8      	bne.n	8004f00 <main+0x1d0>
    } while(sets-- != 0U);
 8004f0e:	3820      	subs	r0, #32
 8004f10:	f110 0f20 	cmn.w	r0, #32
 8004f14:	d1f1      	bne.n	8004efa <main+0x1ca>
 8004f16:	9401      	str	r4, [sp, #4]
 8004f18:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 8004f1c:	f3bf 8f6f 	isb	sy
 *
 * @init
 */
void adcObjectInit(ADCDriver *adcp) {

  adcp->state    = ADC_STOP;
 8004f20:	4aae      	ldr	r2, [pc, #696]	; (80051dc <main+0x4ac>)
  adcp->config   = NULL;
 8004f22:	2500      	movs	r5, #0
  adcp->state    = ADC_STOP;
 8004f24:	49ae      	ldr	r1, [pc, #696]	; (80051e0 <main+0x4b0>)
 8004f26:	f04f 0b01 	mov.w	fp, #1
  qp->next = qp;
 8004f2a:	f102 0018 	add.w	r0, r2, #24
  ADCD1.adcc        = ADC12_COMMON;
 8004f2e:	4fad      	ldr	r7, [pc, #692]	; (80051e4 <main+0x4b4>)
 8004f30:	f101 0318 	add.w	r3, r1, #24
  NVIC->__ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8004f34:	f44f 2c80 	mov.w	ip, #262144	; 0x40000
  adcp->config   = NULL;
 8004f38:	604d      	str	r5, [r1, #4]
  adcp->state    = ADC_STOP;
 8004f3a:	f881 b000 	strb.w	fp, [r1]
void chMtxObjectInit(mutex_t *mp) {

  chDbgCheck(mp != NULL);

  ch_queue_init(&mp->queue);
  mp->owner = NULL;
 8004f3e:	620d      	str	r5, [r1, #32]
  adcp->samples  = NULL;
  adcp->depth    = 0;
  adcp->grpp     = NULL;
#if ADC_USE_WAIT == TRUE
  adcp->thread   = NULL;
 8004f40:	6155      	str	r5, [r2, #20]
 8004f42:	6215      	str	r5, [r2, #32]
  ADCD3.data.bdma   = NULL;
 8004f44:	6315      	str	r5, [r2, #48]	; 0x30
  RCC_C1->AHB1ENR |= mask;
 8004f46:	4ea8      	ldr	r6, [pc, #672]	; (80051e8 <main+0x4b8>)
 *
 * @init
 */
void spiObjectInit(SPIDriver *spip) {

  spip->state           = SPI_STOP;
 8004f48:	f8df e2a0 	ldr.w	lr, [pc, #672]	; 80051ec <main+0x4bc>
 8004f4c:	f8df 82a0 	ldr.w	r8, [pc, #672]	; 80051f0 <main+0x4c0>
 8004f50:	f8df 92a0 	ldr.w	r9, [pc, #672]	; 80051f4 <main+0x4c4>
  usbp->state        = USB_STOP;
 8004f54:	f8df a2a0 	ldr.w	sl, [pc, #672]	; 80051f8 <main+0x4c8>
  qp->prev = qp;
 8004f58:	e9c1 3306 	strd	r3, r3, [r1, #24]
 8004f5c:	e9c2 0006 	strd	r0, r0, [r2, #24]
  NVIC->__IPR[n] = NVIC_PRIORITY_MASK(prio);
 8004f60:	4b9b      	ldr	r3, [pc, #620]	; (80051d0 <main+0x4a0>)
 8004f62:	2050      	movs	r0, #80	; 0x50
  ADCD1.adcc        = ADC12_COMMON;
 8004f64:	e9c1 750b 	strd	r7, r5, [r1, #44]	; 0x2c
  adcp->depth    = 0;
 8004f68:	e9c1 5502 	strd	r5, r5, [r1, #8]
  adcp->thread   = NULL;
 8004f6c:	e9c1 5504 	strd	r5, r5, [r1, #16]
  adcp->samples  = NULL;
 8004f70:	e9c2 5501 	strd	r5, r5, [r2, #4]
  adcp->grpp     = NULL;
 8004f74:	e9c2 5503 	strd	r5, r5, [r2, #12]
 8004f78:	f883 0312 	strb.w	r0, [r3, #786]	; 0x312
  NVIC->__ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8004f7c:	f8c3 c180 	str.w	ip, [r3, #384]	; 0x180
  NVIC->__ISER[n >> 5U] = 1U << (n & 0x1FU);
 8004f80:	f8c3 c000 	str.w	ip, [r3]
  NVIC->__ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8004f84:	f04f 4c00 	mov.w	ip, #2147483648	; 0x80000000
  adcp->state    = ADC_STOP;
 8004f88:	f882 b000 	strb.w	fp, [r2]
  NVIC->__IPR[n] = NVIC_PRIORITY_MASK(prio);
 8004f8c:	f883 037f 	strb.w	r0, [r3, #895]	; 0x37f
  ADCD3.adcc        = ADC3_COMMON;
 8004f90:	489a      	ldr	r0, [pc, #616]	; (80051fc <main+0x4cc>)
 8004f92:	62d0      	str	r0, [r2, #44]	; 0x2c
  NVIC->__ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8004f94:	f8c3 c18c 	str.w	ip, [r3, #396]	; 0x18c
  NVIC->__ISER[n >> 5U] = 1U << (n & 0x1FU);
 8004f98:	f8c3 c00c 	str.w	ip, [r3, #12]
  ADCD1.adcm        = ADC1;
 8004f9c:	f8df c260 	ldr.w	ip, [pc, #608]	; 8005200 <main+0x4d0>
 8004fa0:	f8c1 c028 	str.w	ip, [r1, #40]	; 0x28
  ADCD1.dmamode     = ADC12_DMA_SIZE |
 8004fa4:	f8df c25c 	ldr.w	ip, [pc, #604]	; 8005204 <main+0x4d4>
 8004fa8:	f8c1 c034 	str.w	ip, [r1, #52]	; 0x34
  ADCD3.adcm        = ADC3;
 8004fac:	4996      	ldr	r1, [pc, #600]	; (8005208 <main+0x4d8>)
 8004fae:	f8df c25c 	ldr.w	ip, [pc, #604]	; 800520c <main+0x4dc>
 8004fb2:	6291      	str	r1, [r2, #40]	; 0x28
  ADCD3.dmamode     = ADC3_BDMA_SIZE |
 8004fb4:	f242 518a 	movw	r1, #9610	; 0x258a
 8004fb8:	6351      	str	r1, [r2, #52]	; 0x34
  ADC12_COMMON->CCR = STM32_ADC_ADC12_CLOCK_MODE | ADC_DMA_DAMDF | ADC12_CCR_DUAL;
 8004fba:	f44f 3140 	mov.w	r1, #196608	; 0x30000
 8004fbe:	f8d6 20d8 	ldr.w	r2, [r6, #216]	; 0xd8
 8004fc2:	f042 0220 	orr.w	r2, r2, #32
 8004fc6:	f8c6 20d8 	str.w	r2, [r6, #216]	; 0xd8
    RCC_C1->AHB1LPENR |= mask;
 8004fca:	f8d6 2100 	ldr.w	r2, [r6, #256]	; 0x100
 8004fce:	f042 0220 	orr.w	r2, r2, #32
 8004fd2:	f8c6 2100 	str.w	r2, [r6, #256]	; 0x100
  (void)RCC_C1->AHB1LPENR;
 8004fd6:	f8d6 2100 	ldr.w	r2, [r6, #256]	; 0x100
  RCC->AHB1RSTR |= mask;
 8004fda:	f8d6 2080 	ldr.w	r2, [r6, #128]	; 0x80
 8004fde:	f042 0220 	orr.w	r2, r2, #32
 8004fe2:	f8c6 2080 	str.w	r2, [r6, #128]	; 0x80
  RCC->AHB1RSTR &= ~mask;
 8004fe6:	f8d6 2080 	ldr.w	r2, [r6, #128]	; 0x80
 8004fea:	f022 0220 	bic.w	r2, r2, #32
 8004fee:	f8c6 2080 	str.w	r2, [r6, #128]	; 0x80
  (void)RCC->AHB1RSTR;
 8004ff2:	f8d6 2080 	ldr.w	r2, [r6, #128]	; 0x80
 8004ff6:	60b9      	str	r1, [r7, #8]
  RCC_C1->AHB1ENR &= ~mask;
 8004ff8:	f8d6 20d8 	ldr.w	r2, [r6, #216]	; 0xd8
  sdp->vmt = &vmt;
 8004ffc:	4f84      	ldr	r7, [pc, #528]	; (8005210 <main+0x4e0>)
 8004ffe:	f022 0220 	bic.w	r2, r2, #32
 8005002:	463c      	mov	r4, r7
 8005004:	f8c6 20d8 	str.w	r2, [r6, #216]	; 0xd8
  RCC_C1->AHB1LPENR &= ~mask;
 8005008:	f8d6 2100 	ldr.w	r2, [r6, #256]	; 0x100
 800500c:	f022 0220 	bic.w	r2, r2, #32
 8005010:	f8c6 2100 	str.w	r2, [r6, #256]	; 0x100
  (void)RCC_C1->AHB1LPENR;
 8005014:	f8d6 2100 	ldr.w	r2, [r6, #256]	; 0x100
  RCC_C1->AHB4ENR |= mask;
 8005018:	f8d6 20e0 	ldr.w	r2, [r6, #224]	; 0xe0
 800501c:	f042 7280 	orr.w	r2, r2, #16777216	; 0x1000000
 8005020:	f8c6 20e0 	str.w	r2, [r6, #224]	; 0xe0
    RCC_C1->AHB4LPENR |= mask;
 8005024:	f8d6 2108 	ldr.w	r2, [r6, #264]	; 0x108
 8005028:	f042 7280 	orr.w	r2, r2, #16777216	; 0x1000000
 800502c:	f8c6 2108 	str.w	r2, [r6, #264]	; 0x108
  (void)RCC_C1->AHB4LPENR;
 8005030:	f8d6 2108 	ldr.w	r2, [r6, #264]	; 0x108
  RCC->AHB4RSTR |= mask;
 8005034:	f8d6 2088 	ldr.w	r2, [r6, #136]	; 0x88
 8005038:	f042 7280 	orr.w	r2, r2, #16777216	; 0x1000000
 800503c:	f8c6 2088 	str.w	r2, [r6, #136]	; 0x88
  RCC->AHB4RSTR &= ~mask;
 8005040:	f8d6 2088 	ldr.w	r2, [r6, #136]	; 0x88
 8005044:	f022 7280 	bic.w	r2, r2, #16777216	; 0x1000000
 8005048:	f8c6 2088 	str.w	r2, [r6, #136]	; 0x88
  (void)RCC->AHB4RSTR;
 800504c:	f8d6 2088 	ldr.w	r2, [r6, #136]	; 0x88
  ADC3_COMMON->CCR = STM32_ADC_ADC3_CLOCK_MODE;
 8005050:	6081      	str	r1, [r0, #8]
 8005052:	4650      	mov	r0, sl
     allocation.*/
  osalDbgAssert((RCC_C1->AHB4ENR & mask) == mask, "peripherals not allocated");
#endif

  /* Disabling the peripherals.*/
  RCC_C1->AHB4ENR &= ~mask;
 8005054:	f8d6 20e0 	ldr.w	r2, [r6, #224]	; 0xe0
 8005058:	496e      	ldr	r1, [pc, #440]	; (8005214 <main+0x4e4>)
 800505a:	f022 7280 	bic.w	r2, r2, #16777216	; 0x1000000
 800505e:	f8c6 20e0 	str.w	r2, [r6, #224]	; 0xe0
  RCC_C1->AHB4LPENR &= ~mask;
 8005062:	f8d6 2108 	ldr.w	r2, [r6, #264]	; 0x108
 8005066:	f022 7280 	bic.w	r2, r2, #16777216	; 0x1000000
 800506a:	f8c6 2108 	str.w	r2, [r6, #264]	; 0x108
  (void)RCC_C1->AHB4LPENR;
 800506e:	f8d6 2108 	ldr.w	r2, [r6, #264]	; 0x108
 8005072:	4a69      	ldr	r2, [pc, #420]	; (8005218 <main+0x4e8>)
 8005074:	f844 2b04 	str.w	r2, [r4], #4
  iqp->q_top     = bp + size;
 8005078:	4a68      	ldr	r2, [pc, #416]	; (800521c <main+0x4ec>)
 *
 * @init
 */
static inline void chEvtObjectInit(event_source_t *esp) {

  esp->next = (event_listener_t *)esp;
 800507a:	607c      	str	r4, [r7, #4]
  qp->next = qp;
 800507c:	f107 040c 	add.w	r4, r7, #12
 8005080:	61fa      	str	r2, [r7, #28]
  oqp->q_top     = bp + size;
 8005082:	4a67      	ldr	r2, [pc, #412]	; (8005220 <main+0x4f0>)
  iqp->q_counter = 0;
 8005084:	617d      	str	r5, [r7, #20]
  oqp->q_top     = bp + size;
 8005086:	643a      	str	r2, [r7, #64]	; 0x40
  oqp->q_buffer  = bp;
 8005088:	3a10      	subs	r2, #16
  sdp->state = SD_STOP;
 800508a:	f887 b008 	strb.w	fp, [r7, #8]
 800508e:	63fa      	str	r2, [r7, #60]	; 0x3c
  oqp->q_link    = link;
 8005090:	653f      	str	r7, [r7, #80]	; 0x50
  qp->prev = qp;
 8005092:	e9c7 4403 	strd	r4, r4, [r7, #12]
  iqp->q_buffer  = bp;
 8005096:	4c63      	ldr	r4, [pc, #396]	; (8005224 <main+0x4f4>)
 8005098:	61bc      	str	r4, [r7, #24]
  iqp->q_wrptr   = bp;
 800509a:	e9c7 4408 	strd	r4, r4, [r7, #32]
  qp->next = qp;
 800509e:	f107 0430 	add.w	r4, r7, #48	; 0x30
  oqp->q_wrptr   = bp;
 80050a2:	e9c7 2211 	strd	r2, r2, [r7, #68]	; 0x44
  qp->prev = qp;
 80050a6:	e9c7 440c 	strd	r4, r4, [r7, #48]	; 0x30
  sdcp->state    = BLK_STOP;
 80050aa:	4a5f      	ldr	r2, [pc, #380]	; (8005228 <main+0x4f8>)
  oqp->q_counter = size;
 80050ac:	2410      	movs	r4, #16
 80050ae:	f882 b004 	strb.w	fp, [r2, #4]
 80050b2:	63bc      	str	r4, [r7, #56]	; 0x38
  SDCD1.clkfreq = STM32_SDMMC1CLK;
 80050b4:	4614      	mov	r4, r2
  sdcp->errors   = SDC_NO_ERROR;
 80050b6:	6355      	str	r5, [r2, #52]	; 0x34
  SDCD1.thread  = NULL;
 80050b8:	6415      	str	r5, [r2, #64]	; 0x40
  SDCD1.clkfreq = STM32_SDMMC1CLK;
 80050ba:	6495      	str	r5, [r2, #72]	; 0x48
  sdcp->capacity = 0;
 80050bc:	e9c2 550a 	strd	r5, r5, [r2, #40]	; 0x28
  oqp->q_notify  = onfy;
 80050c0:	4a5a      	ldr	r2, [pc, #360]	; (800522c <main+0x4fc>)
 80050c2:	64fa      	str	r2, [r7, #76]	; 0x4c
  SD3.usart = USART3;
 80050c4:	4a5a      	ldr	r2, [pc, #360]	; (8005230 <main+0x500>)
 80050c6:	657a      	str	r2, [r7, #84]	; 0x54
  SD3.clock = STM32_USART3CLK;
 80050c8:	4a5a      	ldr	r2, [pc, #360]	; (8005234 <main+0x504>)
 80050ca:	65ba      	str	r2, [r7, #88]	; 0x58
  sdcp->vmt      = &sdc_vmt;
 80050cc:	4a5a      	ldr	r2, [pc, #360]	; (8005238 <main+0x508>)
 80050ce:	6022      	str	r2, [r4, #0]
  SDCD1.sdmmc   = SDMMC1;
 80050d0:	4a5a      	ldr	r2, [pc, #360]	; (800523c <main+0x50c>)
 80050d2:	6462      	str	r2, [r4, #68]	; 0x44
  SDCD1.buf     = __nocache_sd1_buf;
 80050d4:	4a5a      	ldr	r2, [pc, #360]	; (8005240 <main+0x510>)
 80050d6:	63e2      	str	r2, [r4, #60]	; 0x3c
  SDCD1.resp    = __nocache_sd1_wbuf;
 80050d8:	4a5a      	ldr	r2, [pc, #360]	; (8005244 <main+0x514>)
 80050da:	64e2      	str	r2, [r4, #76]	; 0x4c
  NVIC->__IPR[n] = NVIC_PRIORITY_MASK(prio);
 80050dc:	f06f 045f 	mvn.w	r4, #95	; 0x5f
  NVIC->__ICPR[n >> 5U] = 1U << (n & 0x1FU);
 80050e0:	2208      	movs	r2, #8
  iqp->q_link    = link;
 80050e2:	e9c7 570a 	strd	r5, r7, [r7, #40]	; 0x28
 80050e6:	f88e b000 	strb.w	fp, [lr]
  NVIC->__IPR[n] = NVIC_PRIORITY_MASK(prio);
 80050ea:	f883 4323 	strb.w	r4, [r3, #803]	; 0x323
  spip->config          = NULL;
 80050ee:	f8ce 5004 	str.w	r5, [lr, #4]
  NVIC->__ICPR[n >> 5U] = 1U << (n & 0x1FU);
 80050f2:	f8c3 2184 	str.w	r2, [r3, #388]	; 0x184
  NVIC->__ISER[n >> 5U] = 1U << (n & 0x1FU);
 80050f6:	605a      	str	r2, [r3, #4]
  qp->next = qp;
 80050f8:	f10e 020c 	add.w	r2, lr, #12
#if SPI_USE_SYNCHRONIZATION == TRUE
  spip->sync_transfer   = NULL;
 80050fc:	f8ce 5008 	str.w	r5, [lr, #8]
  spip->state           = SPI_STOP;
 8005100:	f881 b000 	strb.w	fp, [r1]
  qp->prev = qp;
 8005104:	e9ce 2203 	strd	r2, r2, [lr, #12]
  NVIC->__ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8005108:	2210      	movs	r2, #16
  NVIC->__IPR[n] = NVIC_PRIORITY_MASK(prio);
 800510a:	f883 4324 	strb.w	r4, [r3, #804]	; 0x324
 800510e:	f8ce 5014 	str.w	r5, [lr, #20]
  NVIC->__ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8005112:	f8c3 2184 	str.w	r2, [r3, #388]	; 0x184
  NVIC->__ISER[n >> 5U] = 1U << (n & 0x1FU);
 8005116:	605a      	str	r2, [r3, #4]
#if defined(STM32_SPI_DMA_REQUIRED) && defined(STM32_SPI_BDMA_REQUIRED)
  SPID1.is_bdma   = false;
#endif
  SPID1.rx.dma    = NULL;
  SPID1.tx.dma    = NULL;
  SPID1.rxdmamode = STM32_DMA_CR_PL(STM32_SPI_SPI1_DMA_PRIORITY) |
 8005118:	4a4b      	ldr	r2, [pc, #300]	; (8005248 <main+0x518>)
 800511a:	614d      	str	r5, [r1, #20]
 800511c:	f8ce 202c 	str.w	r2, [lr, #44]	; 0x2c
                    STM32_DMA_CR_DIR_P2M |
                    STM32_DMA_CR_TCIE |
                    STM32_DMA_CR_DMEIE |
                    STM32_DMA_CR_TEIE;
  SPID1.txdmamode = STM32_DMA_CR_PL(STM32_SPI_SPI1_DMA_PRIORITY) |
 8005120:	3230      	adds	r2, #48	; 0x30

#if STM32_SPI_USE_SPI2
  spiObjectInit(&SPID2);
  SPID2.spi       = SPI2;
#if defined(STM32_SPI_DMA_REQUIRED) && defined(STM32_SPI_BDMA_REQUIRED)
  SPID2.is_bdma   = false;
 8005122:	f881 5020 	strb.w	r5, [r1, #32]
  SPID1.txdmamode = STM32_DMA_CR_PL(STM32_SPI_SPI1_DMA_PRIORITY) |
 8005126:	f8ce 2030 	str.w	r2, [lr, #48]	; 0x30
  qp->next = qp;
 800512a:	f101 020c 	add.w	r2, r1, #12
  SPID1.is_bdma   = false;
 800512e:	f88e 5020 	strb.w	r5, [lr, #32]
 8005132:	f88c b000 	strb.w	fp, [ip]
  qp->prev = qp;
 8005136:	e9c1 2203 	strd	r2, r2, [r1, #12]
#endif
  SPID2.rx.dma    = NULL;
  SPID2.tx.dma    = NULL;
  SPID2.rxdmamode = STM32_DMA_CR_PL(STM32_SPI_SPI2_DMA_PRIORITY) |
 800513a:	4a43      	ldr	r2, [pc, #268]	; (8005248 <main+0x518>)
 800513c:	62ca      	str	r2, [r1, #44]	; 0x2c
                    STM32_DMA_CR_DIR_P2M |
                    STM32_DMA_CR_TCIE |
                    STM32_DMA_CR_DMEIE |
                    STM32_DMA_CR_TEIE;
  SPID2.txdmamode = STM32_DMA_CR_PL(STM32_SPI_SPI2_DMA_PRIORITY) |
 800513e:	3230      	adds	r2, #48	; 0x30
 8005140:	630a      	str	r2, [r1, #48]	; 0x30
  SPID1.spi       = SPI1;
 8005142:	4a42      	ldr	r2, [pc, #264]	; (800524c <main+0x51c>)
 8005144:	f8ce 201c 	str.w	r2, [lr, #28]
  SPID2.spi       = SPI2;
 8005148:	f5a2 4278 	sub.w	r2, r2, #63488	; 0xf800
  spip->sync_transfer   = NULL;
 800514c:	e9c1 5501 	strd	r5, r5, [r1, #4]
 8005150:	61ca      	str	r2, [r1, #28]
#if defined(STM32_SPI_DMA_REQUIRED) && defined(STM32_SPI_BDMA_REQUIRED)
  SPID3.is_bdma   = false;
#endif
  SPID3.rx.dma    = NULL;
  SPID3.tx.dma    = NULL;
  SPID3.rxdmamode = STM32_DMA_CR_PL(STM32_SPI_SPI3_DMA_PRIORITY) |
 8005152:	4a3d      	ldr	r2, [pc, #244]	; (8005248 <main+0x518>)
  SPID2.tx.dma    = NULL;
 8005154:	e9c1 5509 	strd	r5, r5, [r1, #36]	; 0x24
  qp->next = qp;
 8005158:	f10c 010c 	add.w	r1, ip, #12
  SPID1.tx.dma    = NULL;
 800515c:	e9ce 5509 	strd	r5, r5, [lr, #36]	; 0x24
 8005160:	e9cc 5501 	strd	r5, r5, [ip, #4]
  qp->prev = qp;
 8005164:	e9cc 1103 	strd	r1, r1, [ip, #12]
  NVIC->__IPR[n] = NVIC_PRIORITY_MASK(prio);
 8005168:	f883 4333 	strb.w	r4, [r3, #819]	; 0x333
 800516c:	4621      	mov	r1, r4
  NVIC->__ICPR[n >> 5U] = 1U << (n & 0x1FU);
 800516e:	f44f 2400 	mov.w	r4, #524288	; 0x80000
 8005172:	f8cc 5014 	str.w	r5, [ip, #20]
 8005176:	f8c3 4184 	str.w	r4, [r3, #388]	; 0x184
  NVIC->__ISER[n >> 5U] = 1U << (n & 0x1FU);
 800517a:	605c      	str	r4, [r3, #4]
  NVIC->__ICPR[n >> 5U] = 1U << (n & 0x1FU);
 800517c:	f44f 1400 	mov.w	r4, #2097152	; 0x200000
  SPID3.is_bdma   = false;
 8005180:	f88c 5020 	strb.w	r5, [ip, #32]
  SPID3.rx.dma    = NULL;
 8005184:	f8cc 5024 	str.w	r5, [ip, #36]	; 0x24
  spip->state           = SPI_STOP;
 8005188:	f888 b000 	strb.w	fp, [r8]
  NVIC->__IPR[n] = NVIC_PRIORITY_MASK(prio);
 800518c:	f883 1355 	strb.w	r1, [r3, #853]	; 0x355
  SPID3.tx.dma    = NULL;
 8005190:	f8cc 5028 	str.w	r5, [ip, #40]	; 0x28
  NVIC->__ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8005194:	f8c3 4188 	str.w	r4, [r3, #392]	; 0x188
  NVIC->__ISER[n >> 5U] = 1U << (n & 0x1FU);
 8005198:	609c      	str	r4, [r3, #8]
}
 800519a:	2404      	movs	r4, #4
  SPID3.rxdmamode = STM32_DMA_CR_PL(STM32_SPI_SPI3_DMA_PRIORITY) |
 800519c:	f8cc 202c 	str.w	r2, [ip, #44]	; 0x2c
#if defined(STM32_SPI_DMA_REQUIRED) && defined(STM32_SPI_BDMA_REQUIRED)
  SPID5.is_bdma   = false;
#endif
  SPID5.rx.dma    = NULL;
  SPID5.tx.dma    = NULL;
  SPID5.rxdmamode = STM32_DMA_CR_PL(STM32_SPI_SPI5_DMA_PRIORITY) |
 80051a0:	f8c8 202c 	str.w	r2, [r8, #44]	; 0x2c
  SPID3.txdmamode = STM32_DMA_CR_PL(STM32_SPI_SPI3_DMA_PRIORITY) |
 80051a4:	3230      	adds	r2, #48	; 0x30
 80051a6:	f8c8 5014 	str.w	r5, [r8, #20]
 80051aa:	f8cc 2030 	str.w	r2, [ip, #48]	; 0x30
                    STM32_DMA_CR_DIR_P2M |
                    STM32_DMA_CR_TCIE |
                    STM32_DMA_CR_DMEIE |
                    STM32_DMA_CR_TEIE;
  SPID5.txdmamode = STM32_DMA_CR_PL(STM32_SPI_SPI5_DMA_PRIORITY) |
 80051ae:	f8c8 2030 	str.w	r2, [r8, #48]	; 0x30
  qp->next = qp;
 80051b2:	f108 020c 	add.w	r2, r8, #12
  SPID5.is_bdma   = false;
 80051b6:	f888 5020 	strb.w	r5, [r8, #32]
 80051ba:	f889 b000 	strb.w	fp, [r9]
 80051be:	f8c9 5014 	str.w	r5, [r9, #20]
  qp->prev = qp;
 80051c2:	e9c8 2203 	strd	r2, r2, [r8, #12]
 80051c6:	e043      	b.n	8005250 <main+0x520>
 80051c8:	40020000 	.word	0x40020000
 80051cc:	40020400 	.word	0x40020400
 80051d0:	e000e100 	.word	0xe000e100
 80051d4:	e000ed00 	.word	0xe000ed00
 80051d8:	030c001b 	.word	0x030c001b
 80051dc:	24000038 	.word	0x24000038
 80051e0:	24000000 	.word	0x24000000
 80051e4:	40022300 	.word	0x40022300
 80051e8:	58024400 	.word	0x58024400
 80051ec:	24000120 	.word	0x24000120
 80051f0:	240001d4 	.word	0x240001d4
 80051f4:	24000210 	.word	0x24000210
 80051f8:	2400024c 	.word	0x2400024c
 80051fc:	58026300 	.word	0x58026300
 8005200:	40022000 	.word	0x40022000
 8005204:	00022c16 	.word	0x00022c16
 8005208:	58026000 	.word	0x58026000
 800520c:	24000198 	.word	0x24000198
 8005210:	24000070 	.word	0x24000070
 8005214:	2400015c 	.word	0x2400015c
 8005218:	08005f38 	.word	0x08005f38
 800521c:	24001510 	.word	0x24001510
 8005220:	24001520 	.word	0x24001520
 8005224:	24001500 	.word	0x24001500
 8005228:	240000d0 	.word	0x240000d0
 800522c:	08000a01 	.word	0x08000a01
 8005230:	40004800 	.word	0x40004800
 8005234:	00f42400 	.word	0x00f42400
 8005238:	08005ea4 	.word	0x08005ea4
 800523c:	52007000 	.word	0x52007000
 8005240:	30040000 	.word	0x30040000
 8005244:	30040200 	.word	0x30040200
 8005248:	00010016 	.word	0x00010016
 800524c:	40013000 	.word	0x40013000
  qp->next = qp;
 8005250:	f109 020c 	add.w	r2, r9, #12
  qp->prev = qp;
 8005254:	e9c9 2203 	strd	r2, r2, [r9, #12]
  SPID3.spi       = SPI3;
 8005258:	4ac6      	ldr	r2, [pc, #792]	; (8005574 <main+0x844>)
 800525a:	f8cc 201c 	str.w	r2, [ip, #28]
  SPID5.spi       = SPI5;
 800525e:	f502 328a 	add.w	r2, r2, #70656	; 0x11400
 8005262:	f8c8 201c 	str.w	r2, [r8, #28]
#endif
#endif

#if STM32_SPI_USE_SPI6
  spiObjectInit(&SPID6);
  SPID6.spi       = SPI6;
 8005266:	4ac4      	ldr	r2, [pc, #784]	; (8005578 <main+0x848>)
  spip->sync_transfer   = NULL;
 8005268:	e9c8 5501 	strd	r5, r5, [r8, #4]
  SPID5.tx.dma    = NULL;
 800526c:	e9c8 5509 	strd	r5, r5, [r8, #36]	; 0x24
 8005270:	e9c9 5501 	strd	r5, r5, [r9, #4]
  SPID6.spi       = SPI6;
 8005274:	f8c9 201c 	str.w	r2, [r9, #28]
  NVIC->__ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8005278:	f44f 0280 	mov.w	r2, #4194304	; 0x400000
  NVIC->__IPR[n] = NVIC_PRIORITY_MASK(prio);
 800527c:	f883 1356 	strb.w	r1, [r3, #854]	; 0x356
    usbp->in_params[i]  = NULL;
 8005280:	4629      	mov	r1, r5
  NVIC->__ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8005282:	f8c3 2188 	str.w	r2, [r3, #392]	; 0x188
  NVIC->__ISER[n >> 5U] = 1U << (n & 0x1FU);
 8005286:	609a      	str	r2, [r3, #8]
  SPID6.tx.bdma   = NULL;
  SPID6.rxdmamode = STM32_BDMA_CR_PL(STM32_SPI_SPI6_DMA_PRIORITY) |
                    STM32_BDMA_CR_DIR_P2M |
                    STM32_BDMA_CR_TCIE |
                    STM32_BDMA_CR_TEIE;
  SPID6.txdmamode = STM32_BDMA_CR_PL(STM32_SPI_SPI6_DMA_PRIORITY) |
 8005288:	f241 0318 	movw	r3, #4120	; 0x1018
 800528c:	f241 020a 	movw	r2, #4106	; 0x100a
  usbp->state        = USB_STOP;
 8005290:	f800 bb30 	strb.w	fp, [r0], #48
  SPID6.is_bdma   = true;
 8005294:	f889 b020 	strb.w	fp, [r9, #32]
  SPID6.txdmamode = STM32_BDMA_CR_PL(STM32_SPI_SPI6_DMA_PRIORITY) |
 8005298:	e9c9 230b 	strd	r2, r3, [r9, #44]	; 0x2c
    usbp->in_params[i]  = NULL;
 800529c:	2240      	movs	r2, #64	; 0x40
  SPID6.tx.bdma   = NULL;
 800529e:	e9c9 5509 	strd	r5, r5, [r9, #36]	; 0x24
 80052a2:	f000 fb1f 	bl	80058e4 <memset>
  RCC_C1->APB1LENR |= mask;
 80052a6:	f8d6 30e8 	ldr.w	r3, [r6, #232]	; 0xe8
  ST_ENABLE_STOP();
 80052aa:	49b4      	ldr	r1, [pc, #720]	; (800557c <main+0x84c>)
 80052ac:	ea43 030b 	orr.w	r3, r3, fp
  usbp->transmitting = 0;
 80052b0:	e9ca 5501 	strd	r5, r5, [sl, #4]
 80052b4:	f8c6 30e8 	str.w	r3, [r6, #232]	; 0xe8
    RCC_C1->APB1LLPENR |= mask;
 80052b8:	f8d6 3110 	ldr.w	r3, [r6, #272]	; 0x110
 80052bc:	ea43 030b 	orr.w	r3, r3, fp
 80052c0:	f8c6 3110 	str.w	r3, [r6, #272]	; 0x110
  (void)RCC_C1->APB1LLPENR;
 80052c4:	f8d6 3110 	ldr.w	r3, [r6, #272]	; 0x110
  STM32_ST_TIM->PSC    = (ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1;
 80052c8:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
  ch_system.state = ch_sys_initializing;
 80052cc:	4eac      	ldr	r6, [pc, #688]	; (8005580 <main+0x850>)
  time_measurement_t tm;

  /* Time Measurement subsystem calibration, it does a null measurement
     and calculates the call overhead which is subtracted to real
     measurements.*/
  tcp->offset = (rtcnt_t)0;
 80052ce:	60b5      	str	r5, [r6, #8]
  ST_ENABLE_STOP();
 80052d0:	6bca      	ldr	r2, [r1, #60]	; 0x3c
 80052d2:	ea42 020b 	orr.w	r2, r2, fp
 80052d6:	63ca      	str	r2, [r1, #60]	; 0x3c
  USBD1.otg       = OTG_FS;
 80052d8:	4aaa      	ldr	r2, [pc, #680]	; (8005584 <main+0x854>)
 80052da:	f8ca 2090 	str.w	r2, [sl, #144]	; 0x90
  USBD1.otgparams = &fsparams;
 80052de:	4aaa      	ldr	r2, [pc, #680]	; (8005588 <main+0x858>)
 80052e0:	f8ca 2094 	str.w	r2, [sl, #148]	; 0x94
  STM32_ST_TIM->PSC    = (ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1;
 80052e4:	f640 427f 	movw	r2, #3199	; 0xc7f
 80052e8:	629a      	str	r2, [r3, #40]	; 0x28
  STM32_ST_TIM->ARR    = ST_ARR_INIT;
 80052ea:	9a01      	ldr	r2, [sp, #4]
 80052ec:	62da      	str	r2, [r3, #44]	; 0x2c
  STM32_ST_TIM->CCMR1  = 0;
 80052ee:	619d      	str	r5, [r3, #24]
  STM32_ST_TIM->CCR[0] = 0;
 80052f0:	635d      	str	r5, [r3, #52]	; 0x34
  STM32_ST_TIM->DIER   = 0;
 80052f2:	60dd      	str	r5, [r3, #12]
  STM32_ST_TIM->CR2    = 0;
 80052f4:	605d      	str	r5, [r3, #4]
  STM32_ST_TIM->EGR    = TIM_EGR_UG;
 80052f6:	f8c3 b014 	str.w	fp, [r3, #20]
  STM32_ST_TIM->CR1    = TIM_CR1_CEN;
 80052fa:	f8c3 b000 	str.w	fp, [r3]
  tmp->cumulative = (rttime_t)0;
 80052fe:	2300      	movs	r3, #0
 8005300:	f886 b000 	strb.w	fp, [r6]
  tmp->worst      = (rtcnt_t)0;
 8005304:	e9cd 2502 	strd	r2, r5, [sp, #8]
  tmp->cumulative = (rttime_t)0;
 8005308:	2200      	movs	r2, #0
  tmp->n          = (ucnt_t)0;
 800530a:	e9cd 5504 	strd	r5, r5, [sp, #16]
  tmp->cumulative = (rttime_t)0;
 800530e:	e9cd 2306 	strd	r2, r3, [sp, #24]
  chTMObjectInit(&tm);
  i = TM_CALIBRATION_LOOP;
  do {
    chTMStartMeasurementX(&tm);
 8005312:	a802      	add	r0, sp, #8
 8005314:	f7fb fb8c 	bl	8000a30 <chTMStartMeasurementX>
    chTMStopMeasurementX(&tm);
 8005318:	f7fb fb92 	bl	8000a40 <chTMStopMeasurementX>
    i--;
  } while (i > 0U);
 800531c:	3c01      	subs	r4, #1
 800531e:	d1f8      	bne.n	8005312 <main+0x5e2>
 *
 * @notapi
 */
void __heap_init(void) {

  default_heap.provider = chCoreAllocAlignedWithOffset;
 8005320:	4a9a      	ldr	r2, [pc, #616]	; (800558c <main+0x85c>)
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8005322:	f04f 0c30 	mov.w	ip, #48	; 0x30
  qp->next = qp;
 8005326:	4b9a      	ldr	r3, [pc, #616]	; (8005590 <main+0x860>)
 8005328:	f102 010c 	add.w	r1, r2, #12
  ch_memcore.basemem = __heap_base__;
 800532c:	4899      	ldr	r0, [pc, #612]	; (8005594 <main+0x864>)
 800532e:	6154      	str	r4, [r2, #20]
  core_id = port_get_core_id();
#else
  core_id = 0U;
#endif
  chDbgAssert(ch_system.instances[core_id] == NULL, "instance already registered");
  ch_system.instances[core_id] = oip;
 8005330:	4d99      	ldr	r5, [pc, #612]	; (8005598 <main+0x868>)
 8005332:	609c      	str	r4, [r3, #8]
  chDbgCheck((mp != NULL) &&
             (size >= sizeof(void *)) &&
             (align >= PORT_NATURAL_ALIGN) &&
             MEM_IS_VALID_ALIGNMENT(align));

  mp->next = NULL;
 8005334:	615c      	str	r4, [r3, #20]
 8005336:	62dc      	str	r4, [r3, #44]	; 0x2c
 8005338:	6075      	str	r5, [r6, #4]

  /* Core associated to this instance.*/
  oip->core_id = core_id;
 800533a:	632c      	str	r4, [r5, #48]	; 0x30
  qp->prev = qp;
 800533c:	e9c2 1103 	strd	r1, r1, [r2, #12]
  mp->object_size = size;
  mp->align = align;
 8005340:	2104      	movs	r1, #4
 8005342:	61d9      	str	r1, [r3, #28]
 8005344:	6359      	str	r1, [r3, #52]	; 0x34
  mp->provider = provider;
 8005346:	4995      	ldr	r1, [pc, #596]	; (800559c <main+0x86c>)
 8005348:	6219      	str	r1, [r3, #32]
 800534a:	6399      	str	r1, [r3, #56]	; 0x38
  tcp->offset = tm.best;
 800534c:	9902      	ldr	r1, [sp, #8]
 800534e:	60b1      	str	r1, [r6, #8]
 8005350:	4993      	ldr	r1, [pc, #588]	; (80055a0 <main+0x870>)
 8005352:	6001      	str	r1, [r0, #0]
  ch_memcore.topmem  = __heap_end__;
 8005354:	4993      	ldr	r1, [pc, #588]	; (80055a4 <main+0x874>)
 8005356:	6041      	str	r1, [r0, #4]
 8005358:	4993      	ldr	r1, [pc, #588]	; (80055a8 <main+0x878>)
  H_NEXT(&default_heap.header) = NULL;
  H_PAGES(&default_heap.header) = 0;
 800535a:	e9c2 4401 	strd	r4, r4, [r2, #4]
  default_heap.provider = chCoreAllocAlignedWithOffset;
 800535e:	6011      	str	r1, [r2, #0]
  } while ((c != (char)0) && (i > 0U));
}

static inline void dyn_list_init(dyn_list_t *dlp) {

  dlp->next = (dyn_element_t *)dlp;
 8005360:	f103 0210 	add.w	r2, r3, #16
 8005364:	611a      	str	r2, [r3, #16]
  mp->object_size = size;
 8005366:	2214      	movs	r2, #20
 8005368:	619a      	str	r2, [r3, #24]
 800536a:	f103 0224 	add.w	r2, r3, #36	; 0x24
 800536e:	625a      	str	r2, [r3, #36]	; 0x24
 8005370:	f103 0228 	add.w	r2, r3, #40	; 0x28
 8005374:	629a      	str	r2, [r3, #40]	; 0x28
 8005376:	221c      	movs	r2, #28
 8005378:	631a      	str	r2, [r3, #48]	; 0x30
 800537a:	f103 023c 	add.w	r2, r3, #60	; 0x3c
 800537e:	63da      	str	r2, [r3, #60]	; 0x3c
 8005380:	f103 0240 	add.w	r2, r3, #64	; 0x40
 8005384:	641a      	str	r2, [r3, #64]	; 0x40
 8005386:	f103 0244 	add.w	r2, r3, #68	; 0x44
 800538a:	e9c3 3300 	strd	r3, r3, [r3]
 800538e:	645a      	str	r2, [r3, #68]	; 0x44

  /* Keeping a reference to the configuration data.*/
  oip->config = oicp;
 8005390:	4b86      	ldr	r3, [pc, #536]	; (80055ac <main+0x87c>)
 8005392:	63ab      	str	r3, [r5, #56]	; 0x38
 8005394:	f38c 8811 	msr	BASEPRI, ip
  __ASM volatile ("cpsie i" : : : "memory");
 8005398:	b662      	cpsie	i
  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 800539a:	4b85      	ldr	r3, [pc, #532]	; (80055b0 <main+0x880>)
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 800539c:	f64f 0eff 	movw	lr, #63743	; 0xf8ff
 *
 * @notapi
 */
static inline void __rfcu_object_init(rfcu_t *rfcup) {

  rfcup->mask = (rfcu_mask_t)0;
 80053a0:	636c      	str	r4, [r5, #52]	; 0x34

  ch_dlist_init(&vtlp->dlist);
#if CH_CFG_ST_TIMEDELTA == 0
  vtlp->systime = (systime_t)0;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  vtlp->lasttime = (systime_t)0;
 80053a2:	61ec      	str	r4, [r5, #28]
  reg_value  =  (reg_value                                   |
 80053a4:	4983      	ldr	r1, [pc, #524]	; (80055b4 <main+0x884>)
  DWT->LAR = 0xC5ACCE55U;
 80053a6:	4a84      	ldr	r2, [pc, #528]	; (80055b8 <main+0x888>)
  pqp->prio = (tprio_t)0;
 80053a8:	e9c5 5401 	strd	r5, r4, [r5, #4]
  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 80053ac:	68d8      	ldr	r0, [r3, #12]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 80053ae:	ea00 000e 	and.w	r0, r0, lr
  reg_value  =  (reg_value                                   |
 80053b2:	4301      	orrs	r1, r0
  SCB->AIRCR =  reg_value;
 80053b4:	60d9      	str	r1, [r3, #12]
  CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
 80053b6:	f8d3 10fc 	ldr.w	r1, [r3, #252]	; 0xfc
 80053ba:	f041 7180 	orr.w	r1, r1, #16777216	; 0x1000000
 80053be:	f8c3 10fc 	str.w	r1, [r3, #252]	; 0xfc
  DWT->LAR = 0xC5ACCE55U;
 80053c2:	497e      	ldr	r1, [pc, #504]	; (80055bc <main+0x88c>)
 80053c4:	f8c2 1fb0 	str.w	r1, [r2, #4016]	; 0xfb0
  DWT->CTRL |= DWT_CTRL_CYCCNTENA_Msk;
 80053c8:	6811      	ldr	r1, [r2, #0]
 80053ca:	f041 0101 	orr.w	r1, r1, #1
 80053ce:	6011      	str	r1, [r2, #0]
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 80053d0:	2220      	movs	r2, #32
 80053d2:	77da      	strb	r2, [r3, #31]
 80053d4:	f883 c022 	strb.w	ip, [r3, #34]	; 0x22
 80053d8:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
  pqp->next = pqp;
 80053dc:	602d      	str	r5, [r5, #0]
 80053de:	6a59      	ldr	r1, [r3, #36]	; 0x24
  dlhp->next  = dlhp;
 80053e0:	f105 0310 	add.w	r3, r5, #16
  dlhp->prev  = dlhp;
 80053e4:	e9c5 3304 	strd	r3, r3, [r5, #16]
  dlhp->delta = (sysinterval_t)-1;
 80053e8:	f04f 33ff 	mov.w	r3, #4294967295
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
#if CH_CFG_USE_TIMESTAMP == TRUE
  vtlp->laststamp = (systimestamp_t)chVTGetSystemTimeX();
 80053ec:	460a      	mov	r2, r1
 80053ee:	61ab      	str	r3, [r5, #24]
  tbp->suspended = (uint16_t)~CH_DBG_TRACE_MASK;
 80053f0:	f503 0301 	add.w	r3, r3, #8454144	; 0x810000
 80053f4:	f8c5 3088 	str.w	r3, [r5, #136]	; 0x88
  tbp->ptr       = &tbp->buffer[0];
 80053f8:	f105 0390 	add.w	r3, r5, #144	; 0x90
 80053fc:	f8c5 308c 	str.w	r3, [r5, #140]	; 0x8c
 8005400:	4623      	mov	r3, r4
 8005402:	e9c5 2308 	strd	r2, r3, [r5, #32]
 *
 * @notapi
 */
static inline void __dbg_object_init(system_debug_t *sdp) {

  sdp->panic_msg = NULL;
 8005406:	f8c5 4084 	str.w	r4, [r5, #132]	; 0x84
    tbp->buffer[i].type = CH_TRACE_TYPE_UNUSED;
 800540a:	eb05 1304 	add.w	r3, r5, r4, lsl #4
  for (i = 0U; i < (unsigned)CH_DBG_TRACE_BUFFER_SIZE; i++) {
 800540e:	3401      	adds	r4, #1
    tbp->buffer[i].type = CH_TRACE_TYPE_UNUSED;
 8005410:	f893 2090 	ldrb.w	r2, [r3, #144]	; 0x90
  for (i = 0U; i < (unsigned)CH_DBG_TRACE_BUFFER_SIZE; i++) {
 8005414:	2c80      	cmp	r4, #128	; 0x80
    tbp->buffer[i].type = CH_TRACE_TYPE_UNUSED;
 8005416:	f36f 0202 	bfc	r2, #0, #3
 800541a:	f883 2090 	strb.w	r2, [r3, #144]	; 0x90
  for (i = 0U; i < (unsigned)CH_DBG_TRACE_BUFFER_SIZE; i++) {
 800541e:	d1f4      	bne.n	800540a <main+0x6da>
  p->prev       = qp->prev;
 8005420:	f8df 819c 	ldr.w	r8, [pc, #412]	; 80055c0 <main+0x890>
#if (CH_DBG_ENABLE_STACK_CHECK == TRUE) || (CH_CFG_USE_DYNAMIC == TRUE)
  oip->rlist.current->wabase = oicp->mainthread_base;
#endif

  /* Setting up the caller as current thread.*/
  oip->rlist.current->state = CH_STATE_CURRENT;
 8005424:	f04f 0901 	mov.w	r9, #1
  tp->name              = name;
 8005428:	4966      	ldr	r1, [pc, #408]	; (80055c4 <main+0x894>)
  tp->state             = CH_STATE_WTSTART;
 800542a:	f04f 0b02 	mov.w	fp, #2
  tp->wabase = tdp->wbase;
 800542e:	4866      	ldr	r0, [pc, #408]	; (80055c8 <main+0x898>)
  p->prev->next = p;
 8005430:	f108 0224 	add.w	r2, r8, #36	; 0x24
  tp->name              = name;
 8005434:	65a9      	str	r1, [r5, #88]	; 0x58
  lp->next = lp;
 8005436:	f108 0140 	add.w	r1, r8, #64	; 0x40
  p->prev       = qp->prev;
 800543a:	f8c0 20fc 	str.w	r2, [r0, #252]	; 0xfc
  p->prev->next = p;
 800543e:	f100 03f8 	add.w	r3, r0, #248	; 0xf8
  lp->next = lp;
 8005442:	66a9      	str	r1, [r5, #104]	; 0x68
  oip->rlist.current = __thd_object_init(oip, &oip->mainthread,
 8005444:	f108 0114 	add.w	r1, r8, #20
  p->prev->next = p;
 8005448:	62aa      	str	r2, [r5, #40]	; 0x28
  qp->next = qp;
 800544a:	f108 0244 	add.w	r2, r8, #68	; 0x44
 800544e:	60e9      	str	r1, [r5, #12]
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);
 8005450:	495e      	ldr	r1, [pc, #376]	; (80055cc <main+0x89c>)
  tp->hdr.pqueue.prio   = prio;
 8005452:	646c      	str	r4, [r5, #68]	; 0x44
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);
 8005454:	f8c0 10c4 	str.w	r1, [r0, #196]	; 0xc4
 8005458:	495d      	ldr	r1, [pc, #372]	; (80055d0 <main+0x8a0>)
  tp->realprio          = prio;
 800545a:	67ec      	str	r4, [r5, #124]	; 0x7c
  tp->mtxlist           = NULL;
 800545c:	2400      	movs	r4, #0
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);
 800545e:	f8c0 10e4 	str.w	r1, [r0, #228]	; 0xe4
  p->prev->next = p;
 8005462:	64eb      	str	r3, [r5, #76]	; 0x4c
  tp->name              = name;
 8005464:	495b      	ldr	r1, [pc, #364]	; (80055d4 <main+0x8a4>)
  qp->prev      = p;
 8005466:	62eb      	str	r3, [r5, #44]	; 0x2c
  qp->next = qp;
 8005468:	f500 738c 	add.w	r3, r0, #280	; 0x118
  tp->owner             = oip;
 800546c:	f8c0 5100 	str.w	r5, [r0, #256]	; 0x100
  p->next       = qp;
 8005470:	f8c0 80f8 	str.w	r8, [r0, #248]	; 0xf8
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);
 8005474:	f8c0 40c8 	str.w	r4, [r0, #200]	; 0xc8
  tp->hdr.pqueue.prio   = prio;
 8005478:	f8c0 90f0 	str.w	r9, [r0, #240]	; 0xf0
  tp->realprio          = prio;
 800547c:	f8c0 9128 	str.w	r9, [r0, #296]	; 0x128
  tp->refs              = (trefs_t)1;
 8005480:	f880 910e 	strb.w	r9, [r0, #270]	; 0x10e
  tp->state             = CH_STATE_WTSTART;
 8005484:	f8a0 b10c 	strh.w	fp, [r0, #268]	; 0x10c
  tp->name              = name;
 8005488:	f8c0 1104 	str.w	r1, [r0, #260]	; 0x104
  tp->owner             = oip;
 800548c:	656d      	str	r5, [r5, #84]	; 0x54
  tp->wabase = tdp->wbase;
 800548e:	f8c0 0108 	str.w	r0, [r0, #264]	; 0x108
  p->prev       = qp->prev;
 8005492:	f8c5 8050 	str.w	r8, [r5, #80]	; 0x50
  oip->rlist.current->wabase = oicp->mainthread_base;
 8005496:	65ec      	str	r4, [r5, #92]	; 0x5c
  oip->rlist.current->state = CH_STATE_CURRENT;
 8005498:	f8a5 9060 	strh.w	r9, [r5, #96]	; 0x60
  tp->refs              = (trefs_t)1;
 800549c:	f885 9062 	strb.w	r9, [r5, #98]	; 0x62
  qp->prev = qp;
 80054a0:	e9c5 221b 	strd	r2, r2, [r5, #108]	; 0x6c
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);
 80054a4:	f100 02c4 	add.w	r2, r0, #196	; 0xc4
 80054a8:	f8c0 20f4 	str.w	r2, [r0, #244]	; 0xf4
  lp->next = lp;
 80054ac:	f500 728a 	add.w	r2, r0, #276	; 0x114
  tp->epending          = (eventmask_t)0;
 80054b0:	e9c0 4448 	strd	r4, r4, [r0, #288]	; 0x120
 80054b4:	e9c5 441d 	strd	r4, r4, [r5, #116]	; 0x74
  qp->next = qp;
 80054b8:	e9c0 2345 	strd	r2, r3, [r0, #276]	; 0x114
  qp->prev = qp;
 80054bc:	f8c0 311c 	str.w	r3, [r0, #284]	; 0x11c
 80054c0:	30e8      	adds	r0, #232	; 0xe8
 80054c2:	f7fb fccd 	bl	8000e60 <__sch_ready_behind.isra.0>
  ch_system.state = ch_sys_running;
 80054c6:	f886 b000 	strb.w	fp, [r6]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 80054ca:	f384 8811 	msr	BASEPRI, r4
 80054ce:	2330      	movs	r3, #48	; 0x30
 80054d0:	f383 8811 	msr	BASEPRI, r3
  if (midi_initialized) {
 80054d4:	4940      	ldr	r1, [pc, #256]	; (80055d8 <main+0x8a8>)
 80054d6:	780a      	ldrb	r2, [r1, #0]
 80054d8:	2a00      	cmp	r2, #0
 80054da:	f000 80a9 	beq.w	8005630 <main+0x900>
 80054de:	f384 8811 	msr	BASEPRI, r4
 * @note Cette procdure est ncessaire sur certaines cartes Nucleo o
 *       la broche VBUS (PA9) nest pas connecte au contrleur OTG FS.
 */
void usb_device_start(void) {
    /* 1. Dconnexion logique pour forcer une r-numration */
    usbDisconnectBus(&USBD1);
 80054e2:	f8da 2090 	ldr.w	r2, [sl, #144]	; 0x90
 80054e6:	2530      	movs	r5, #48	; 0x30
 80054e8:	f8d2 3804 	ldr.w	r3, [r2, #2052]	; 0x804
 80054ec:	f043 0302 	orr.w	r3, r3, #2
 80054f0:	f8c2 3804 	str.w	r3, [r2, #2052]	; 0x804
 80054f4:	f385 8811 	msr	BASEPRI, r5
  (void) chSchGoSleepTimeoutS(CH_STATE_SLEEPING, ticks);
 80054f8:	f643 2198 	movw	r1, #15000	; 0x3a98
 80054fc:	2008      	movs	r0, #8
 80054fe:	f7fc f9ef 	bl	80018e0 <chSchGoSleepTimeoutS>
 8005502:	2400      	movs	r4, #0
 8005504:	f384 8811 	msr	BASEPRI, r4
 8005508:	f385 8811 	msr	BASEPRI, r5
  usbp->config = config;
 800550c:	4b33      	ldr	r3, [pc, #204]	; (80055dc <main+0x8ac>)
    usbp->epc[i] = NULL;
 800550e:	2224      	movs	r2, #36	; 0x24
 8005510:	4621      	mov	r1, r4
 8005512:	4833      	ldr	r0, [pc, #204]	; (80055e0 <main+0x8b0>)
  usbp->config = config;
 8005514:	f8ca 3004 	str.w	r3, [sl, #4]
    usbp->epc[i] = NULL;
 8005518:	f000 f9e4 	bl	80058e4 <memset>
  if (usbp->state == USB_STOP) {
 800551c:	f89a 3000 	ldrb.w	r3, [sl]
 8005520:	2b01      	cmp	r3, #1
 8005522:	f000 8140 	beq.w	80057a6 <main+0xa76>
    usbp->state = USB_READY;
 8005526:	2202      	movs	r2, #2
 8005528:	2300      	movs	r3, #0
 800552a:	f88a 2000 	strb.w	r2, [sl]
 800552e:	f383 8811 	msr	BASEPRI, r3
        USBD1.otg->GCCFG &= ~USB_OTG_GCCFG_VBDEN;
#endif
    }

    /* 4. Connexion logique sur le bus */
    usbConnectBus(&USBD1);
 8005532:	f8da 2090 	ldr.w	r2, [sl, #144]	; 0x90
/*                                API MIDI                                */
/* ====================================================================== */

void midi_note_on(midi_dest_t d,uint8_t ch,uint8_t n,uint8_t v){
  if ((v & 0x7F)==0){ midi_note_off(d,ch,n,0); return; }
  uint8_t m[3]={ (uint8_t)(0x90|(ch&0x0F)), (uint8_t)(n&0x7F), (uint8_t)(v&0x7F) };
 8005536:	f643 4890 	movw	r8, #15504	; 0x3c90
 800553a:	4e2a      	ldr	r6, [pc, #168]	; (80055e4 <main+0x8b4>)
 800553c:	2764      	movs	r7, #100	; 0x64
 800553e:	f8d2 3804 	ldr.w	r3, [r2, #2052]	; 0x804
 8005542:	2530      	movs	r5, #48	; 0x30
 8005544:	f023 0302 	bic.w	r3, r3, #2
 8005548:	f8c2 3804 	str.w	r3, [r2, #2052]	; 0x804
 * @brief Indique si le priphrique USB MIDI est actif et prt  lenvoi.
 *
 * @return true si la couche USB MIDI est initialise et disponible.
 */
bool usb_device_active(void) {
    return usb_midi_tx_ready;
 800554c:	7833      	ldrb	r3, [r6, #0]
  usb_device_start();

  while (true) {

    /* Attendre que lhte ait configur le device (endpoint IN prt) */
    if (!usb_device_active()) {
 800554e:	f003 04ff 	and.w	r4, r3, #255	; 0xff
 8005552:	2b00      	cmp	r3, #0
 8005554:	d148      	bne.n	80055e8 <main+0x8b8>
 8005556:	f385 8811 	msr	BASEPRI, r5
 800555a:	f44f 71fa 	mov.w	r1, #500	; 0x1f4
 800555e:	2008      	movs	r0, #8
 8005560:	f7fc f9be 	bl	80018e0 <chSchGoSleepTimeoutS>
 8005564:	f384 8811 	msr	BASEPRI, r4
 8005568:	7833      	ldrb	r3, [r6, #0]
 800556a:	f003 04ff 	and.w	r4, r3, #255	; 0xff
 800556e:	2b00      	cmp	r3, #0
 8005570:	d0f1      	beq.n	8005556 <main+0x826>
 8005572:	e039      	b.n	80055e8 <main+0x8b8>
 8005574:	40003c00 	.word	0x40003c00
 8005578:	58001400 	.word	0x58001400
 800557c:	5c001000 	.word	0x5c001000
 8005580:	24000d40 	.word	0x24000d40
 8005584:	40080000 	.word	0x40080000
 8005588:	08005e14 	.word	0x08005e14
 800558c:	24000d4c 	.word	0x24000d4c
 8005590:	24000cf0 	.word	0x24000cf0
 8005594:	24000d38 	.word	0x24000d38
 8005598:	24000330 	.word	0x24000330
 800559c:	08000ad1 	.word	0x08000ad1
 80055a0:	24001830 	.word	0x24001830
 80055a4:	24080000 	.word	0x24080000
 80055a8:	08000a91 	.word	0x08000a91
 80055ac:	08005cf0 	.word	0x08005cf0
 80055b0:	e000ed00 	.word	0xe000ed00
 80055b4:	05fa0300 	.word	0x05fa0300
 80055b8:	e0001000 	.word	0xe0001000
 80055bc:	c5acce55 	.word	0xc5acce55
 80055c0:	24000358 	.word	0x24000358
 80055c4:	08005d04 	.word	0x08005d04
 80055c8:	24000bc0 	.word	0x24000bc0
 80055cc:	08000a21 	.word	0x08000a21
 80055d0:	080003d1 	.word	0x080003d1
 80055d4:	08005994 	.word	0x08005994
 80055d8:	24000e24 	.word	0x24000e24
 80055dc:	08005f28 	.word	0x08005f28
 80055e0:	24000258 	.word	0x24000258
 80055e4:	2400153c 	.word	0x2400153c
    case MIDI_DEST_USB:  send_usb(m,n);  break;
 80055e8:	a802      	add	r0, sp, #8
  uint8_t m[3]={ (uint8_t)(0x90|(ch&0x0F)), (uint8_t)(n&0x7F), (uint8_t)(v&0x7F) };
 80055ea:	f8ad 8008 	strh.w	r8, [sp, #8]
 80055ee:	f88d 700a 	strb.w	r7, [sp, #10]
    case MIDI_DEST_USB:  send_usb(m,n);  break;
 80055f2:	f7ff f8dd 	bl	80047b0 <send_usb.constprop.0>
 80055f6:	f385 8811 	msr	BASEPRI, r5
 80055fa:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
 80055fe:	2008      	movs	r0, #8
 8005600:	2400      	movs	r4, #0
 8005602:	f7fc f96d 	bl	80018e0 <chSchGoSleepTimeoutS>
 8005606:	f384 8811 	msr	BASEPRI, r4
  midi_send(d,m,3);
}

void midi_note_off(midi_dest_t d,uint8_t ch,uint8_t n,uint8_t v){
  uint8_t m[3]={ (uint8_t)(0x80|(ch&0x0F)), (uint8_t)(n&0x7F), (uint8_t)(v&0x7F) };
 800560a:	f44f 5372 	mov.w	r3, #15488	; 0x3c80
    case MIDI_DEST_USB:  send_usb(m,n);  break;
 800560e:	a802      	add	r0, sp, #8
  uint8_t m[3]={ (uint8_t)(0x80|(ch&0x0F)), (uint8_t)(n&0x7F), (uint8_t)(v&0x7F) };
 8005610:	f88d 400a 	strb.w	r4, [sp, #10]
 8005614:	f8ad 3008 	strh.w	r3, [sp, #8]
    case MIDI_DEST_USB:  send_usb(m,n);  break;
 8005618:	f7ff f8ca 	bl	80047b0 <send_usb.constprop.0>
 800561c:	f385 8811 	msr	BASEPRI, r5
 8005620:	f242 3128 	movw	r1, #9000	; 0x2328
 8005624:	2008      	movs	r0, #8
 8005626:	f7fc f95b 	bl	80018e0 <chSchGoSleepTimeoutS>
 800562a:	f384 8811 	msr	BASEPRI, r4
}
 800562e:	e78d      	b.n	800554c <main+0x81c>
  midi_initialized = true;
 8005630:	f881 9000 	strb.w	r9, [r1]
 8005634:	f382 8811 	msr	BASEPRI, r2
 8005638:	f383 8811 	msr	BASEPRI, r3
  if (sdp->state == SD_STOP) {
 800563c:	7a3b      	ldrb	r3, [r7, #8]
 800563e:	2b01      	cmp	r3, #1
 8005640:	d10e      	bne.n	8005660 <main+0x930>
  RCC_C1->APB1LENR |= mask;
 8005642:	4b92      	ldr	r3, [pc, #584]	; (800588c <main+0xb5c>)
 8005644:	f8d3 20e8 	ldr.w	r2, [r3, #232]	; 0xe8
 8005648:	f442 2280 	orr.w	r2, r2, #262144	; 0x40000
 800564c:	f8c3 20e8 	str.w	r2, [r3, #232]	; 0xe8
    RCC_C1->APB1LLPENR |= mask;
 8005650:	f8d3 2110 	ldr.w	r2, [r3, #272]	; 0x110
 8005654:	f442 2280 	orr.w	r2, r2, #262144	; 0x40000
 8005658:	f8c3 2110 	str.w	r2, [r3, #272]	; 0x110
  (void)RCC_C1->APB1LLPENR;
 800565c:	f8d3 3110 	ldr.w	r3, [r3, #272]	; 0x110
    brr = (uint32_t)((clock + config->speed/2) / config->speed);
 8005660:	6dba      	ldr	r2, [r7, #88]	; 0x58
 8005662:	f643 5309 	movw	r3, #15625	; 0x3d09
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
 8005666:	2140      	movs	r1, #64	; 0x40
  u->CR3 = config->cr3 | USART_CR3_EIE;
 8005668:	2601      	movs	r6, #1
    brr = (uint32_t)((clock + config->speed/2) / config->speed);
 800566a:	4413      	add	r3, r2
 800566c:	f647 2212 	movw	r2, #31250	; 0x7a12
    sdp->state = SD_READY;
 8005670:	f04f 0c02 	mov.w	ip, #2
 8005674:	fbb3 f2f2 	udiv	r2, r3, r2
  USART_TypeDef *u = sdp->usart;
 8005678:	6d7b      	ldr	r3, [r7, #84]	; 0x54
  u->BRR = brr;
 800567a:	60da      	str	r2, [r3, #12]
  u->ICR = 0xFFFFFFFFU;
 800567c:	f04f 32ff 	mov.w	r2, #4294967295
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
 8005680:	6059      	str	r1, [r3, #4]
  u->CR1 = config->cr1 | USART_CR1_UE | USART_CR1_PEIE |
 8005682:	f240 112d 	movw	r1, #301	; 0x12d
  u->CR3 = config->cr3 | USART_CR3_EIE;
 8005686:	609e      	str	r6, [r3, #8]
  u->CR1 = config->cr1 | USART_CR1_UE | USART_CR1_PEIE |
 8005688:	6019      	str	r1, [r3, #0]
  u->ICR = 0xFFFFFFFFU;
 800568a:	621a      	str	r2, [r3, #32]
 800568c:	2300      	movs	r3, #0
    sdp->rxmask = 0xFF;
 800568e:	f887 205c 	strb.w	r2, [r7, #92]	; 0x5c
 8005692:	f887 c008 	strb.w	ip, [r7, #8]
 8005696:	f383 8811 	msr	BASEPRI, r3
  mbp->buffer = buf;
 800569a:	497d      	ldr	r1, [pc, #500]	; (8005890 <main+0xb60>)
 800569c:	487d      	ldr	r0, [pc, #500]	; (8005894 <main+0xb64>)
 800569e:	4a7e      	ldr	r2, [pc, #504]	; (8005898 <main+0xb68>)
 80056a0:	6008      	str	r0, [r1, #0]
  mbp->cnt    = (size_t)0;
 80056a2:	610b      	str	r3, [r1, #16]
  mbp->reset  = false;
 80056a4:	750b      	strb	r3, [r1, #20]
  mbp->cnt    = (size_t)0;
 80056a6:	6113      	str	r3, [r2, #16]
  mbp->reset  = false;
 80056a8:	7513      	strb	r3, [r2, #20]
  mbp->wrptr  = buf;
 80056aa:	e9c1 0002 	strd	r0, r0, [r1, #8]
  mbp->top    = &buf[n];
 80056ae:	f500 6080 	add.w	r0, r0, #1024	; 0x400
 80056b2:	6048      	str	r0, [r1, #4]
  mbp->buffer = buf;
 80056b4:	4879      	ldr	r0, [pc, #484]	; (800589c <main+0xb6c>)
 80056b6:	6010      	str	r0, [r2, #0]
  mbp->wrptr  = buf;
 80056b8:	e9c2 0002 	strd	r0, r0, [r2, #8]
  mbp->top    = &buf[n];
 80056bc:	f500 7000 	add.w	r0, r0, #512	; 0x200
 80056c0:	6050      	str	r0, [r2, #4]
  qp->next = qp;
 80056c2:	4877      	ldr	r0, [pc, #476]	; (80058a0 <main+0xb70>)
  qp->prev = qp;
 80056c4:	e9c0 0000 	strd	r0, r0, [r0]
  sp->cnt = n;
 80056c8:	6083      	str	r3, [r0, #8]
  qp->next = qp;
 80056ca:	4876      	ldr	r0, [pc, #472]	; (80058a4 <main+0xb74>)
  qp->prev = qp;
 80056cc:	e9c0 0000 	strd	r0, r0, [r0]
 80056d0:	6083      	str	r3, [r0, #8]
  qp->next = qp;
 80056d2:	f101 0018 	add.w	r0, r1, #24
  qp->prev = qp;
 80056d6:	e9c1 0006 	strd	r0, r0, [r1, #24]
  qp->next = qp;
 80056da:	f101 0020 	add.w	r0, r1, #32
  qp->prev = qp;
 80056de:	e9c1 0008 	strd	r0, r0, [r1, #32]
  qp->next = qp;
 80056e2:	f102 0118 	add.w	r1, r2, #24
  qp->prev = qp;
 80056e6:	e9c2 1106 	strd	r1, r1, [r2, #24]
  qp->next = qp;
 80056ea:	f102 0120 	add.w	r1, r2, #32
  qp->prev = qp;
 80056ee:	e9c2 1108 	strd	r1, r1, [r2, #32]
  midi_usb_queue_fill = 0;
 80056f2:	4a6d      	ldr	r2, [pc, #436]	; (80058a8 <main+0xb78>)
 80056f4:	8013      	strh	r3, [r2, #0]
  midi_usb_queue_high_water = 0;
 80056f6:	4a6d      	ldr	r2, [pc, #436]	; (80058ac <main+0xb7c>)
 80056f8:	8013      	strh	r3, [r2, #0]
  midi_usb_rx_queue_fill = 0;
 80056fa:	4a6d      	ldr	r2, [pc, #436]	; (80058b0 <main+0xb80>)
 80056fc:	8013      	strh	r3, [r2, #0]
  midi_usb_rx_queue_high_water = 0;
 80056fe:	4a6d      	ldr	r2, [pc, #436]	; (80058b4 <main+0xb84>)
 8005700:	8013      	strh	r3, [r2, #0]
  midi_usb_rx_drops = 0;
 8005702:	4a6d      	ldr	r2, [pc, #436]	; (80058b8 <main+0xb88>)
 8005704:	6013      	str	r3, [r2, #0]
 8005706:	2230      	movs	r2, #48	; 0x30
 8005708:	f382 8811 	msr	BASEPRI, r2
  tp->wabase = (stkalign_t *)wsp;
 800570c:	4c6b      	ldr	r4, [pc, #428]	; (80058bc <main+0xb8c>)
  PORT_SETUP_CONTEXT(tp, wsp, tp, pf, arg);
 800570e:	4a6c      	ldr	r2, [pc, #432]	; (80058c0 <main+0xb90>)
 8005710:	f504 7721 	add.w	r7, r4, #644	; 0x284
  p->prev       = qp->prev;
 8005714:	6ae8      	ldr	r0, [r5, #44]	; 0x2c
  p->prev->next = p;
 8005716:	f504 712e 	add.w	r1, r4, #696	; 0x2b8
 800571a:	f8c4 22a4 	str.w	r2, [r4, #676]	; 0x2a4
 800571e:	f8c4 72b4 	str.w	r7, [r4, #692]	; 0x2b4
  tp->hdr.pqueue.prio   = prio;
 8005722:	2281      	movs	r2, #129	; 0x81
  PORT_SETUP_CONTEXT(tp, wsp, tp, pf, arg);
 8005724:	4f67      	ldr	r7, [pc, #412]	; (80058c4 <main+0xb94>)
  tp->hdr.pqueue.prio   = prio;
 8005726:	f8c4 22b0 	str.w	r2, [r4, #688]	; 0x2b0
  PORT_SETUP_CONTEXT(tp, wsp, tp, pf, arg);
 800572a:	f8c4 7284 	str.w	r7, [r4, #644]	; 0x284
  tp->name              = name;
 800572e:	4f66      	ldr	r7, [pc, #408]	; (80058c8 <main+0xb98>)
  p->prev       = qp->prev;
 8005730:	f8c4 02bc 	str.w	r0, [r4, #700]	; 0x2bc
  tp->state             = CH_STATE_WTSTART;
 8005734:	f8a4 c2cc 	strh.w	ip, [r4, #716]	; 0x2cc
  p->next       = qp;
 8005738:	f8c4 82b8 	str.w	r8, [r4, #696]	; 0x2b8
  tp->refs              = (trefs_t)1;
 800573c:	f884 62ce 	strb.w	r6, [r4, #718]	; 0x2ce
  PORT_SETUP_CONTEXT(tp, wsp, tp, pf, arg);
 8005740:	f8c4 3288 	str.w	r3, [r4, #648]	; 0x288
  tp->realprio          = prio;
 8005744:	f8c4 22e8 	str.w	r2, [r4, #744]	; 0x2e8
  qp->next = qp;
 8005748:	f504 7236 	add.w	r2, r4, #728	; 0x2d8
  tp->wabase = (stkalign_t *)wsp;
 800574c:	f8c4 42c8 	str.w	r4, [r4, #712]	; 0x2c8
  tp->owner             = oip;
 8005750:	f8c4 52c0 	str.w	r5, [r4, #704]	; 0x2c0
  tp->name              = name;
 8005754:	f8c4 72c4 	str.w	r7, [r4, #708]	; 0x2c4
  tp->epending          = (eventmask_t)0;
 8005758:	e9c4 33b8 	strd	r3, r3, [r4, #736]	; 0x2e0
  p->prev->next = p;
 800575c:	6001      	str	r1, [r0, #0]
  thread_t *otp = __instance_get_currthread(oip);
 800575e:	68e8      	ldr	r0, [r5, #12]
  ntp->u.rdymsg = msg;
 8005760:	f8c4 32d0 	str.w	r3, [r4, #720]	; 0x2d0
  lp->next = lp;
 8005764:	f504 7335 	add.w	r3, r4, #724	; 0x2d4
  qp->prev      = p;
 8005768:	62e9      	str	r1, [r5, #44]	; 0x2c
  lp->next = lp;
 800576a:	f8c4 32d4 	str.w	r3, [r4, #724]	; 0x2d4
  qp->prev = qp;
 800576e:	e9c4 22b6 	strd	r2, r2, [r4, #728]	; 0x2d8
  if (unlikely(ntp->hdr.pqueue.prio <= otp->hdr.pqueue.prio)) {
 8005772:	f8d4 22b0 	ldr.w	r2, [r4, #688]	; 0x2b0
 8005776:	6883      	ldr	r3, [r0, #8]
 8005778:	429a      	cmp	r2, r3
 800577a:	f240 8082 	bls.w	8005882 <main+0xb52>
    otp = __sch_ready_ahead(otp);
 800577e:	f7fb fb47 	bl	8000e10 <__sch_ready_ahead>
  if ((oip->trace_buffer.suspended & CH_DBG_TRACE_MASK_SWITCH) == 0U) {
 8005782:	f8b5 3088 	ldrh.w	r3, [r5, #136]	; 0x88
    ntp->state = CH_STATE_CURRENT;
 8005786:	f884 62cc 	strb.w	r6, [r4, #716]	; 0x2cc
    __instance_set_currthread(oip, ntp);
 800578a:	f504 742a 	add.w	r4, r4, #680	; 0x2a8
 800578e:	079a      	lsls	r2, r3, #30
    otp = __sch_ready_ahead(otp);
 8005790:	4606      	mov	r6, r0
    __instance_set_currthread(oip, ntp);
 8005792:	60ec      	str	r4, [r5, #12]
 8005794:	d567      	bpl.n	8005866 <main+0xb36>
    chSysSwitch(ntp, otp);
 8005796:	4631      	mov	r1, r6
 8005798:	484c      	ldr	r0, [pc, #304]	; (80058cc <main+0xb9c>)
 800579a:	f7fa fe11 	bl	80003c0 <__port_switch>
 800579e:	2300      	movs	r3, #0
 80057a0:	f383 8811 	msr	BASEPRI, r3
  return tp;
 80057a4:	e69d      	b.n	80054e2 <main+0x7b2>
  RCC_C1->AHB1ENR |= mask;
 80057a6:	4b39      	ldr	r3, [pc, #228]	; (800588c <main+0xb5c>)
  NVIC->__ICPR[n >> 5U] = 1U << (n & 0x1FU);
 80057a8:	2520      	movs	r5, #32
  stm32_otg_t *otgp = usbp->otg;
 80057aa:	f8da 0090 	ldr.w	r0, [sl, #144]	; 0x90
 80057ae:	f8d3 10d8 	ldr.w	r1, [r3, #216]	; 0xd8
  NVIC->__IPR[n] = NVIC_PRIORITY_MASK(prio);
 80057b2:	4a47      	ldr	r2, [pc, #284]	; (80058d0 <main+0xba0>)
 80057b4:	f041 6100 	orr.w	r1, r1, #134217728	; 0x8000000
 80057b8:	f8c3 10d8 	str.w	r1, [r3, #216]	; 0xd8
    RCC_C1->AHB1LPENR |= mask;
 80057bc:	f8d3 1100 	ldr.w	r1, [r3, #256]	; 0x100
 80057c0:	f041 6100 	orr.w	r1, r1, #134217728	; 0x8000000
 80057c4:	f8c3 1100 	str.w	r1, [r3, #256]	; 0x100
  (void)RCC_C1->AHB1LPENR;
 80057c8:	f8d3 1100 	ldr.w	r1, [r3, #256]	; 0x100
  RCC->AHB1RSTR |= mask;
 80057cc:	f8d3 1080 	ldr.w	r1, [r3, #128]	; 0x80
 80057d0:	f041 6100 	orr.w	r1, r1, #134217728	; 0x8000000
 80057d4:	f8c3 1080 	str.w	r1, [r3, #128]	; 0x80
  RCC->AHB1RSTR &= ~mask;
 80057d8:	f8d3 1080 	ldr.w	r1, [r3, #128]	; 0x80
 80057dc:	f021 6100 	bic.w	r1, r1, #134217728	; 0x8000000
 80057e0:	f8c3 1080 	str.w	r1, [r3, #128]	; 0x80
  (void)RCC->AHB1RSTR;
 80057e4:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 80057e8:	23e0      	movs	r3, #224	; 0xe0
 80057ea:	f882 3365 	strb.w	r3, [r2, #869]	; 0x365
      otgp->GUSBCFG = GUSBCFG_FDMOD | GUSBCFG_TRDT(TRDT_VALUE_FS) |
 80057ee:	4b39      	ldr	r3, [pc, #228]	; (80058d4 <main+0xba4>)
  NVIC->__ICPR[n >> 5U] = 1U << (n & 0x1FU);
 80057f0:	f8c2 518c 	str.w	r5, [r2, #396]	; 0x18c
  NVIC->__ISER[n >> 5U] = 1U << (n & 0x1FU);
 80057f4:	60d5      	str	r5, [r2, #12]
 80057f6:	60c3      	str	r3, [r0, #12]
      otgp->DCFG = 0x02200000 | DCFG_DSPD_FS11;
 80057f8:	4b37      	ldr	r3, [pc, #220]	; (80058d8 <main+0xba8>)
 80057fa:	f8c0 3800 	str.w	r3, [r0, #2048]	; 0x800
    otgp->GOTGCTL = GOTGCTL_BVALOEN | GOTGCTL_BVALOVAL;
 80057fe:	23c0      	movs	r3, #192	; 0xc0
    otgp->PCGCCTL = 0;
 8005800:	f8c0 4e00 	str.w	r4, [r0, #3584]	; 0xe00
    otgp->GOTGCTL = GOTGCTL_BVALOEN | GOTGCTL_BVALOVAL;
 8005804:	6003      	str	r3, [r0, #0]
    otgp->GCCFG = GCCFG_INIT_VALUE;
 8005806:	f44f 1304 	mov.w	r3, #2162688	; 0x210000
 800580a:	6383      	str	r3, [r0, #56]	; 0x38
  while ((otgp->GRSTCTL & GRSTCTL_AHBIDL) == 0)
 800580c:	6903      	ldr	r3, [r0, #16]
 800580e:	2b00      	cmp	r3, #0
 8005810:	dafc      	bge.n	800580c <main+0xadc>
  otgp->GRSTCTL = GRSTCTL_CSRST;
 8005812:	2301      	movs	r3, #1
 8005814:	4a31      	ldr	r2, [pc, #196]	; (80058dc <main+0xbac>)
 8005816:	6103      	str	r3, [r0, #16]
 8005818:	6851      	ldr	r1, [r2, #4]
 800581a:	6853      	ldr	r3, [r2, #4]
  return (bool)(((rtcnt_t)cnt - (rtcnt_t)start) <
 800581c:	1a5b      	subs	r3, r3, r1
  while (chSysIsCounterWithinX(chSysGetRealtimeCounterX(), start, end)) {
 800581e:	2b0b      	cmp	r3, #11
 8005820:	d9fb      	bls.n	800581a <main+0xaea>
  while ((otgp->GRSTCTL & GRSTCTL_CSRST) != 0)
 8005822:	6903      	ldr	r3, [r0, #16]
 8005824:	07db      	lsls	r3, r3, #31
 8005826:	d4fc      	bmi.n	8005822 <main+0xaf2>
 8005828:	4a2c      	ldr	r2, [pc, #176]	; (80058dc <main+0xbac>)
 800582a:	6851      	ldr	r1, [r2, #4]
 800582c:	6853      	ldr	r3, [r2, #4]
  return (bool)(((rtcnt_t)cnt - (rtcnt_t)start) <
 800582e:	1a5b      	subs	r3, r3, r1
  while (chSysIsCounterWithinX(chSysGetRealtimeCounterX(), start, end)) {
 8005830:	2b11      	cmp	r3, #17
 8005832:	d9fb      	bls.n	800582c <main+0xafc>
  while ((otgp->GRSTCTL & GRSTCTL_AHBIDL) == 0)
 8005834:	6903      	ldr	r3, [r0, #16]
 8005836:	2b00      	cmp	r3, #0
 8005838:	dafc      	bge.n	8005834 <main+0xb04>
    otgp->GAHBCFG = 0;
 800583a:	2400      	movs	r4, #0
    otg_disable_ep(usbp);
 800583c:	f8da 1094 	ldr.w	r1, [sl, #148]	; 0x94
    otgp->GAHBCFG = 0;
 8005840:	6084      	str	r4, [r0, #8]
    otg_disable_ep(usbp);
 8005842:	f7fb fab5 	bl	8000db0 <otg_disable_ep.isra.0>
      otgp->GINTMSK  = GINTMSK_ENUMDNEM | GINTMSK_USBRSTM | GINTMSK_USBSUSPM |
 8005846:	4b26      	ldr	r3, [pc, #152]	; (80058e0 <main+0xbb0>)
    otgp->DIEPMSK  = 0;
 8005848:	f8c0 4810 	str.w	r4, [r0, #2064]	; 0x810
    otgp->DOEPMSK  = 0;
 800584c:	f8c0 4814 	str.w	r4, [r0, #2068]	; 0x814
    otgp->DAINTMSK = 0;
 8005850:	f8c0 481c 	str.w	r4, [r0, #2076]	; 0x81c
      otgp->GINTMSK  = GINTMSK_ENUMDNEM | GINTMSK_USBRSTM | GINTMSK_USBSUSPM |
 8005854:	6183      	str	r3, [r0, #24]
    otgp->GINTSTS  = 0xFFFFFFFF;
 8005856:	f04f 33ff 	mov.w	r3, #4294967295
 800585a:	6143      	str	r3, [r0, #20]
    otgp->GAHBCFG |= GAHBCFG_GINTMSK;
 800585c:	6883      	ldr	r3, [r0, #8]
 800585e:	f043 0301 	orr.w	r3, r3, #1
 8005862:	6083      	str	r3, [r0, #8]
 8005864:	e65f      	b.n	8005526 <main+0x7f6>
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_SWITCH;
 8005866:	f890 3024 	ldrb.w	r3, [r0, #36]	; 0x24
 800586a:	f8d5 208c 	ldr.w	r2, [r5, #140]	; 0x8c
 800586e:	00db      	lsls	r3, r3, #3
 8005870:	6a81      	ldr	r1, [r0, #40]	; 0x28
    oip->trace_buffer.ptr->u.sw.ntp    = ntp;
 8005872:	6094      	str	r4, [r2, #8]
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_SWITCH;
 8005874:	f043 0302 	orr.w	r3, r3, #2
    oip->trace_buffer.ptr->u.sw.wtobjp = otp->u.wtobjp;
 8005878:	60d1      	str	r1, [r2, #12]
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_SWITCH;
 800587a:	7013      	strb	r3, [r2, #0]
    trace_next(oip);
 800587c:	f7fb fa78 	bl	8000d70 <trace_next.constprop.0>
 8005880:	e789      	b.n	8005796 <main+0xa66>
    (void) __sch_ready_behind(ntp);
 8005882:	f504 702a 	add.w	r0, r4, #680	; 0x2a8
 8005886:	f7fb faeb 	bl	8000e60 <__sch_ready_behind.isra.0>
 800588a:	e788      	b.n	800579e <main+0xa6e>
 800588c:	58024400 	.word	0x58024400
 8005890:	24000e54 	.word	0x24000e54
 8005894:	24000e7c 	.word	0x24000e7c
 8005898:	24001284 	.word	0x24001284
 800589c:	240012ac 	.word	0x240012ac
 80058a0:	2400152c 	.word	0x2400152c
 80058a4:	24001520 	.word	0x24001520
 80058a8:	2400127c 	.word	0x2400127c
 80058ac:	2400127e 	.word	0x2400127e
 80058b0:	240014ac 	.word	0x240014ac
 80058b4:	240014ae 	.word	0x240014ae
 80058b8:	24001280 	.word	0x24001280
 80058bc:	24001540 	.word	0x24001540
 80058c0:	080003d1 	.word	0x080003d1
 80058c4:	080049d1 	.word	0x080049d1
 80058c8:	0800599c 	.word	0x0800599c
 80058cc:	240017e8 	.word	0x240017e8
 80058d0:	e000e100 	.word	0xe000e100
 80058d4:	40001440 	.word	0x40001440
 80058d8:	02200003 	.word	0x02200003
 80058dc:	e0001000 	.word	0xe0001000
 80058e0:	c0303c08 	.word	0xc0303c08

080058e4 <memset>:
 80058e4:	0783      	lsls	r3, r0, #30
 80058e6:	b530      	push	{r4, r5, lr}
 80058e8:	d048      	beq.n	800597c <memset+0x98>
 80058ea:	1e54      	subs	r4, r2, #1
 80058ec:	2a00      	cmp	r2, #0
 80058ee:	d03f      	beq.n	8005970 <memset+0x8c>
 80058f0:	b2ca      	uxtb	r2, r1
 80058f2:	4603      	mov	r3, r0
 80058f4:	e001      	b.n	80058fa <memset+0x16>
 80058f6:	3c01      	subs	r4, #1
 80058f8:	d33a      	bcc.n	8005970 <memset+0x8c>
 80058fa:	f803 2b01 	strb.w	r2, [r3], #1
 80058fe:	079d      	lsls	r5, r3, #30
 8005900:	d1f9      	bne.n	80058f6 <memset+0x12>
 8005902:	2c03      	cmp	r4, #3
 8005904:	d92d      	bls.n	8005962 <memset+0x7e>
 8005906:	b2cd      	uxtb	r5, r1
 8005908:	ea45 2505 	orr.w	r5, r5, r5, lsl #8
 800590c:	2c0f      	cmp	r4, #15
 800590e:	ea45 4505 	orr.w	r5, r5, r5, lsl #16
 8005912:	d936      	bls.n	8005982 <memset+0x9e>
 8005914:	f1a4 0210 	sub.w	r2, r4, #16
 8005918:	f022 0c0f 	bic.w	ip, r2, #15
 800591c:	f103 0e20 	add.w	lr, r3, #32
 8005920:	44e6      	add	lr, ip
 8005922:	ea4f 1c12 	mov.w	ip, r2, lsr #4
 8005926:	f103 0210 	add.w	r2, r3, #16
 800592a:	e942 5504 	strd	r5, r5, [r2, #-16]
 800592e:	e942 5502 	strd	r5, r5, [r2, #-8]
 8005932:	3210      	adds	r2, #16
 8005934:	4572      	cmp	r2, lr
 8005936:	d1f8      	bne.n	800592a <memset+0x46>
 8005938:	f10c 0201 	add.w	r2, ip, #1
 800593c:	f014 0f0c 	tst.w	r4, #12
 8005940:	eb03 1202 	add.w	r2, r3, r2, lsl #4
 8005944:	f004 0c0f 	and.w	ip, r4, #15
 8005948:	d013      	beq.n	8005972 <memset+0x8e>
 800594a:	f1ac 0304 	sub.w	r3, ip, #4
 800594e:	f023 0303 	bic.w	r3, r3, #3
 8005952:	3304      	adds	r3, #4
 8005954:	4413      	add	r3, r2
 8005956:	f842 5b04 	str.w	r5, [r2], #4
 800595a:	4293      	cmp	r3, r2
 800595c:	d1fb      	bne.n	8005956 <memset+0x72>
 800595e:	f00c 0403 	and.w	r4, ip, #3
 8005962:	b12c      	cbz	r4, 8005970 <memset+0x8c>
 8005964:	b2c9      	uxtb	r1, r1
 8005966:	441c      	add	r4, r3
 8005968:	f803 1b01 	strb.w	r1, [r3], #1
 800596c:	429c      	cmp	r4, r3
 800596e:	d1fb      	bne.n	8005968 <memset+0x84>
 8005970:	bd30      	pop	{r4, r5, pc}
 8005972:	4664      	mov	r4, ip
 8005974:	4613      	mov	r3, r2
 8005976:	2c00      	cmp	r4, #0
 8005978:	d1f4      	bne.n	8005964 <memset+0x80>
 800597a:	e7f9      	b.n	8005970 <memset+0x8c>
 800597c:	4603      	mov	r3, r0
 800597e:	4614      	mov	r4, r2
 8005980:	e7bf      	b.n	8005902 <memset+0x1e>
 8005982:	461a      	mov	r2, r3
 8005984:	46a4      	mov	ip, r4
 8005986:	e7e0      	b.n	800594a <memset+0x66>
